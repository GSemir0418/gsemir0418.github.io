<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on GSemir Blog</title>
    <link>https://gsemir0418.github.io/posts/</link>
    <description>Recent content in Posts on GSemir Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Jun 2021 09:30:55 +0800</lastBuildDate><atom:link href="https://gsemir0418.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Array常用方法整理</title>
      <link>https://gsemir0418.github.io/posts/array/</link>
      <pubDate>Mon, 28 Jun 2021 09:30:55 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/array/</guid>
      <description>Array.prototype.map() 1.关键词：遍历 2.是否修改原数组：false 3.返回值： newArray[]，回调函数的结果组成了新数组的每一个元素。
4.语法： var new_array = arr.map((currentValue, index, array) =&amp;gt; { // callback })  currentValue：callback数组中正在处理的当前元素； index：可选，callback数组中正在处理的当前元素的索引； array：可选，map方法调用的数组，几乎不用  5.描述 map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。
因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。
callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。
6.示例 // 求数组中每个元素的平方根 const arr = [4, 9, 16] const newArr = arr.map(Math.sqrt)// [2, 3, 4]  // 使用map重新格式化数组中的对象 const arr = [ { key:1, value:10 }, { key:2, value:20 } ] const newArr = arr.</description>
    </item>
    
    <item>
      <title>React入门</title>
      <link>https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 25 Jun 2021 23:11:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/</guid>
      <description>1.React是什么 用于构建用户界面的JS库（操作DOM呈现页面）
是一个将数据渲染为HTML视图的开源的JavaScript库
 官网：https://react.docschina.org/
 2.谁开发的 Facebook
3.为什么要学   原生JS操作DOM繁琐、效率低（DOM-API操作UI）
  使用js直接操作DOM，浏览器会进行大量的重绘重排
  原生js没有组件化的编码方案，代码复用率低
模块化是针对js的，可以把js拆分成独立的功能模块，方便复用。但是html结构和css样式，包括字体图片音频视频等，复用率低。
  4.React的特点   用组件化模式、声明式编码，提高开发效率及组件复用率
之前使用的是命令式编码，面向过程。比如我想喝一杯水，需要命令别人先站起来，再走到水杯旁，把我帮我拿过来等等的步骤；但是声明式编码只需我说嗓子干了，自动就会帮我把水拿过来。
  在React Native中可以使用React语法进行移动端开发。
React Native可以使得前端开发人员使用最熟悉的js来编写安卓和ios应用。
  使用虚拟DOM+优秀的Diffing算法，尽量减少与真实DOM的交互
  ​	虚拟DOM发生改变后会对比之前的虚拟DOM，从而减少真实DOM的更新渲染过程
5. React基本使用 5.1 js库引入（注意引入顺序） 1.react.development.js：react核心库
2.react-dom.development.js：提供操作DOM的react扩展库
3.babel.min.js：解析JSX语法代码转为js代码的库
5.2 虚拟DOM的创建 5.2.1 关于虚拟DOM （1）本质上是object类型的一般对象
（2）虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是react内部在用，无需真实DOM上那么多属性
（3）虚拟DOM最终会被React转化为真实DOM，呈现在页面上
5.2.2 创建的两种方式 （1）纯js方式
const VDOM = React.createElement(&amp;#39;标签名&amp;#39;,{标签属性},&amp;#39;标签内容&amp;#39;) const VDOM = React.createElement(&amp;#39;h1&amp;#39;,{id:&amp;#39;title&amp;#39;},&amp;#39;React.createElement(&amp;#39;span&amp;#39;,{},&amp;#39;HELLO REACT!&amp;#39;)&amp;#39;) ​	可以看到，若遇标签嵌套情况，利用纯js来写非常复杂。
（2）JSX方式
​	是react 定义的一种类似于 XML 的 JS 扩展语法: JS + XML。本质是React.</description>
    </item>
    
    <item>
      <title>初识Hooks</title>
      <link>https://gsemir0418.github.io/posts/reacthooks/</link>
      <pubDate>Fri, 25 Jun 2021 23:07:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/reacthooks/</guid>
      <description>1 Hook简介 1.1 基本概念 Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使⽤ state 以及其他的 React 特性。
1.2 React Hooks优势   函数组件不能使⽤state，⼀般只⽤于⼀些简单⽆交互的组件，⽤作信息展示，即我们上⾯说的傻⽠组件使⽤，如果需要交互更改状态等复杂逻辑时就需要使⽤class组件了
React Hooks让我们更好的拥抱函数式编程，让函数式组件也能使⽤state功能，因为函数式组件⽐class组件更简洁好⽤，因为React Hooks的出现，相信未来我们会更多的使⽤函数式组件
  副作⽤问题
我们⼀般称数据获取、订阅、定时执⾏任务、⼿动修改ReactDOM这些⾏为都可以称为副作⽤由于React Hooks的出现，我们可以使⽤useEffect来处理组件副作⽤问题，所以我们的函数式组件也能进⾏副作⽤逻辑的处理了
  有状态的逻辑重⽤组件
  复杂的状态管理
之前我们使⽤redux、dva、mobx第三⽅状态管理器来进⾏复杂的状态管理
现在我们可以使⽤useReducer、useContext配合使⽤实现复杂状态管理，不⽤再依赖第三⽅状态管理器
  开发效率和质量问题
函数式组件⽐class组件简洁，开发的体验更好，效率更⾼同时应⽤的性能也更好
   2 useState 2.1 定义 useState：组件状态管理钩⼦，使函数组件能够使⽤state
2.2 基本使用 const [state,setState]=useState(initState)  state是要设置的状态 setState是更新state的⽅法，只是⼀个⽅法名，可以随意更改 initState是初始的state，可以是随意的数据类型，也可以是回调函数，但是函数必须是有返回值  2.3 实际应用 import React, { useState } from &amp;#39;react&amp;#39; export default function UseS() { const [count, setState] = useState(0) return ( &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;你点击了{count}次&amp;lt;/div&amp;gt; &amp;lt;button onClick={() =&amp;gt; setState(count + 1)}&amp;gt;点 击&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ) }  3 useEffect 3.</description>
    </item>
    
    <item>
      <title>antdpro&#43;umi实战</title>
      <link>https://gsemir0418.github.io/posts/antdpro&#43;umi%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 25 Jun 2021 22:51:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/antdpro&#43;umi%E5%AE%9E%E6%88%98/</guid>
      <description>本文通过一个todo list 的小项目演示，实现三个功能：
 列表功能，列出所有todo项； 添加新项，添加新的todo项； 更新项，更新现有的todo项状态，修改成待办、已完成或者取消  数据结构：
{id : 1, // 唯一标识title : &amp;quot;完成antdpro实战&amp;quot;, // 待办事项标题status : 0 // 状态：0-待办，1-已完成，2-已取消}创建新项目 新建项目目录
mkdir todo-listcd todo-list执行
yarn create umi选择ant-design-pro、JavaScript、simple，完成项目的创建
目录结构 ├── config # umi 配置，包含路由，构建等配置├── mock # 本地模拟数据├── public # 一些公共静态资源├── src│ ├── assets # 本地静态资源│ ├── components # 业务通用组件│ ├── e2e # 集成测试用例│ ├── layouts # 通用布局│ ├── models # 全局 dva model│ ├── pages # 业务页面入口和常用模板│ ├── services # 后台接口服务│ ├── utils # 工具库│ ├── locales # 国际化资源│ ├── global.</description>
    </item>
    
    <item>
      <title>Node文件模块</title>
      <link>https://gsemir0418.github.io/posts/node%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Fri, 25 Jun 2021 14:40:55 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/node%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/</guid>
      <description>1 待办事项命令行程序需求   功能：
  可以列出所有的todo；
  新增、编辑、删除todo；
  修改todo状态为已完成/未完成
    命令
t t add 任务名 t clear   2 创建命令行项目  空文件夹下，执行：  yarn init -y -y表示跳过交互式对话（确定版本等信息），根据默认值生成package.json
 创建index.js，引入commanderjs库，添加add和clear子命令：  const program = require(&amp;#39;commander&amp;#39;); program .option(&amp;#39;-x,--xxx&amp;#39;, &amp;#39;desc of x&amp;#39;)// x选项 即在node index命令后输入的选项 program .command(&amp;#39;add&amp;#39;)// 子命令 	.description(&amp;#39;add a task&amp;#39;)// 子命令描述 	.action((...args) =&amp;gt; { //拿到用户输入的所有字符串参数  const words = args.slice(0,-1).join(&amp;#39; &amp;#39;)// 由于最后一个参数默认是command对象，因此需要对参数进行预处理 	}) program .</description>
    </item>
    
    <item>
      <title>React组件生命周期</title>
      <link>https://gsemir0418.github.io/posts/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Fri, 25 Jun 2021 11:09:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>1 生命周期的理解 1.1 引出生命周期  需求：
 让指定的文本做显示* */* 隐藏的渐变动画 从完全可见，到彻底消失，耗时2S 点击“不活了”按钮从界面中卸载组件   源码及笔记如下：
class Life extends React.Component { //只要页面发生更新，则说明是状态在驱动  state = { opacity: 0.5 } death = () =&amp;gt; { ReactDOM.unmountComponentAtNode(document.getElementById(&amp;#39;test&amp;#39;)) } //和render一样 是由React帮忙调用的 因此不用写成箭头函数的形式  //执行时机：组件挂载到页面后  componentDidMount() { //起个名字 挂到实例自身 方便清除时用  this.timer = setInterval(() =&amp;gt; { //获取状态值  let opacity = this.state.opacity //每次-0.1  opacity -= 0.1 if (opacity &amp;lt;= 0) opacity = 1 //设置新的透明度  this.</description>
    </item>
    
    <item>
      <title>React基础</title>
      <link>https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 29 Apr 2021 23:11:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/</guid>
      <description>1 React定义组件 1.1 函数式组件  函数式组件适用于简单组件的定义，其首字母需大写，且虚拟DOM元素必须有结束标签 函数组件中的this指向为window，但babel编译后默认开启了严格模式，因此结果为undefined 返回的虚拟DOM元素只能有一个根元素 渲染函数式组件的过程：  React解析组件标签，找到了Demo组件 发现组件式使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM。随后呈现在页面中    function Demo(){ console.log(this);//undefined 	return &amp;lt;h1&amp;gt;函数式组件，适用于简单组件的定义&amp;lt;/h1&amp;gt; } ReactDOM.render(&amp;lt;Demo/&amp;gt;,document.getElementById(&amp;#39;test&amp;#39;)) 1.2 类式组件   继承React.Component类，组件名首字母必须大写，且虚拟DOM元素必须有结束标签
  必须有render()方法，且render方法必须有返回值，返回的虚拟DOM元素只能有一个根元素
  渲染类式组件的过程
1.React 内部会创建组件实例对象
2.调用 render()得到虚拟 DOM, 并解析为真实 DOM
3.插入到指定的页面元素内部
  class MyComponent extends React.Component{ render(){ //render放在MyComponent的原型对象（React.Component）上，供实例使用 	//render中的this指向MyComponent实例对象（组件实例对象） 	console.log(&amp;#39;render方法中的this指向：&amp;#39;,this); return &amp;lt;h1&amp;gt;类式组件，适用于复杂组件的定义&amp;lt;/h1&amp;gt; } } ReactDOM.render(&amp;lt;MyComponent/&amp;gt;,document.getElementById(&amp;#39;test&amp;#39;))  2 组件实例三大属性 2.1 state 2.1.1 state基本使用 state 是组件对象最重要的属性，值是对象(可以包含多个 key-value 的组合)</description>
    </item>
    
    <item>
      <title>展示平台说明文档</title>
      <link>https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</link>
      <pubDate>Fri, 08 Jan 2021 23:15:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</guid>
      <description>1. 模型展示页面 ​	模型展示页面是基于There.js库、模型和材质加载器以及控制器，实现模型在web端的简单展示。具体实现逻辑已写好，用户只需修改obj模型路径等简单操作即可实现模型展示demo。obj模型导出及注意事项见3dsMax技术文档。模板已发布到GitHub供读者学习参考：
 https://github.com/GSemir0418/TemplateProjects
 ​	下图为项目目录结构：
​	其中，js文件夹包含全部Javascript脚本文件，models文件夹用来存储obj模型，index.html是项目的主页。
​	js文件夹中，除index.js外，均是由Three.js为我们提供的模型加载器和控制器脚本文件。而页面的主要逻辑全部封装到了index.js中。
1.1 更改网页名称 ​	在index.html文件中，修改&amp;lt;title&amp;gt;标签内的内容即可：
&amp;lt;title&amp;gt;XXX村寨模型展示&amp;lt;/title&amp;gt;1.2 修改模型路径 ​	首先将obj模型拷贝至models文件夹下。
​	在js/index.js文件中，修改15和16行的代码如下：
//模型路径let mat1 = &#39;./models/testobj/lancuiting.mtl&#39;;let obj1 = &#39;./models/testobj/lancuiting.obj&#39;;​	注意路径使用相对路径。
1.3 控制模型体积 ​	js/index.js文件中，修改51行代码中的参数即可，注意三个数字应保持一致：
model1.scale.set(1.4, 1.4, 1.4);1.4 其他可配置选项 ​	如需修改灯光位置及强度，可以修改js/index.js文件中46和47行代码：
//括号中的2为强度let dLight = new THREE.DirectionalLight(0xFFFFFF, 2);//光源的位置dLight.position.set(500, 1000, 4000); 2. Turn.js翻页特效 ​	展示平台的第一个模块是少数民族建筑特征分析。针对大量的图文资料，传统的页面布局得不到很好的展示与交互效果。为提高用户体验，选择类似书本翻页的形式作为展示图文视频资料的方式。Turn.js是一个JavaScript库，利用HTML5的所有优点，可以使内容呈现起来像一本真正的书或杂志。
​	关于Turn.js的入门教程可以看siki学院的免费课程，也可以通过官网进行学习。
 siki学院：http://www.sikiedu.com/course/517/tasks
Turn.js官网：http://www.turnjs.com/
 ​	由于少数民族建筑资料篇幅较多，文章内容比较复杂，且Turn.js并没有为用户提供书页模板，全部样式都是用户在CSS中定义的。考虑到书页制作的便捷性与美观性，选择PPT来制作展示书籍的内容，再以加载图片的方式将内容加载到网页端，实现具有翻页效果的少数民族建筑特征分析资料展示模块。</description>
    </item>
    
    <item>
      <title>3dsMax技术文档</title>
      <link>https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Fri, 08 Jan 2021 16:41:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
      <description>1. 3dsMax概述 ​	3dsMax是由AutoDesk公司开发的三维模型与动画制作渲染软件，它被广泛应用于多个领域，包括游戏设计、广告设计、建筑设计和影视制作等。其优点是具有强大的材质编辑和灯光处理功能，并且相关的学习资源非常丰富。在后期的模型渲染上功能强大，能够得到逼真的模型。同其他建模软件相比，3dsMax创建的模型面片数量较少，占用空间小，模型的处理速度也比较快。本课题正是应用其强大的模型兼容性以及材质编辑功能，作为单体建筑模型后期纹理映射和OBJ模型导出的重要软件。
 2. 3dsMax软件安装 ​	3dsMax软件发展至今，从最初的3D Studio MAX 1.0开始，其版本迭代更新二十余次，截至文章发布前，Autodesk公司已推出3dsMax 2021。考虑到兼容性、稳定性等问题，推荐安装3dsMax 2016之后的版本。
​	本章以3dsMax 2020软件安装为例，详细介绍软件安装的过程及注意事项。
2.1 解压缩安装包 ​	将安装包及注册机文件解压缩至目标文件夹，注意目标文件夹名称及路径应保证全英文。
​	为防止安装破解过程中出现未知错误，建议安装前关闭所有杀毒软件。
2.2 安装软件 ​	进入安装包文件夹，右键单击Setup.exe，选择以管理员身份运行；
​
在打开的窗口中选择安装（在此计算机安装）。
许可协议选择我接受，单击下一步。
设置安装路径后，点击安装即可。注意路径仍要保证全英文。
安装完成后，选择立即启动。
2.3 破解软件 ​	第一次进入软件后，选择enter a serial number输入序列号。
​	选择 I Agree我同意。
​	进入激活页面，选择Activate激活。
​	在Serial Number栏中填写序列号666-69696969，单击Next。
​	第一次会提醒”检测到无效的序列号“，此时选择重新输入，将序列号再次输入即可。
​	当进入到激活选项窗口，复制Request code请求码。右键单击安装包中的xf-adesk20.exe破解工具，选择以管理员身份运行。
​	将请求码复制到破解工具中的Request栏后，先单击Patch，再点击Generate，复制Activation栏中自动生成的激活码。
​	拿到激活码后，回到激活选项页面，选择I have an activation code from Autodesk，把激活码复制到输入框后，点击Next。
​	激活完成，选择Finish退出激活窗口。
​	至此，3dsMax 2020安装完成。
2.4 修改软件语言 ​	3dsMax软件支持简体中文，切换中文版本也很简单，点击开始，找到Autodesk文件夹，选择3dMax 2020 - simplified Chinese即可。</description>
    </item>
    
    <item>
      <title>Revit建模技术文档</title>
      <link>https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sun, 03 Jan 2021 16:41:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
      <description>1. Revit概述 2.安装软件 3.点云数据导入 3.1 直接导入 3.2 Recap 4.构件族与模型搭建 4.1 建模流程概述 4.2 轴网布局 4.3 木框架搭建 4.4 屋顶 4.4.1 歇山式屋顶 4.4.2 悬山式屋顶 4.5 门板 4.6 其他构件 4.7 FBX模型导出 5.绘制施工图纸 </description>
    </item>
    
    <item>
      <title>StartBlog</title>
      <link>https://gsemir0418.github.io/posts/startblog/</link>
      <pubDate>Sun, 03 Jan 2021 16:41:51 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/startblog/</guid>
      <description>Step1 安装hugo  下载链接：https://github.com/gohugoio/hugo/releases
 选择最新版本进行安装（建议安装hugo_extended版本）。
注意解压后需配置环境变量，可以使用version命令测试是否配置成功：
hugo versionStep2 新建博客站点 使用命令行，输入如下命令新建博客站点：
hugo new site BLOGNAMEStep3 下载并配置主题  主题下载链接：https://themes.gohugo.io/
 官网提供了许多主题供用户选择，按照主题下的安装配置说明进行主题的下载与配置。
这里以Diary主题为例，首先在博客的根目录下，使用终端进行git初始化：
git init并执行：
git submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary主题会自动下载至根目录下的themes文件夹中。下载完成后，启动hugo本地服务并指定该主题：
hugo server -t diary --buildDrafts可以通过访问localhost:1313进入本地部署的博客站点。可以看到，hugo已经为我们配置好了下载的主题。
Step4 新建博客 同样，在终端中执行：
hugo new post/文章名称.md可以使用Typora来编辑文章，就像我现在这样。
Step5 部署到github 首先进入自己的github，新建一个repository，注意名称要使用小写昵称全名.github.io。
在终端执行：
hugo --theme=diary --baseUrl=&amp;quot;https://gsemir0418.github.io/&amp;quot; --buildDrafts此时在根目录下，hugo为我们生成了一个public文件夹，我们只需利用github将此文件夹上传到库中即可。
在public文件夹下，进行git初始化。
git initgit add .git commit -m &amp;quot;v0&amp;quot;此时需要注册GitHub信息
git config --global user.email &amp;quot;you@example.com&amp;quot;git config --global user.</description>
    </item>
    
  </channel>
</rss>
