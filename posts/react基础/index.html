<!DOCTYPE html>
<html><head>
<title>React基础</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="React基础" />
<meta property="og:description" content="1 React定义组件 1.1 函数式组件  函数式组件适用于简单组件的定义，其首字母需大写，且虚拟DOM元素必须有结束标签 函数组件中的this指向为window，但babel编译后默认开启了严格模式，因此结果为undefined 返回的虚拟DOM元素只能有一个根元素 渲染函数式组件的过程：  React解析组件标签，找到了Demo组件 发现组件式使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM。随后呈现在页面中    function Demo(){ console.log(this);//undefined 	return &lt;h1&gt;函数式组件，适用于简单组件的定义&lt;/h1&gt; } ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;)) 1.2 类式组件   继承React.Component类，组件名首字母必须大写，且虚拟DOM元素必须有结束标签
  必须有render()方法，且render方法必须有返回值，返回的虚拟DOM元素只能有一个根元素
  渲染类式组件的过程
1.React 内部会创建组件实例对象
2.调用 render()得到虚拟 DOM, 并解析为真实 DOM
3.插入到指定的页面元素内部
  class MyComponent extends React.Component{ render(){ //render放在MyComponent的原型对象（React.Component）上，供实例使用 	//render中的this指向MyComponent实例对象（组件实例对象） 	console.log(&#39;render方法中的this指向：&#39;,this); return &lt;h1&gt;类式组件，适用于复杂组件的定义&lt;/h1&gt; } } ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#39;test&#39;))  2 组件实例三大属性 2.1 state 2.1.1 state基本使用 state 是组件对象最重要的属性，值是对象(可以包含多个 key-value 的组合)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-29T23:11:51+08:00" />
<meta property="article:modified_time" content="2021-04-29T23:11:51+08:00" /><meta property="og:site_name" content="My Blog" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="React基础"/>
<meta name="twitter:description" content="1 React定义组件 1.1 函数式组件  函数式组件适用于简单组件的定义，其首字母需大写，且虚拟DOM元素必须有结束标签 函数组件中的this指向为window，但babel编译后默认开启了严格模式，因此结果为undefined 返回的虚拟DOM元素只能有一个根元素 渲染函数式组件的过程：  React解析组件标签，找到了Demo组件 发现组件式使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM。随后呈现在页面中    function Demo(){ console.log(this);//undefined 	return &lt;h1&gt;函数式组件，适用于简单组件的定义&lt;/h1&gt; } ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;)) 1.2 类式组件   继承React.Component类，组件名首字母必须大写，且虚拟DOM元素必须有结束标签
  必须有render()方法，且render方法必须有返回值，返回的虚拟DOM元素只能有一个根元素
  渲染类式组件的过程
1.React 内部会创建组件实例对象
2.调用 render()得到虚拟 DOM, 并解析为真实 DOM
3.插入到指定的页面元素内部
  class MyComponent extends React.Component{ render(){ //render放在MyComponent的原型对象（React.Component）上，供实例使用 	//render中的this指向MyComponent实例对象（组件实例对象） 	console.log(&#39;render方法中的this指向：&#39;,this); return &lt;h1&gt;类式组件，适用于复杂组件的定义&lt;/h1&gt; } } ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#39;test&#39;))  2 组件实例三大属性 2.1 state 2.1.1 state基本使用 state 是组件对象最重要的属性，值是对象(可以包含多个 key-value 的组合)"/>







<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>






<link rel="stylesheet" href="https://gsemir0418.github.io/scss/journal.min.5e8f3f653e9f6ce67bf72ff8ee6fee69decf7b5639a3ae7f8344750ad4e065b1.css" integrity="sha256-Xo8/ZT6fbOZ79y/47m/uad7Pe1Y5o65/g0R1CtTgZbE=" media="screen">



<link rel="stylesheet" href="https://gsemir0418.github.io/scss/dark-mode.min.bdfa63b2e89903517dcbb1032b537d54cff3f425c19d008a78dfe49e6cd07ced.css" integrity="sha256-vfpjsuiZA1F9y7EDK1N9VM/z9CXBnQCKeN/knmzQfO0=" media="screen">


<script src="https://gsemir0418.github.io//js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>




  
    <script src="https://gsemir0418.github.io//js/toc-collapse.js"></script>
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: 'your client id',
  clientSecret: 'your client secret',
  repo: 'repo name',
  owner: 'user',
  admin: ['user'],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>








</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://gsemir0418.github.io/">
    
        <div class="nav-title">
            GSemir Blog
        </div>
        
        <div class="nav-subtitle">
            个人技术博客
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS Feed
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	2021 GSemir Blog
	

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#1-react%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#1-react定义组件-nav`)" id="1-react定义组件-nav">
									1 React定义组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#11-%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#11-函数式组件-nav`)" id="11-函数式组件-nav">
									1.1 函数式组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e7%b1%bb%e5%bc%8f%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#12-类式组件-nav`)" id="12-类式组件-nav">
									1.2 类式组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#2-%e7%bb%84%e4%bb%b6%e5%ae%9e%e4%be%8b%e4%b8%89%e5%a4%a7%e5%b1%9e%e6%80%a7" onclick="onNavClick(`#2-组件实例三大属性-nav`)" id="2-组件实例三大属性-nav">
									2 组件实例三大属性
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#21-state" onclick="onNavClick(`#21-state-nav`)" id="21-state-nav">
									2.1 state
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#211-state%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8" onclick="onNavClick(`#211-state基本使用-nav`)" id="211-state基本使用-nav">
									2.1.1 state基本使用
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#212-%e6%b3%a8%e6%84%8f" onclick="onNavClick(`#212-注意-nav`)" id="212-注意-nav">
									2.1.2 注意
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#213-state%e7%9a%84%e7%ae%80%e5%86%99%e6%96%b9%e5%bc%8f" onclick="onNavClick(`#213-state的简写方式-nav`)" id="213-state的简写方式-nav">
									2.1.3 state的简写方式：
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#22-props" onclick="onNavClick(`#22-props-nav`)" id="22-props-nav">
									2.2 props
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#221-props%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8" onclick="onNavClick(`#221-props基本使用-nav`)" id="221-props基本使用-nav">
									2.2.1 props基本使用
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#222-%e5%af%b9props%e8%bf%9b%e8%a1%8c%e9%99%90%e5%88%b6" onclick="onNavClick(`#222-对props进行限制-nav`)" id="222-对props进行限制-nav">
									2.2.2 对props进行限制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#223-props%e7%9a%84%e7%ae%80%e5%86%99%e6%96%b9%e5%bc%8f" onclick="onNavClick(`#223-props的简写方式-nav`)" id="223-props的简写方式-nav">
									2.2.3 props的简写方式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#224-%e7%b1%bb%e5%bc%8f%e7%bb%84%e4%bb%b6%e4%b8%ad%e7%9a%84%e6%9e%84%e9%80%a0%e5%99%a8%e4%b8%8eprops" onclick="onNavClick(`#224-类式组件中的构造器与props-nav`)" id="224-类式组件中的构造器与props-nav">
									2.2.4 类式组件中的构造器与props
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#225-%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e4%bd%bf%e7%94%a8props" onclick="onNavClick(`#225-函数组件使用props-nav`)" id="225-函数组件使用props-nav">
									2.2.5 函数组件使用props
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#23-refs" onclick="onNavClick(`#23-refs-nav`)" id="23-refs-nav">
									2.3 refs
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#231-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%bd%a2%e5%bc%8f%e7%9a%84ref" onclick="onNavClick(`#231-字符串形式的ref-nav`)" id="231-字符串形式的ref-nav">
									2.3.1 字符串形式的ref
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#232-%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0%e5%bd%a2%e5%bc%8f%e7%9a%84ref" onclick="onNavClick(`#232-回调函数形式的ref-nav`)" id="232-回调函数形式的ref-nav">
									2.3.2 回调函数形式的ref
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#233-%e5%9b%9e%e8%b0%83%e5%bd%a2%e5%bc%8fref%e8%b0%83%e7%94%a8%e6%ac%a1%e6%95%b0%e7%9a%84%e9%97%ae%e9%a2%98" onclick="onNavClick(`#233-回调形式ref调用次数的问题-nav`)" id="233-回调形式ref调用次数的问题-nav">
									2.3.3 回调形式ref调用次数的问题
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#234-createref" onclick="onNavClick(`#234-createref-nav`)" id="234-createref-nav">
									2.3.4 createRef
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#235-%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86" onclick="onNavClick(`#235-事件处理-nav`)" id="235-事件处理-nav">
									2.3.5 事件处理
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#3-react%e6%94%b6%e9%9b%86%e8%a1%a8%e5%8d%95%e6%95%b0%e6%8d%ae" onclick="onNavClick(`#3-react收集表单数据-nav`)" id="3-react收集表单数据-nav">
									3 React收集表单数据
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#31-%e9%9d%9e%e5%8f%97%e6%8e%a7%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#31-非受控组件-nav`)" id="31-非受控组件-nav">
									3.1 非受控组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#32-%e5%8f%97%e6%8e%a7%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#32-受控组件-nav`)" id="32-受控组件-nav">
									3.2 受控组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#4-%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0%e4%bb%a5%e5%8f%8a%e5%87%bd%e6%95%b0%e6%9f%af%e9%87%8c%e5%8c%96" onclick="onNavClick(`#4-高阶函数以及函数柯里化-nav`)" id="4-高阶函数以及函数柯里化-nav">
									4 高阶函数以及函数柯里化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#41-%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0%e4%b8%8e%e5%87%bd%e6%95%b0%e6%9f%af%e9%87%8c%e5%8c%96%e7%9a%84%e5%ae%9a%e4%b9%89" onclick="onNavClick(`#41-高阶函数与函数柯里化的定义-nav`)" id="41-高阶函数与函数柯里化的定义-nav">
									4.1 高阶函数与函数柯里化的定义
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#42-%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%9f%af%e9%87%8c%e5%8c%96%e7%9a%84%e5%86%99%e6%b3%95" onclick="onNavClick(`#42-不使用柯里化的写法-nav`)" id="42-不使用柯里化的写法-nav">
									4.2 不使用柯里化的写法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e8%a1%a5%e5%85%85" onclick="onNavClick(`#补充-nav`)" id="补充-nav">
									补充：
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#1-%e7%b1%bb%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%9f%a5%e8%af%86" onclick="onNavClick(`#1-类的基本知识-nav`)" id="1-类的基本知识-nav">
									1 类的基本知识
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2-%e5%8e%9f%e7%94%9f%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a" onclick="onNavClick(`#2-原生事件绑定-nav`)" id="2-原生事件绑定-nav">
									2 原生事件绑定
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#3-%e7%b1%bb%e4%b8%ad%e6%96%b9%e6%b3%95%e7%9a%84this%e6%8c%87%e5%90%91" onclick="onNavClick(`#3-类中方法的this指向-nav`)" id="3-类中方法的this指向-nav">
									3 类中方法的this指向
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#4-%e5%b1%95%e5%bc%80%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e7%94%a8%e6%b3%95" onclick="onNavClick(`#4-展开运算符的用法-nav`)" id="4-展开运算符的用法-nav">
									4 展开运算符的用法
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a class="pagination-action" v-on:click="toggleDarkMode">
            <i class="material-icons pagination-action-icon" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons pagination-action-icon" v-else="isDarkMode">
                brightness_7
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS Feed
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#1-react%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#1-react定义组件-nav`)" id="1-react定义组件-nav">
									1 React定义组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#11-%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#11-函数式组件-nav`)" id="11-函数式组件-nav">
									1.1 函数式组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e7%b1%bb%e5%bc%8f%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#12-类式组件-nav`)" id="12-类式组件-nav">
									1.2 类式组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#2-%e7%bb%84%e4%bb%b6%e5%ae%9e%e4%be%8b%e4%b8%89%e5%a4%a7%e5%b1%9e%e6%80%a7" onclick="onNavClick(`#2-组件实例三大属性-nav`)" id="2-组件实例三大属性-nav">
									2 组件实例三大属性
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#21-state" onclick="onNavClick(`#21-state-nav`)" id="21-state-nav">
									2.1 state
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#211-state%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8" onclick="onNavClick(`#211-state基本使用-nav`)" id="211-state基本使用-nav">
									2.1.1 state基本使用
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#212-%e6%b3%a8%e6%84%8f" onclick="onNavClick(`#212-注意-nav`)" id="212-注意-nav">
									2.1.2 注意
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#213-state%e7%9a%84%e7%ae%80%e5%86%99%e6%96%b9%e5%bc%8f" onclick="onNavClick(`#213-state的简写方式-nav`)" id="213-state的简写方式-nav">
									2.1.3 state的简写方式：
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#22-props" onclick="onNavClick(`#22-props-nav`)" id="22-props-nav">
									2.2 props
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#221-props%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8" onclick="onNavClick(`#221-props基本使用-nav`)" id="221-props基本使用-nav">
									2.2.1 props基本使用
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#222-%e5%af%b9props%e8%bf%9b%e8%a1%8c%e9%99%90%e5%88%b6" onclick="onNavClick(`#222-对props进行限制-nav`)" id="222-对props进行限制-nav">
									2.2.2 对props进行限制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#223-props%e7%9a%84%e7%ae%80%e5%86%99%e6%96%b9%e5%bc%8f" onclick="onNavClick(`#223-props的简写方式-nav`)" id="223-props的简写方式-nav">
									2.2.3 props的简写方式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#224-%e7%b1%bb%e5%bc%8f%e7%bb%84%e4%bb%b6%e4%b8%ad%e7%9a%84%e6%9e%84%e9%80%a0%e5%99%a8%e4%b8%8eprops" onclick="onNavClick(`#224-类式组件中的构造器与props-nav`)" id="224-类式组件中的构造器与props-nav">
									2.2.4 类式组件中的构造器与props
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#225-%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e4%bd%bf%e7%94%a8props" onclick="onNavClick(`#225-函数组件使用props-nav`)" id="225-函数组件使用props-nav">
									2.2.5 函数组件使用props
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#23-refs" onclick="onNavClick(`#23-refs-nav`)" id="23-refs-nav">
									2.3 refs
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#231-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%bd%a2%e5%bc%8f%e7%9a%84ref" onclick="onNavClick(`#231-字符串形式的ref-nav`)" id="231-字符串形式的ref-nav">
									2.3.1 字符串形式的ref
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#232-%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0%e5%bd%a2%e5%bc%8f%e7%9a%84ref" onclick="onNavClick(`#232-回调函数形式的ref-nav`)" id="232-回调函数形式的ref-nav">
									2.3.2 回调函数形式的ref
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#233-%e5%9b%9e%e8%b0%83%e5%bd%a2%e5%bc%8fref%e8%b0%83%e7%94%a8%e6%ac%a1%e6%95%b0%e7%9a%84%e9%97%ae%e9%a2%98" onclick="onNavClick(`#233-回调形式ref调用次数的问题-nav`)" id="233-回调形式ref调用次数的问题-nav">
									2.3.3 回调形式ref调用次数的问题
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#234-createref" onclick="onNavClick(`#234-createref-nav`)" id="234-createref-nav">
									2.3.4 createRef
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#235-%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86" onclick="onNavClick(`#235-事件处理-nav`)" id="235-事件处理-nav">
									2.3.5 事件处理
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#3-react%e6%94%b6%e9%9b%86%e8%a1%a8%e5%8d%95%e6%95%b0%e6%8d%ae" onclick="onNavClick(`#3-react收集表单数据-nav`)" id="3-react收集表单数据-nav">
									3 React收集表单数据
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#31-%e9%9d%9e%e5%8f%97%e6%8e%a7%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#31-非受控组件-nav`)" id="31-非受控组件-nav">
									3.1 非受控组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#32-%e5%8f%97%e6%8e%a7%e7%bb%84%e4%bb%b6" onclick="onNavClick(`#32-受控组件-nav`)" id="32-受控组件-nav">
									3.2 受控组件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#4-%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0%e4%bb%a5%e5%8f%8a%e5%87%bd%e6%95%b0%e6%9f%af%e9%87%8c%e5%8c%96" onclick="onNavClick(`#4-高阶函数以及函数柯里化-nav`)" id="4-高阶函数以及函数柯里化-nav">
									4 高阶函数以及函数柯里化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#41-%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0%e4%b8%8e%e5%87%bd%e6%95%b0%e6%9f%af%e9%87%8c%e5%8c%96%e7%9a%84%e5%ae%9a%e4%b9%89" onclick="onNavClick(`#41-高阶函数与函数柯里化的定义-nav`)" id="41-高阶函数与函数柯里化的定义-nav">
									4.1 高阶函数与函数柯里化的定义
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#42-%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%9f%af%e9%87%8c%e5%8c%96%e7%9a%84%e5%86%99%e6%b3%95" onclick="onNavClick(`#42-不使用柯里化的写法-nav`)" id="42-不使用柯里化的写法-nav">
									4.2 不使用柯里化的写法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e8%a1%a5%e5%85%85" onclick="onNavClick(`#补充-nav`)" id="补充-nav">
									补充：
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#1-%e7%b1%bb%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%9f%a5%e8%af%86" onclick="onNavClick(`#1-类的基本知识-nav`)" id="1-类的基本知识-nav">
									1 类的基本知识
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2-%e5%8e%9f%e7%94%9f%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a" onclick="onNavClick(`#2-原生事件绑定-nav`)" id="2-原生事件绑定-nav">
									2 原生事件绑定
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#3-%e7%b1%bb%e4%b8%ad%e6%96%b9%e6%b3%95%e7%9a%84this%e6%8c%87%e5%90%91" onclick="onNavClick(`#3-类中方法的this指向-nav`)" id="3-类中方法的this指向-nav">
									3 类中方法的this指向
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#4-%e5%b1%95%e5%bc%80%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e7%94%a8%e6%b3%95" onclick="onNavClick(`#4-展开运算符的用法-nav`)" id="4-展开运算符的用法-nav">
									4 展开运算符的用法
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://gsemir0418.github.io/">
            GSemir Blog
        </a>
        
        <button type="button" class="nav-darkmode-toggle" v-on:click="toggleDarkMode">
            <i class="material-icons" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons" v-else="isDarkMode">
                brightness_7
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://gsemir0418.github.io/">
        <div class="single-column-header-title">GSemir Blog</div>
        
        <div class="single-column-header-subtitle">个人技术博客</div>
        

    </a>
</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    React基础
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2021-04-29 23:11
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/b%E7%AB%99react%E7%AC%94%E8%AE%B0">B站React笔记</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF">前端</a>
                                &nbsp;
                            
                                <a href="/tags/react%E5%9F%BA%E7%A1%80">React基础</a>
                                &nbsp;
                            
                                <a href="/tags/react">React</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <h1 id="1-react定义组件">1 React定义组件</h1>
<h2 id="11-函数式组件">1.1 函数式组件</h2>
<ul>
<li>函数式组件适用于简单组件的定义，其首字母需大写，且虚拟DOM元素必须有结束标签</li>
<li>函数组件中的this指向为window，但babel编译后默认开启了严格模式，因此结果为undefined</li>
<li>返回的虚拟DOM元素只能有一个根元素</li>
<li>渲染函数式组件的过程：
<ol>
<li>React解析组件标签，找到了Demo组件</li>
<li>发现组件式使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM。随后呈现在页面中</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">function</span> Demo(){
	console.log(<span style="color:#8b008b;font-weight:bold">this</span>);<span style="color:#228b22">//undefined
</span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">return</span> &lt;h1&gt;函数式组件<span style="color:#a61717;background-color:#e3d2d2">，</span>适用于简单组件的定义&lt;<span style="color:#a61717;background-color:#e3d2d2">/h1&gt;</span>
}
ReactDOM.render(&lt;Demo/&gt;,<span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h2 id="12-类式组件">1.2 类式组件</h2>
<ul>
<li>
<p>继承<strong>React.Component</strong>类，组件名首字母必须<strong>大写</strong>，且虚拟DOM元素必须有<strong>结束标签</strong></p>
</li>
<li>
<p>必须有<strong>render()<strong>方法，且render方法必须有</strong>返回值</strong>，返回的虚拟DOM元素只能<strong>有一个根元素</strong></p>
</li>
<li>
<p>渲染类式组件的过程</p>
<p>1.React 内部会创建组件实例对象</p>
<p>2.调用 render()得到虚拟 DOM, 并解析为真实 DOM</p>
<p>3.插入到指定的页面元素内部</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> MyComponent <span style="color:#8b008b;font-weight:bold">extends</span> React.Component{
	render(){
	<span style="color:#228b22">//render放在MyComponent的原型对象（React.Component）上，供实例使用
</span><span style="color:#228b22"></span>	<span style="color:#228b22">//render中的this指向MyComponent实例对象（组件实例对象）
</span><span style="color:#228b22"></span>	console.log(<span style="color:#cd5555">&#39;render方法中的this指向：&#39;</span>,<span style="color:#8b008b;font-weight:bold">this</span>);
	<span style="color:#8b008b;font-weight:bold">return</span> &lt;h1&gt;类式组件<span style="color:#a61717;background-color:#e3d2d2">，</span>适用于复杂组件的定义&lt;<span style="color:#a61717;background-color:#e3d2d2">/h1&gt;</span>
	}
}
ReactDOM.render(&lt;MyComponent/&gt;,<span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><hr>
<h1 id="2-组件实例三大属性">2 组件实例三大属性</h1>
<h2 id="21-state">2.1 state</h2>
<h3 id="211-state基本使用">2.1.1 state基本使用</h3>
<p>state 是组件对象最重要的属性，值是对象(可以包含多个 key-value 的组合)</p>
<p>组件被称为&quot;状态机&quot;，通过更新组件的 state 来更新对应的页面显示(重新渲染组件)</p>
<blockquote>
<p>需求：定义一个展示天气信息的组件</p>
<ul>
<li>默认展示天气炎热 或 凉爽</li>
<li>点击文字切换天气</li>
</ul>
</blockquote>
<p>代码如下：（无效）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Weather <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
	constructor(props) {
		<span style="color:#8b008b;font-weight:bold">super</span>(props)
		<span style="color:#8b008b;font-weight:bold">this</span>.state = { isHot: <span style="color:#8b008b;font-weight:bold">false</span> }<span style="color:#228b22">//this指向当前类的实例对象
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//解决方案
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//利用bind将原型对象上的changeWeather方法的this指向强行绑定为实例对象
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//从而形成一个新函数，再将其赋值给新的变量changeWeather
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">this</span>.changeWeather = <span style="color:#8b008b;font-weight:bold">this</span>.changeWeather.bind(<span style="color:#8b008b;font-weight:bold">this</span>)
    }
	changeWeather() {
        <span style="color:#228b22">//changWeather方法放在Weather的原型对象上，供实例对象使用
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//由于changeWeather是作为onClick的回调，所以是直接调用的，而不是通过实例调用的，此时this应该指向window对象
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//又因为类中的方法默认开启了局部严格模式，所以结果为undefined
</span><span style="color:#228b22"></span>        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);<span style="color:#228b22">//undefined
</span><span style="color:#228b22"></span>    }
	render() {
		<span style="color:#8b008b;font-weight:bold">const</span> { isHot } = <span style="color:#8b008b;font-weight:bold">this</span>.state<span style="color:#228b22">//this是组件实例对象
</span><span style="color:#228b22"></span>		console.log(<span style="color:#8b008b;font-weight:bold">this</span>);
		<span style="color:#228b22">//绑定默认事件时，要注意C大写，如onBlur；
</span><span style="color:#228b22"></span>		<span style="color:#228b22">//事件的回调函数不需要加括号，否则react会将方法执行后的返回值（这里是undefined）赋给onClick，使得单击事件失效
</span><span style="color:#228b22"></span>		<span style="color:#8b008b;font-weight:bold">return</span> &lt;h1 onClick={<span style="color:#8b008b;font-weight:bold">this</span>.changeWeather}&gt;今天天气很{isHot ? <span style="color:#cd5555">&#39;炎热&#39;</span> : <span style="color:#cd5555">&#39;寒冷&#39;</span>}&lt;<span style="color:#a61717;background-color:#e3d2d2">/h1&gt;</span>
	}
}
ReactDOM.render(&lt;Weather /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h3 id="212-注意">2.1.2 注意</h3>
<ul>
<li>
<p>组件中 render 方法中的 this 为组件实例对象</p>
</li>
<li>
<p>组件自定义的方法中 this 为 undefined，如何解决？</p>
<p>1.强制绑定 this: 通过函数对象的 bind()</p>
<p>2.箭头函数</p>
</li>
<li>
<p>状态数据，不能直接修改或更新，需要在方法中使用**this.setState({})**来修改，修改后代码如下：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Weather <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {

    <span style="color:#228b22">//构造器调用几次？————1次
</span><span style="color:#228b22"></span>    constructor(props) {
        <span style="color:#8b008b;font-weight:bold">super</span>(props)
        <span style="color:#228b22">//初始化状态
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">this</span>.state = { isHot: <span style="color:#8b008b;font-weight:bold">false</span>, wind: <span style="color:#cd5555">&#39;微风&#39;</span> }<span style="color:#228b22">//this指向当前类的实例对象
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//解决this指向问题
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">this</span>.changeWeather = <span style="color:#8b008b;font-weight:bold">this</span>.changeWeather.bind(<span style="color:#8b008b;font-weight:bold">this</span>)
    }

    <span style="color:#228b22">//render调用几次？————1+n次 1是指初始化的那次 n是状态更新的次数
</span><span style="color:#228b22"></span>    render() {
        <span style="color:#228b22">//读取状态，ES6的解构赋值
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">const</span> { isHot, wind } = <span style="color:#8b008b;font-weight:bold">this</span>.state<span style="color:#228b22">//this是组件实例对象
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">return</span> &lt;h1 onClick={<span style="color:#8b008b;font-weight:bold">this</span>.changeWeather}&gt;今天天气很{isHot ? <span style="color:#cd5555">&#39;炎热&#39;</span> : <span style="color:#cd5555">&#39;寒冷&#39;</span>}<span style="color:#a61717;background-color:#e3d2d2">，</span>{wind}&lt;<span style="color:#a61717;background-color:#e3d2d2">/h1&gt;</span>
    }

    <span style="color:#228b22">//changeWeather调用几次？————点几次调用几次
</span><span style="color:#228b22"></span>    changeWeather() {
        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);<span style="color:#228b22">//undefined
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//获取原来的isHot值
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">const</span> isHot = <span style="color:#8b008b;font-weight:bold">this</span>.state.isHot
        <span style="color:#228b22">//严重注意，state状态值不能直接更改，
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//this.state.isHot = !isHot是错误的,react是严格的单向绑定，值在这变化虽然有效，但react不认
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//状态值必须通过setState方法进行更新，且更新是一种合并状态，而不是替换，否则微风也就不会显示了
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">this</span>.setState({ isHot: !isHot })
    }
}
ReactDOM.render(&lt;Weather /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h3 id="213-state的简写方式">2.1.3 state的简写方式：</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Weather <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    <span style="color:#228b22">//初始化状态
</span><span style="color:#228b22"></span>    <span style="color:#228b22">//利用类的特性，可以直接写赋值语句，表示在该类的每一个实例对象中添加state属性
</span><span style="color:#228b22"></span>    state = { isHot: <span style="color:#8b008b;font-weight:bold">false</span>, wind: <span style="color:#cd5555">&#39;微风&#39;</span> }
    render() {
        <span style="color:#8b008b;font-weight:bold">const</span> { isHot, wind } = <span style="color:#8b008b;font-weight:bold">this</span>.state
        <span style="color:#8b008b;font-weight:bold">return</span> &lt;h1 onClick={<span style="color:#8b008b;font-weight:bold">this</span>.changeWeather}&gt;今天天气很{isHot ? <span style="color:#cd5555">&#39;炎热&#39;</span> : <span style="color:#cd5555">&#39;寒冷&#39;</span>}<span style="color:#a61717;background-color:#e3d2d2">，</span>{wind}&lt;<span style="color:#a61717;background-color:#e3d2d2">/h1&gt;</span>
    }
    <span style="color:#228b22">//自定义方法（只能作为事件的回调，因为react只会帮我们new实例之后执行render方法）：赋值语句+箭头函数
</span><span style="color:#228b22"></span>    <span style="color:#228b22">//由于箭头函数没有自己的this，回去找外层的this，正是实例对象
</span><span style="color:#228b22"></span>    changeWeather = () =&gt; {
        <span style="color:#8b008b;font-weight:bold">const</span> isHot = <span style="color:#8b008b;font-weight:bold">this</span>.state.isHot
        <span style="color:#8b008b;font-weight:bold">this</span>.setState({ isHot: !isHot })
        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);
    }
}
ReactDOM.render(&lt;Weather/&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h2 id="22-props">2.2 props</h2>
<h3 id="221-props基本使用">2.2.1 props基本使用</h3>
<p>每个组件对象都会有 props(properties 的简写)属性，<strong>组件标签的所有属性都保存在 props 中</strong>，可以通过标签属性从组件外向组件内传递变化的数据</p>
<p>注意: 组件内部不要修改 props 数据</p>
<blockquote>
<p>需求：自定义用来显示一个人员信息的组件</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#8b008b;font-weight:bold">class</span> Person <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    render() {
        <span style="color:#228b22">//console.log(this);//均指向实例对象
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//this.props.name = &#34;haha&#34;会报错，因为props是只读的
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">const</span> { name, age, gender } = <span style="color:#8b008b;font-weight:bold">this</span>.props
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;ul&gt;
                &lt;li&gt;name:{name}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
                &lt;li&gt;age:{age + <span style="color:#b452cd">1</span>}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
                &lt;li&gt;gender:{gender}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/ul&gt;</span>
        )
    }
}
<span style="color:#228b22">//注意传参时的age要用{}包裹起来
</span><span style="color:#228b22"></span>ReactDOM.render(&lt;Person name=<span style="color:#cd5555">&#39;tom&#39;</span> age={<span style="color:#b452cd">18</span>} gender=<span style="color:#cd5555">&#39;man&#39;</span> /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
ReactDOM.render(&lt;Person name=<span style="color:#cd5555">&#39;gsq&#39;</span> age={<span style="color:#b452cd">20</span>} gender=<span style="color:#cd5555">&#39;man&#39;</span> /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test2&#39;</span>))

<span style="color:#8b008b;font-weight:bold">const</span> personAjax = { name: <span style="color:#cd5555">&#39;ajax&#39;</span>, age: <span style="color:#b452cd">10</span>, gender: <span style="color:#cd5555">&#39;man&#39;</span> }
<span style="color:#228b22">//可以使用展开运算符批量传递props
</span><span style="color:#228b22"></span>ReactDOM.render(&lt;Person {...personAjax} /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test3&#39;</span>))
<span style="color:#228b22">//注意，此处的{...personajax}并不是展开运算符的克隆对象用法，
</span><span style="color:#228b22">//而是babel和react允许展开运算符展开对象并赋值
</span><span style="color:#228b22"></span>console.log(...personAjax);<span style="color:#228b22">//为空，虽然允许展开，但不能让你随意操作
</span></code></pre></div><h3 id="222-对props进行限制">2.2.2 对props进行限制</h3>
<blockquote>
<p>需求：</p>
<ul>
<li>姓名必须指定，且为字符串类型</li>
<li>性别为字符串类型，如果性别没有指定，默认为男</li>
<li>年龄为字符串类型，且为数字类型，默认值为 18</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#228b22">&lt;!--</span> 引入propstype<span style="color:#a61717;background-color:#e3d2d2">，</span>用来对props进行限制<span style="color:#a61717;background-color:#e3d2d2">（</span>其实就是弹出一些警告<span style="color:#a61717;background-color:#e3d2d2">）</span> --&gt;
&lt;script src=<span style="color:#cd5555">&#34;../js/prop-types.js&#34;</span>&gt;&lt;<span style="color:#a61717;background-color:#e3d2d2">/script&gt;</span>
...
	<span style="color:#228b22">//对标签属性进行类型、必要性等的限制
</span><span style="color:#228b22"></span>    Person.propTypes = {<span style="color:#228b22">//此处的p小写
</span><span style="color:#228b22"></span>        name:PropTypes.string.isRequired,<span style="color:#228b22">//别忘逗号和P和T都大写
</span><span style="color:#228b22"></span>        gender:PropTypes.string,
        age:PropTypes.number,
        eat:PropTypes.func<span style="color:#228b22">//如果要限制传递方法，注意方法的名字是func
</span><span style="color:#228b22"></span>    }
    <span style="color:#228b22">//指定默认标签属性值
</span><span style="color:#228b22"></span>    Person.defaultProps={
        gender:<span style="color:#cd5555">&#39;不男不女&#39;</span>,
        age:<span style="color:#b452cd">0</span>
    }
</code></pre></div><h3 id="223-props的简写方式">2.2.3 props的简写方式</h3>
<p>就是将定义在类之外的限制props的语句作为静态方法，写到类中</p>
<blockquote>
<p>若要给类的原型对象自身加属性，用static关键字</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#8b008b;font-weight:bold">class</span> Person <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    <span style="color:#228b22">//对标签属性进行类型、必要性等的限制
</span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">static</span> propTypes = {<span style="color:#228b22">//此处的p小写
</span><span style="color:#228b22"></span>        name: PropTypes.string.isRequired,<span style="color:#228b22">//别忘逗号和P和T都大写
</span><span style="color:#228b22"></span>        gender: PropTypes.string,
        age: PropTypes.number,
        eat: PropTypes.func<span style="color:#228b22">//如果要限制传递方法，注意方法的名字是func
</span><span style="color:#228b22"></span>    }
    <span style="color:#228b22">//指定默认标签属性值
</span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">static</span> defaultProps = {
        gender: <span style="color:#cd5555">&#39;不男不女&#39;</span>,
        age: <span style="color:#b452cd">0</span>
    }
    render() {
        <span style="color:#8b008b;font-weight:bold">const</span> { name, age, gender } = <span style="color:#8b008b;font-weight:bold">this</span>.props
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;ul&gt;
            	&lt;li&gt;name:{name}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
				&lt;li&gt;age:{age + <span style="color:#b452cd">1</span>}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
				&lt;li&gt;gender:{gender}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
			&lt;<span style="color:#a61717;background-color:#e3d2d2">/ul&gt;</span>
		)
	}
}
</code></pre></div><h3 id="224-类式组件中的构造器与props">2.2.4 类式组件中的构造器与props</h3>
<p>类中的构造器可以省略</p>
<p>如果写了构造器，同时接受props并传递给super，那么就可以通过this.props访问实例对象的props了（几乎用不到）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">constructor(props) {
    <span style="color:#228b22">//构造器是否接受props，是否传递给super，取决于：
</span><span style="color:#228b22"></span>    <span style="color:#228b22">//是否希望在构造器中通过this访问props（即访问每个实例对象的props）
</span><span style="color:#228b22"></span>    <span style="color:#228b22">//一般能不写就不写
</span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">super</span>(props)
    console.log(<span style="color:#cd5555">&#39;constractor&#39;</span>,props);
}
</code></pre></div><h3 id="225-函数组件使用props">2.2.5 函数组件使用props</h3>
<p>函数组件因为自身能够传参，因此可以使用props属性</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#228b22">//函数组件因为自身能够传参，因此可以使用props属性
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">function</span> Person(props) {
    <span style="color:#8b008b;font-weight:bold">const</span> {name,gender,age} = props
    <span style="color:#8b008b;font-weight:bold">return</span> (
        &lt;ul&gt;
            &lt;li&gt;姓名<span style="color:#a61717;background-color:#e3d2d2">：</span>{name}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
            &lt;li&gt;性别<span style="color:#a61717;background-color:#e3d2d2">：</span>{gender}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
            &lt;li&gt;年龄<span style="color:#a61717;background-color:#e3d2d2">：</span>{age}&lt;<span style="color:#a61717;background-color:#e3d2d2">/li&gt;</span>
        &lt;<span style="color:#a61717;background-color:#e3d2d2">/ul&gt;</span>
    )
}
<span style="color:#228b22">//对props进行限制，只能放到函数外面了
</span><span style="color:#228b22"></span>Person.propTypes = {<span style="color:#228b22">//此处的p小写
</span><span style="color:#228b22"></span>    name: PropTypes.string.isRequired,<span style="color:#228b22">//别忘逗号和P和T都大写
</span><span style="color:#228b22"></span>    gender: PropTypes.string,
    age: PropTypes.number,
    eat: PropTypes.func<span style="color:#228b22">//如果要限制传递方法，注意方法的名字是func
</span><span style="color:#228b22"></span>}
Person.defaultProps = {
    gender: <span style="color:#cd5555">&#39;不男不女&#39;</span>,
    age: <span style="color:#b452cd">0</span>
}
ReactDOM.render(&lt;Person age={<span style="color:#b452cd">18</span>} gender=<span style="color:#cd5555">&#39;man&#39;</span> /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h2 id="23-refs">2.3 refs</h2>
<p>组件内的标签可以定义 ref 属性来<strong>标识自己</strong></p>
<blockquote>
<p>需求: 自定义组件</p>
<ol>
<li>
<p>点击按钮, 提示第一个输入框中的值</p>
</li>
<li>
<p>当第 2 个输入框失去焦点时, 提示这个输入框中的值</p>
</li>
</ol>
</blockquote>
<h3 id="231-字符串形式的ref">2.3.1 字符串形式的ref</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Demo <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    render() {
        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;div&gt;
                &lt;input ref=<span style="color:#cd5555">&#34;inp1&#34;</span> type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;&amp;nbsp;
                &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.showData}&gt;点击显示左侧内容&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;&amp;nbsp;</span>
                &lt;input ref=<span style="color:#cd5555">&#34;inp2&#34;</span> onBlur={<span style="color:#8b008b;font-weight:bold">this</span>.showData2} placeholder=<span style="color:#cd5555">&#34;失去焦点弹出输入内容&#34;</span> type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/div&gt;</span>
        )
    }
    showData = () =&gt; {
        <span style="color:#8b008b;font-weight:bold">const</span> {inp1} = <span style="color:#8b008b;font-weight:bold">this</span>.refs
        alert(inp1.value)
    }
    showData2 = () =&gt; {
        <span style="color:#8b008b;font-weight:bold">const</span> {inp2} = <span style="color:#8b008b;font-weight:bold">this</span>.refs
        alert(inp2.value)
    }
}
ReactDOM.render(&lt;Demo /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h3 id="232-回调函数形式的ref">2.3.2 回调函数形式的ref</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Demo <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    render() {
        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;div&gt;
                {<span style="color:#228b22">/* c表示currentNode，this表示组件实例对象，
</span><span style="color:#228b22">                把ref当前所处节点(c)挂在了实例自身上，并命名为inp1 */</span>}
                &lt;input ref={c =&gt; <span style="color:#8b008b;font-weight:bold">this</span>.inp1 = c} type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;&amp;nbsp;
                &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.showData}&gt;点击显示左侧内容&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/div&gt;</span>
        )
    }
    showData = () =&gt; {
        <span style="color:#228b22">//const { inp1 } = this.refs不用从refs中取了，从实例自身取即可
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">const</span> { inp1 } = <span style="color:#8b008b;font-weight:bold">this</span>
        alert(inp1.value)
    }
}
ReactDOM.render(&lt;Demo /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h3 id="233-回调形式ref调用次数的问题">2.3.3 回调形式ref调用次数的问题</h3>
<ul>
<li>初始化时，ref的回调会执行一次。但是当更新组件时，ref的回调会执行两次，分别返回null和currentNode，因为每次渲染时都会创建一个新的函数实例，所以React清空旧的ref并设置新的。</li>
<li>可以定义成class的绑定函数的方法来解决，但一般就用内联就可以了，多此一举。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Demo <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    state = { isHot: <span style="color:#8b008b;font-weight:bold">true</span> }
    <span style="color:#228b22">//不用管它 只是为了更新组件方便些
</span><span style="color:#228b22"></span>    changeWeather = () =&gt; {
        <span style="color:#8b008b;font-weight:bold">const</span> { isHot } = <span style="color:#8b008b;font-weight:bold">this</span>.state
        <span style="color:#8b008b;font-weight:bold">this</span>.setState({ isHot: !isHot })
    }
    showData = () =&gt; {
        <span style="color:#228b22">//const { inp1 } = this.refs不用从refs中取了，从实例自身取即可
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">const</span> { inp1 } = <span style="color:#8b008b;font-weight:bold">this</span>
        alert(inp1.value)
    }
    <span style="color:#228b22">//只是将将内联形式提取出来而已，可以解决此问题
</span><span style="color:#228b22"></span>    saveRef = (c) =&gt; {
        <span style="color:#8b008b;font-weight:bold">this</span>.inp2 = c<span style="color:#228b22">//将传入的c节点挂载到实例对象上，命名为inp2
</span><span style="color:#228b22"></span>        console.log(<span style="color:#cd5555">&#34;@@&#34;</span>, c);
    }
    showData2 = () =&gt; {
        <span style="color:#8b008b;font-weight:bold">const</span> { inp2 } = <span style="color:#8b008b;font-weight:bold">this</span>
        alert(inp2.value)
    }
    render() {
        <span style="color:#8b008b;font-weight:bold">const</span> { isHot } = <span style="color:#8b008b;font-weight:bold">this</span>.state
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;div&gt;
            &lt;h2&gt;今天天气很{isHot ? <span style="color:#cd5555">&#39;炎热&#39;</span> : <span style="color:#cd5555">&#39;寒冷&#39;</span>}&lt;<span style="color:#a61717;background-color:#e3d2d2">/h2&gt;</span>
            &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.changeWeather}&gt;单击切换天气&lt;<span style="color:#1c7e71">/button&gt;&lt;br /</span>&gt;
            {<span style="color:#228b22">/*初始化时，ref的回调会执行一次
</span><span style="color:#228b22">            但是当更新组件时，ref的回调会执行两次，分别返回null和currentNode，
</span><span style="color:#228b22">            因为每次渲染时都会创建一个新的函数实例，所以React清空旧的ref并设置新的*/</span>}

            {<span style="color:#228b22">/*传统内联回调形式*/</span>}
            &lt;input ref={c =&gt; { <span style="color:#8b008b;font-weight:bold">this</span>.inp1 = c, console.log(<span style="color:#cd5555">&#34;@&#34;</span>, c); }} type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;&amp;nbsp;
            &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.showData}&gt;点击显示左侧内容&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>

            {<span style="color:#228b22">/*可以定义成class的绑定函数的方法来解决 但一般就用内联就可以了 多此一举*/</span>}
            &lt;input type=<span style="color:#cd5555">&#34;text&#34;</span> ref={<span style="color:#8b008b;font-weight:bold">this</span>.saveRef} /&gt;
            &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.showData2}&gt;点击显示左侧内容&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/div&gt;</span>
    	)	
    }
}
ReactDOM.render(&lt;Demo /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h3 id="234-createref">2.3.4 createRef</h3>
<ul>
<li>React.createRef()调用后，返回一个容器，该容器可以存储被ref所标识的节点</li>
<li>一个容器只能存一个节点</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Demo <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    <span style="color:#228b22">/*
</span><span style="color:#228b22">    React.createRef()调用后，返回一个容器
</span><span style="color:#228b22">    该容器可以存储被ref所标识的节点
</span><span style="color:#228b22">    一个容器只能存一个节点
</span><span style="color:#228b22">    */</span>
    myRef1 = React.createRef()
    myRef2 = React.createRef()
    render() {
        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;div&gt;
                &lt;input ref={<span style="color:#8b008b;font-weight:bold">this</span>.myRef1} type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;&amp;nbsp;
                &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.showData}&gt;点击显示左侧内容&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
                &lt;input ref={<span style="color:#8b008b;font-weight:bold">this</span>.myRef2} onBlur={<span style="color:#8b008b;font-weight:bold">this</span>.showData2} type=<span style="color:#cd5555">&#34;text&#34;</span>/&gt;
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/div&gt;</span>
        )
    }
    showData = () =&gt; {
    	alert(<span style="color:#8b008b;font-weight:bold">this</span>.myRef1.current.value)
    }
    showData2 = ()=&gt;{
    	alert(<span style="color:#8b008b;font-weight:bold">this</span>.myRef2.current.value)
    }
}
ReactDOM.render(&lt;Demo /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h3 id="235-事件处理">2.3.5 事件处理</h3>
<p>1.通过onXxx属性指定事件处理函数（注意大小写）</p>
<ul>
<li>React使用的是自定义事件，而不是原生DOM事件——为了更好的兼容性</li>
<li>React中的事件是通过事件委托方式处理的（委托给组件最外层的元素）——为了高效率</li>
<li>事件委托的原理是事件冒泡</li>
</ul>
<p>2.通过event.target（发生事件的事件源）得到发生事件的DOM元素对象——不要过度使用ref</p>
<ul>
<li>当发生事件的元素正好是我们要操作的元素，就可以省略ref，例如下面的失去焦点事件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Demo <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    <span style="color:#228b22">//创建ref容器
</span><span style="color:#228b22"></span>    myRef1 = React.createRef()
    render() {
        console.log(<span style="color:#8b008b;font-weight:bold">this</span>);
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;div&gt;
            &lt;input ref={<span style="color:#8b008b;font-weight:bold">this</span>.myRef1} type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;&amp;nbsp;
            &lt;button onClick={<span style="color:#8b008b;font-weight:bold">this</span>.showData}&gt;点击显示左侧内容&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
            &lt;input onBlur={<span style="color:#8b008b;font-weight:bold">this</span>.showData2} type=<span style="color:#cd5555">&#34;text&#34;</span> /&gt;
        	&lt;<span style="color:#a61717;background-color:#e3d2d2">/div&gt;</span>
    	)
    }
    <span style="color:#228b22">//展示左侧输入框的数据
</span><span style="color:#228b22"></span>    showData = () =&gt; {
        alert(<span style="color:#8b008b;font-weight:bold">this</span>.myRef1.current.value)
    }
    <span style="color:#228b22">//展示右侧输入框的数据
</span><span style="color:#228b22"></span>    <span style="color:#228b22">//react在调用这个回调的同时会传入event事件对象
</span><span style="color:#228b22"></span>    showData2 = (e) =&gt; {
        alert(event.target.value)
    }
}
ReactDOM.render(&lt;Demo /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><hr>
<h1 id="3-react收集表单数据">3 React收集表单数据</h1>
<blockquote>
<p>需求: 定义一个包含表单的组件</p>
<p>输入用户名密码后，点击登录提示输入信息</p>
</blockquote>
<h2 id="31-非受控组件">3.1 非受控组件</h2>
<p>输入类型的DOM（表单），对其值现用现取（username.value）的组件，称其为非受控组件</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Login <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    handleSubmit = () =&gt; {
        event.preventDefault()<span style="color:#228b22">//阻止表单的默认提交动作
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">const</span>{username,password} = <span style="color:#8b008b;font-weight:bold">this</span>
        <span style="color:#228b22">// alert(username)是错误的，因为挂载到实例自身的是username节点，表示的是用户名输入框这个节点
</span><span style="color:#228b22"></span>        <span style="color:#228b22">// 所以要通过.value显示其值
</span><span style="color:#228b22"></span>        alert(<span style="color:#cd5555">`username:</span><span style="color:#cd5555">${</span>username.value<span style="color:#cd5555">}</span><span style="color:#cd5555">,password:</span><span style="color:#cd5555">${</span>password.value<span style="color:#cd5555">}</span><span style="color:#cd5555">`</span>)
    }
    render() {
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;form action=<span style="color:#cd5555">&#34;http://www.atguigu.com&#34;</span> onSubmit={<span style="color:#8b008b;font-weight:bold">this</span>.handleSubmit}&gt;
                用户名<span style="color:#a61717;background-color:#e3d2d2">：</span>&lt;input ref={c =&gt; <span style="color:#8b008b;font-weight:bold">this</span>.username = c} type=<span style="color:#cd5555">&#34;text&#34;</span> name=<span style="color:#cd5555">&#34;username&#34;</span> /&gt;
                密码<span style="color:#a61717;background-color:#e3d2d2">：</span>&lt;input ref={c =&gt; <span style="color:#8b008b;font-weight:bold">this</span>.password = c} type=<span style="color:#cd5555">&#34;password&#34;</span> name=<span style="color:#cd5555">&#34;password&#34;</span> /&gt;
                &lt;button&gt;登录&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/form&gt;</span>
        )
    }
}
ReactDOM.render(&lt;Login /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h2 id="32-受控组件">3.2 受控组件</h2>
<p>页面中所有输入类的dom，随着我们的输入，就能把数据维护到状态中，需要用时直接在状态中取出即可</p>
<p>即实现<strong>双向数据绑定</strong>的组件称之为受控组件</p>
<pre><code>class Login extends React.Component {
	//初始化状态
    state = {
        username:&quot;&quot;,
        password:&quot;&quot;
    }
    //保存用户名到状态中
    saveUsername = (event) =&gt; {
    	this.setState({ username: event.target.value })
    }
    //保存密码到状态中
    savePassword = (event) =&gt; {
    	this.setState({ password: event.target.value })
    }
    //表单提交的回调
    handleSubmit = () =&gt; {
    	event.preventDefault()
    	const { username, password } = this.state
    	alert(`username=${username},password=${password}`)
    }
    //页面中所有输入类的dom，随着我们的输入，就能把数据维护到状态中，需要用时直接在状态中取出即可
    //即双向数据绑定
    render() {
        return (
            &lt;form action=&quot;http://www.atguigu.com&quot; onSubmit={this.handleSubmit}&gt;
                用户名：&lt;input onChange={this.saveUsername} type=&quot;text&quot; name=&quot;username&quot; /&gt;
                密码：&lt;input onChange={this.savePassword} type=&quot;password&quot; name=&quot;password&quot; /&gt;
                &lt;button&gt;登录&lt;/button&gt;
            &lt;/form&gt;
        )
    }
}
ReactDOM.render(&lt;Login /&gt;, document.getElementById('test'))
</code></pre><hr>
<h1 id="4-高阶函数以及函数柯里化">4 高阶函数以及函数柯里化</h1>
<p>上文中的方法过于冗杂，不适于输入项较多的表单</p>
<p>可以只写一个函数，通过表单项<strong>回调函数的参数</strong>来界定保存的数据</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Login <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    <span style="color:#228b22">//初始化状态
</span><span style="color:#228b22"></span>    state = {
        username: <span style="color:#cd5555">&#34;&#34;</span>,
        password: <span style="color:#cd5555">&#34;&#34;</span>
    }
    <span style="color:#228b22">//保存表单数据到状态中
</span><span style="color:#228b22"></span>    saveFormData = (dataType) =&gt; {
        <span style="color:#228b22">//当我们给onchange事件的回调函数加上括号，实际表示将其返回值作为onchange事件的回调了
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//因此我们索性将此回调函数的返回值写作一个新回调函数，作为onchange事件真正的回调函数
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">return</span> () =&gt; {
            <span style="color:#228b22">//dataType需要加中括号，因为{}对象中左侧的默认是字符串类型，加不加引号都属于字符串
</span><span style="color:#228b22"></span>            <span style="color:#8b008b;font-weight:bold">this</span>.setState({ [dataType]: event.target.value })
        }
    }
    <span style="color:#228b22">//表单提交的回调
</span><span style="color:#228b22"></span>    handleSubmit = () =&gt; {
        event.preventDefault()
        <span style="color:#8b008b;font-weight:bold">const</span> { username, password } = <span style="color:#8b008b;font-weight:bold">this</span>.state
        alert(<span style="color:#cd5555">`username=</span><span style="color:#cd5555">${</span>username<span style="color:#cd5555">}</span><span style="color:#cd5555">,password=</span><span style="color:#cd5555">${</span>password<span style="color:#cd5555">}</span><span style="color:#cd5555">`</span>)
    }
    render() {
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;form action=<span style="color:#cd5555">&#34;http://www.atguigu.com&#34;</span> onSubmit={<span style="color:#8b008b;font-weight:bold">this</span>.handleSubmit}&gt;
                用户名<span style="color:#a61717;background-color:#e3d2d2">：</span>&lt;input onChange={<span style="color:#8b008b;font-weight:bold">this</span>.saveFormData(<span style="color:#cd5555">&#39;username&#39;</span>)} type=<span style="color:#cd5555">&#34;text&#34;</span> name=<span style="color:#cd5555">&#34;username&#34;</span> /&gt;
                密码<span style="color:#a61717;background-color:#e3d2d2">：</span>&lt;input onChange={<span style="color:#8b008b;font-weight:bold">this</span>.saveFormData(<span style="color:#cd5555">&#39;password&#39;</span>)} type=<span style="color:#cd5555">&#34;password&#34;</span> name=<span style="color:#cd5555">&#34;password&#34;</span> /&gt;
                &lt;button&gt;登录&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/form&gt;</span>
        )
    }
}
ReactDOM.render(&lt;Login /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h2 id="41-高阶函数与函数柯里化的定义">4.1 高阶函数与函数柯里化的定义</h2>
<p>1.高阶函数：如果一个函数符合下面规范中的任何一个，那该函数就是高阶函数</p>
<ul>
<li>若A函数，接受的参数是一个函数，那么A就称为高阶函数</li>
<li>若A函数，调用的返回值依然是一个函数，那么A就称为高阶函数</li>
<li>常见的高阶函数有：Promise、setTimeout、arr.map</li>
</ul>
<p>2.函数的柯里化：通过函数调用继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式</p>
<h2 id="42-不使用柯里化的写法">4.2 不使用柯里化的写法</h2>
<p>直接将返回值中的回调函数写成内联的形式，并传出event对象.</p>
<p>柯里化的核心点在于，事件的回调必须是一个函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Login <span style="color:#8b008b;font-weight:bold">extends</span> React.Component {
    <span style="color:#228b22">//初始化状态
</span><span style="color:#228b22"></span>    state = {
        username: <span style="color:#cd5555">&#34;&#34;</span>,
        password: <span style="color:#cd5555">&#34;&#34;</span>
    }
    <span style="color:#228b22">//保存表单数据到状态中
</span><span style="color:#228b22"></span>    saveFormData = (dataType) =&gt; {
        <span style="color:#228b22">//当我们给onchange事件的回调函数加上括号，实际表示将其返回值作为onchange事件的回调了
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//因此我们索性将此回调函数的返回值写作一个新回调函数，作为onchange事件真正的回调函数
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">return</span> () =&gt; {
            <span style="color:#228b22">//dataType需要加中括号，因为{}对象中左侧的默认是字符串类型，加不加引号都属于字符串
</span><span style="color:#228b22"></span>            <span style="color:#8b008b;font-weight:bold">this</span>.setState({ [dataType]: event.target.value })
        }
    }
    <span style="color:#228b22">//表单提交的回调
</span><span style="color:#228b22"></span>    handleSubmit = () =&gt; {
        event.preventDefault()
        <span style="color:#8b008b;font-weight:bold">const</span> { username, password } = <span style="color:#8b008b;font-weight:bold">this</span>.state
        alert(<span style="color:#cd5555">`username=</span><span style="color:#cd5555">${</span>username<span style="color:#cd5555">}</span><span style="color:#cd5555">,password=</span><span style="color:#cd5555">${</span>password<span style="color:#cd5555">}</span><span style="color:#cd5555">`</span>)
    }
    render() {
        <span style="color:#8b008b;font-weight:bold">return</span> (
            &lt;form action=<span style="color:#cd5555">&#34;http://www.atguigu.com&#34;</span> onSubmit={<span style="color:#8b008b;font-weight:bold">this</span>.handleSubmit}&gt;
                用户名<span style="color:#a61717;background-color:#e3d2d2">：</span>&lt;input onChange={<span style="color:#8b008b;font-weight:bold">this</span>.saveFormData(<span style="color:#cd5555">&#39;username&#39;</span>)} type=<span style="color:#cd5555">&#34;text&#34;</span> name=<span style="color:#cd5555">&#34;username&#34;</span> /&gt;
                密码<span style="color:#a61717;background-color:#e3d2d2">：</span>&lt;input onChange={<span style="color:#8b008b;font-weight:bold">this</span>.saveFormData(<span style="color:#cd5555">&#39;password&#39;</span>)} type=<span style="color:#cd5555">&#34;password&#34;</span> name=<span style="color:#cd5555">&#34;password&#34;</span> /&gt;
                &lt;button&gt;登录&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
            &lt;<span style="color:#a61717;background-color:#e3d2d2">/form&gt;</span>
        )
    }
}
ReactDOM.render(&lt;Login /&gt;, <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;test&#39;</span>))
</code></pre></div><h1 id="补充">补充：</h1>
<h2 id="1-类的基本知识">1 类的基本知识</h2>
<ul>
<li>类中的构造器不是必须写的，如果要对实例进行一些初始化的操作，如添加指定属性时再写</li>
<li>若A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须调用的</li>
<li>类中所定义的方法，都是放在类的原型对象上，供实例去使用</li>
<li>类中允许直接写赋值语句</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#228b22">//创建一个Person类
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">class</span> Person {
    <span style="color:#228b22">//构造器方法
</span><span style="color:#228b22"></span>    constructor(name, age) {
        <span style="color:#228b22">//构造器中的this指向实例对象，因为在new的时候实际上是实例对象调用的构造器方法
</span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name
        <span style="color:#8b008b;font-weight:bold">this</span>.age = age
    }
    <span style="color:#228b22">//一般方法
</span><span style="color:#228b22"></span>    speak() {
        console.log(<span style="color:#cd5555">`我叫</span><span style="color:#cd5555">${</span><span style="color:#8b008b;font-weight:bold">this</span>.name<span style="color:#cd5555">}</span><span style="color:#cd5555">，我今年</span><span style="color:#cd5555">${</span><span style="color:#8b008b;font-weight:bold">this</span>.age<span style="color:#cd5555">}</span><span style="color:#cd5555">岁了`</span>);
        <span style="color:#228b22">//speak方法写在类的的原型对象上，供实例使用
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//实例在调用自身不存在的方法时，会自动去原型链上找
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//通过Person的实例调用speak方法时，speak中的this就是person实例
</span><span style="color:#228b22"></span>        <span style="color:#228b22">//具体情况需要看是谁调用的，call bind apply都可以改变this的指向
</span><span style="color:#228b22"></span>    }
}
<span style="color:#228b22">//创建一个Person的实例对象
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">const</span> p1 = <span style="color:#8b008b;font-weight:bold">new</span> Person(<span style="color:#cd5555">&#39;gsq&#39;</span>, <span style="color:#b452cd">25</span>)
<span style="color:#8b008b;font-weight:bold">const</span> p2 = <span style="color:#8b008b;font-weight:bold">new</span> Person(<span style="color:#cd5555">&#39;zs&#39;</span>, <span style="color:#b452cd">26</span>)
console.log(p1);
console.log(p2);
p1.speak()
p2.speak()

<span style="color:#228b22">//创建一个Student类，继承于Person类
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">class</span> Student <span style="color:#8b008b;font-weight:bold">extends</span> Person {
	constructor(name, age, grade) {
		<span style="color:#8b008b;font-weight:bold">super</span>(name, age)<span style="color:#228b22">//必须调用super，且必须写在第一句
</span><span style="color:#228b22"></span>		<span style="color:#8b008b;font-weight:bold">this</span>.grade = grade
	}
	<span style="color:#228b22">//方法的重写
</span><span style="color:#228b22"></span>	speak() {
		console.log(<span style="color:#cd5555">`我叫</span><span style="color:#cd5555">${</span><span style="color:#8b008b;font-weight:bold">this</span>.name<span style="color:#cd5555">}</span><span style="color:#cd5555">，我今年</span><span style="color:#cd5555">${</span><span style="color:#8b008b;font-weight:bold">this</span>.age<span style="color:#cd5555">}</span><span style="color:#cd5555">岁，今年上</span><span style="color:#cd5555">${</span><span style="color:#8b008b;font-weight:bold">this</span>.grade<span style="color:#cd5555">}</span><span style="color:#cd5555">`</span>);
	}
	study() {
		console.log(<span style="color:#cd5555">&#34;正在学习&#34;</span>);
	}
}
<span style="color:#8b008b;font-weight:bold">const</span> s1 = <span style="color:#8b008b;font-weight:bold">new</span> Student(<span style="color:#cd5555">&#39;abc&#39;</span>, <span style="color:#b452cd">26</span>, <span style="color:#cd5555">&#34;研三&#34;</span>)
s1.speak()
s1.study()
<span style="color:#228b22">/*
</span><span style="color:#228b22">总结：
</span><span style="color:#228b22">1.类中的构造器不是必须写的，如果要对实例进行一些初始化的操作，如添加指定属性时再写
</span><span style="color:#228b22">2.若A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须调用的
</span><span style="color:#228b22">3.类中所定义的方法，都是放在类的原型对象上，供实例去使用
</span><span style="color:#228b22">*/</span>

<span style="color:#228b22">//另，类中允许直接写赋值语句，应用如下
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">class</span> Car {
    constructor(name, price) {
    <span style="color:#8b008b;font-weight:bold">this</span>.name = name
    <span style="color:#8b008b;font-weight:bold">this</span>.price = price
	}
	a = <span style="color:#b452cd">1</span>
	wheels = <span style="color:#b452cd">4</span><span style="color:#228b22">//类中允许直接写赋值语句，此属性会给每个实例对象
</span><span style="color:#228b22"></span>	<span style="color:#228b22">//若要给类的原型对象自身加属性，用static关键字
</span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">static</span> b = <span style="color:#b452cd">3</span>
	fn1() {
	<span style="color:#228b22">//这是放在类的原型对象上的方法
</span><span style="color:#228b22"></span>	}
	fn2 = () =&gt; {
	<span style="color:#228b22">//这是放在类的实例对象上的方法
</span><span style="color:#228b22"></span>	}
}
<span style="color:#8b008b;font-weight:bold">const</span> c1 = <span style="color:#8b008b;font-weight:bold">new</span> Car(<span style="color:#cd5555">&#39;benz&#39;</span>, <span style="color:#b452cd">10000</span>)
console.log(c1);<span style="color:#228b22">//可以利用此特性，简化react中state的编写
</span><span style="color:#228b22"></span>console.log(Car.b);
</code></pre></div><h2 id="2-原生事件绑定">2 原生事件绑定</h2>
<ol>
<li>addEventListener（事件监听器）</li>
<li>onclick（js动态绑定）</li>
<li>直接在标签上绑定（行内绑定）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">&lt;button id=<span style="color:#cd5555">&#34;btn1&#34;</span>&gt;按钮1&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
&lt;button id=<span style="color:#cd5555">&#34;btn2&#34;</span>&gt;按钮2&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
&lt;button onclick=<span style="color:#cd5555">&#34;demo()&#34;</span>&gt;按钮3&lt;<span style="color:#a61717;background-color:#e3d2d2">/button&gt;</span>
&lt;script&gt;
    <span style="color:#228b22">//方式1，addEventListener（事件监听器）
</span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">const</span> btn1 = <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;btn1&#39;</span>)
	btn1.addEventListener(<span style="color:#cd5555">&#39;click&#39;</span>,()=&gt;{
    	alert(<span style="color:#cd5555">&#39;按钮1被点击了&#39;</span>)
	})
	<span style="color:#228b22">//方式2，onclick（js动态绑定）
</span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">const</span> btn2 = <span style="color:#658b00">document</span>.getElementById(<span style="color:#cd5555">&#39;btn2&#39;</span>)
	btn2.onclick = ()=&gt;{
    	alert(<span style="color:#cd5555">&#39;按钮2被点击了&#39;</span>)
	}
	<span style="color:#228b22">//方式3，直接在标签上绑定（行内绑定）
</span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">function</span> demo(){
    	alert(<span style="color:#cd5555">&#39;按钮3被点击了&#39;</span>)
	}
	<span style="color:#228b22">//react推荐使用方法3
</span><span style="color:#228b22"></span>&lt;<span style="color:#a61717;background-color:#e3d2d2">/script&gt;</span>
</code></pre></div><h2 id="3-类中方法的this指向">3 类中方法的this指向</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">class</span> Student{
    constructor(name,age){
        <span style="color:#8b008b;font-weight:bold">this</span>.name = name
        <span style="color:#8b008b;font-weight:bold">this</span>.age = age
	}
    study(){<span style="color:#228b22">//study方法在Student类的原型对象上，供实例对象使用
</span><span style="color:#228b22"></span>    	console.log(<span style="color:#8b008b;font-weight:bold">this</span>);<span style="color:#228b22">//这里的this指向Student实例对象
</span><span style="color:#228b22"></span>    }
}

<span style="color:#8b008b;font-weight:bold">const</span> s1 = <span style="color:#8b008b;font-weight:bold">new</span> Student(<span style="color:#cd5555">&#39;gsq&#39;</span>,<span style="color:#b452cd">18</span>)
s1.study()<span style="color:#228b22">//通过实例调用原型对象上的study方法
</span><span style="color:#228b22"></span>
<span style="color:#8b008b;font-weight:bold">const</span> x = s1.study<span style="color:#228b22">//将study方法赋值给了x
</span><span style="color:#228b22"></span>x()<span style="color:#228b22">//undefined，因为这属于直接调用study方法，由于类中默认开启严格模式，所以是undefined（不然应该是window对象）
</span><span style="color:#228b22"></span>
<span style="color:#228b22">//关于局部开启严格模式
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">function</span> demo1(){
	console.log(<span style="color:#8b008b;font-weight:bold">this</span>);<span style="color:#228b22">//this指向window对象
</span><span style="color:#228b22"></span>}
demo1()

<span style="color:#8b008b;font-weight:bold">function</span> demo2(){
	<span style="color:#cd5555">&#39;use strict&#39;</span><span style="color:#228b22">//局部开启严格模式
</span><span style="color:#228b22"></span>	console.log(<span style="color:#8b008b;font-weight:bold">this</span>);<span style="color:#228b22">//此时是undefined，因为严格模型不让this指向window
</span><span style="color:#228b22"></span>}
demo2()
</code></pre></div><h2 id="4-展开运算符的用法">4 展开运算符的用法</h2>
<ol>
<li>展开一个数组</li>
<li>数组的拼接</li>
<li>函数传参（批量传入参数）</li>
<li>复制对象（深复制）</li>
<li>复制一个对象的同时修改器属性</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">let</span> arr1 = [<span style="color:#b452cd">1</span>,<span style="color:#b452cd">3</span>,<span style="color:#b452cd">5</span>,<span style="color:#b452cd">7</span>,<span style="color:#b452cd">9</span>]    
<span style="color:#8b008b;font-weight:bold">let</span> arr2 = [<span style="color:#b452cd">2</span>,<span style="color:#b452cd">4</span>,<span style="color:#b452cd">6</span>,<span style="color:#b452cd">8</span>,<span style="color:#b452cd">10</span>]    

<span style="color:#228b22">//1.展开一个数组
</span><span style="color:#228b22"></span>console.log(arr1)<span style="color:#228b22">//[1,3,5,7,9]
</span><span style="color:#228b22"></span>console.log(...arr1)<span style="color:#228b22">//1 3 5 7 9
</span><span style="color:#228b22"></span>
<span style="color:#228b22">//2.数组的拼接
</span><span style="color:#228b22"></span>console.log(...[...arr1,...arr2])<span style="color:#228b22">//展开拼接后的数组1 3 5 7 9 2 4 6 8 10
</span><span style="color:#228b22"></span>
<span style="color:#228b22">//3.函数传参，批量传入参数
</span><span style="color:#228b22">//需求：数组求和
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">function</span> sum(...numbers) {
	<span style="color:#8b008b;font-weight:bold">return</span> numbers.reduce((preValue,currentValue) =&gt; {<span style="color:#228b22">//这是数组中非常重要的一个方法reduce
</span><span style="color:#228b22"></span>		<span style="color:#8b008b;font-weight:bold">return</span> preValue + currentValue
	})
}
console.log(sum(<span style="color:#b452cd">1</span>,<span style="color:#b452cd">2</span>,<span style="color:#b452cd">3</span>,<span style="color:#b452cd">4</span>));<span style="color:#228b22">//10
</span><span style="color:#228b22"></span>
<span style="color:#228b22">//4.复制对象
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">let</span> p1 = {name:<span style="color:#cd5555">&#39;gsq&#39;</span>,age:<span style="color:#b452cd">10</span>}
<span style="color:#228b22">//console.log(...p1);//报错，因为在原生js中，展开运算符不可以展开对象
</span><span style="color:#228b22">//但如果在外面包上一层展开运算符，就可以克隆一个对象（深复制），
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">let</span> p2 = {...p1}
p1.name = <span style="color:#cd5555">&#39;zs&#39;</span><span style="color:#228b22">//更改p1的值，p2并不会受影响
</span><span style="color:#228b22"></span>console.log(p2,p1);

<span style="color:#228b22">//5.复制一个对象的同时修改其属性
</span><span style="color:#228b22">//实质上是两个对象的合并
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">let</span> p3 = {...p1,name:<span style="color:#cd5555">&#39;gsqzs&#39;</span>}
console.log(p3);
</code></pre></div><p>5 对象相关知识</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#8b008b;font-weight:bold">let</span> a = <span style="color:#cd5555">&#39;name&#39;</span>
<span style="color:#8b008b;font-weight:bold">const</span> obj = {} <span style="color:#228b22">//需求是将其变成{name:&#39;tom&#39;}
</span><span style="color:#228b22">// 不可直接obj.a = &#34;tom&#34;
</span><span style="color:#228b22"></span>obj[a] = <span style="color:#cd5555">&#34;tom&#34;</span>
console.log(obj)
</code></pre></div><p>6 显示函数柯里化</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#228b22">//正常写法
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">function</span> sum(a, b, c) {
	<span style="color:#8b008b;font-weight:bold">return</span> a + b + c
}
console.log(sum(<span style="color:#b452cd">1</span>, <span style="color:#b452cd">2</span>, <span style="color:#b452cd">3</span>));

<span style="color:#228b22">//函数柯里化写法
</span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">function</span> sum2(a) {
    <span style="color:#8b008b;font-weight:bold">return</span> (b) =&gt; {
        <span style="color:#8b008b;font-weight:bold">return</span> (c) =&gt; {
        	<span style="color:#8b008b;font-weight:bold">return</span> a + b + c
        }
    }
}
console.log(sum2(<span style="color:#b452cd">1</span>)(<span style="color:#b452cd">2</span>)(<span style="color:#b452cd">3</span>));
</code></pre></div>
                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">最后修改于 2021-04-29</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E6%8A%80%E6%9C%AF/">
			下回<br>可视化大屏技术
                </a>
                
                
                
                <a class="older-posts" href="https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/">
			上回<br>展示平台说明文档
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>






            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	2021 GSemir Blog
	
</div>
            </div>
    <script>
let app;

app = new Vue({
    el: '#app',
    data: {
        scrollY: 0,
        navOpacity: 0,
        isDrawerOpen: false,
        mounted: false,
        isDarkMode: false
    },
    methods: {
            sgn(t, x) {
                let k = 1. / (1. - 2 * t);
                if (x <= t) return 0;
                else if (x >= 1 - t) return 1;
                else {
                    return k * (x - t);
                }
            },
            handleScroll() {
                this.scrollY = window.scrollY;
                this.navOpacity = this.sgn(.0, Math.min(1, Math.max(0, window.scrollY / (this.pageHeadHeight() - this.navBarHeight() * 0.8))));
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;

                if (this.navOpacity >= 1) {
                    navBackground.style.opacity = 1;
                    navTitle.style.opacity = 1;
                } else {
                    navBackground.style.opacity = 0;
                    navTitle.style.opacity = 0;
                }
            },
            handleResize() {
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;
                extraContainer.style.left = (streamContainer.offsetWidth - extraContainer.offsetWidth) + 'px';
            },
            navBarHeight() {
                return this.$refs.navBar.offsetHeight;
            },
            pageHeadHeight() {
                return this.$refs.pageHead.offsetHeight;
            },
            toggleDrawer() {
                this.isDrawerOpen = !this.isDrawerOpen;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            closeDrawer() {
                this.isDrawerOpen = false;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode==true){
                    document.cookie = "night=1;path=/";
                    document.body.classList.add("night");
                } else {
                    document.cookie = "night=0;path=/";
                    document.body.classList.remove("night");
                }
            }
    },
    created() {
        window.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        window._nonDesktop = function () {
            let check = false;
            (function (a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };
        
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        if (night==""){
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                
            }
        }else{
            
            if (night=="1") {
                this.toggleDarkMode();
            }
        }
    },
    mounted() {
        this.handleScroll();
        this.handleResize();
        this.mounted = true;

        
    },
    destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
        window.removeEventListener('resize', this.handleResize);
    }
});
</script>

<script src="https://gsemir0418.github.io//js/journal.js"></script>
    </body>
</html>
