<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GSemir Blog</title>
    <link>https://gsemir0418.github.io/</link>
    <description>Recent content on GSemir Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Aug 2021 22:51:51 +0800</lastBuildDate>
    
        <atom:link href="https://gsemir0418.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>React入门</title>
        <link>https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/</link>
        <pubDate>Fri, 25 Jun 2021 23:11:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/ -&lt;h1 id=&#34;1react是什么&#34;&gt;1.React是什么&lt;/h1&gt;
&lt;p&gt;用于构建&lt;strong&gt;用户界面&lt;/strong&gt;的JS库（操作DOM呈现页面）&lt;/p&gt;
&lt;p&gt;是一个将数据渲染为HTML视图的开源的JavaScript库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：https://react.docschina.org/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2谁开发的&#34;&gt;2.谁开发的&lt;/h1&gt;
&lt;p&gt;Facebook&lt;/p&gt;
&lt;h1 id=&#34;3为什么要学&#34;&gt;3.为什么要学&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原生JS操作DOM&lt;strong&gt;繁琐、效率低&lt;/strong&gt;（&lt;strong&gt;DOM-API操作UI&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用js直接操作DOM，浏览器会进行大量的&lt;strong&gt;重绘重排&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原生js没有&lt;strong&gt;组件化&lt;/strong&gt;的编码方案，代码复用率低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块化&lt;/strong&gt;是针对js的，可以把js拆分成独立的功能模块，方便复用。但是html结构和css样式，包括字体图片音频视频等，复用率低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4react的特点&#34;&gt;4.React的特点&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用&lt;strong&gt;组件化模式&lt;/strong&gt;、&lt;strong&gt;声明式编码&lt;/strong&gt;，提高开发效率及组件复用率&lt;/p&gt;
&lt;p&gt;之前使用的是&lt;strong&gt;命令式编码&lt;/strong&gt;，面向过程。比如我想喝一杯水，需要命令别人先站起来，再走到水杯旁，把我帮我拿过来等等的步骤；但是声明式编码只需我说嗓子干了，自动就会帮我把水拿过来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;React Native&lt;/strong&gt;中可以使用React语法进行&lt;strong&gt;移动端&lt;/strong&gt;开发。&lt;/p&gt;
&lt;p&gt;React Native可以使得前端开发人员使用最熟悉的js来编写安卓和ios应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;strong&gt;虚拟DOM&lt;/strong&gt;+优秀的&lt;strong&gt;Diffing算法&lt;/strong&gt;，尽量减少与真实DOM的交互&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​	虚拟DOM发生改变后会对比之前的虚拟DOM，从而减少真实DOM的更新渲染过程&lt;/p&gt;
&lt;h1 id=&#34;5-react基本使用&#34;&gt;5. React基本使用&lt;/h1&gt;
&lt;h2 id=&#34;51-js库引入注意引入顺序&#34;&gt;5.1 js库引入（注意引入顺序）&lt;/h2&gt;
&lt;p&gt;1.react.development.js：react核心库&lt;/p&gt;
&lt;p&gt;2.react-dom.development.js：提供操作DOM的react扩展库&lt;/p&gt;
&lt;p&gt;3.babel.min.js：解析JSX语法代码转为js代码的库&lt;/p&gt;
&lt;h2 id=&#34;52-虚拟dom的创建&#34;&gt;5.2 虚拟DOM的创建&lt;/h2&gt;
&lt;h3 id=&#34;521-关于虚拟dom&#34;&gt;5.2.1 关于虚拟DOM&lt;/h3&gt;
&lt;p&gt;（1）本质上是object类型的&lt;strong&gt;一般对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是react内部在用，无需真实DOM上那么多属性&lt;/p&gt;
&lt;p&gt;（3）虚拟DOM最终会被React转化为真实DOM，呈现在页面上&lt;/p&gt;
&lt;h3 id=&#34;522-创建的两种方式&#34;&gt;5.2.2 创建的两种方式&lt;/h3&gt;
&lt;p&gt;（1）纯js方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = React.createElement(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;标签名&amp;#39;&lt;/span&gt;,{标签属性},&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;标签内容&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = React.createElement(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;,{id:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;title&amp;#39;&lt;/span&gt;},&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;React.createElement(&amp;#39;&lt;/span&gt;span&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;,{},&amp;#39;&lt;/span&gt;HELLO REACT!&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		可以看到，若遇标签嵌套情况，利用纯js来写非常复杂。&lt;/p&gt;
&lt;p&gt;（2）JSX方式&lt;/p&gt;
&lt;p&gt;​		是react 定义的一种类似于 XML 的 JS 扩展语法: JS + XML。本质是React.createElement(&amp;lsquo;标签名&amp;rsquo;,{标签属性},&amp;lsquo;标签内容&amp;rsquo;)方法的语法糖，极大地简化了创建虚拟DOM过程。&lt;strong&gt;在利用JSX创建之前，需要将&lt;!-- raw HTML omitted --&gt;标签的type属性由默认的text/javascript改为text/babel&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;1）JSX创建虚拟DOM的写法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = (
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;title&amp;#34;&lt;/span&gt;&amp;gt;
    	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;span&lt;/span&gt;&amp;gt;hello,react&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;span&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt;&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）&lt;strong&gt;JSX语法&lt;/strong&gt;如下：&lt;/p&gt;
&lt;p&gt;1.遇到 &amp;lt;开头的代码，以标签的语法解析：html 同名标签转换为 html 同名元素，其它标签需要特别解析：若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。&lt;/p&gt;
&lt;p&gt;2.遇到以 { 开头的代码，以 JS 语法解析: &lt;strong&gt;标签中的 js 表达式必须用{ }包含&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;只有一个根标签&lt;/strong&gt;，若想在虚拟DOM中再新增标签，外面需要统一包一个标签&lt;/p&gt;
&lt;p&gt;4.标签必须&lt;strong&gt;闭合&lt;/strong&gt;（自闭合也行）&lt;/p&gt;
&lt;p&gt;5.标签内样式的类名指定不要用class，要用&lt;strong&gt;className&lt;/strong&gt;，例如&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;6.标签中内联样式要用**style={{key:value}}**的形式去写，多个单词的要用小驼峰,例如style={{fontSize:&amp;lsquo;29px&amp;rsquo;}}&lt;/p&gt;
&lt;h2 id=&#34;53-渲染虚拟dom&#34;&gt;5.3 渲染虚拟DOM&lt;/h2&gt;
&lt;p&gt;基本语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;ReactDOM.render(VirtualDOM,containerDOM)
ReactDOM.render(VDOM,&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;54-模块与组件的理解&#34;&gt;5.4 模块与组件的理解&lt;/h2&gt;
&lt;p&gt;模块指的是向外提供特定功能的js程序，一般就是一个js文件，模块化是为了更好地复用js，简化js的编写，提高js运行效率。模块化只针对js；而组件指的是用来实现局部功能效果的代码和资源的集合（html、css、js、image、video等），组件化是为了复用编码，简化项目编码，提高运行效率&lt;/p&gt;
&lt;p&gt;1.5 jsx练习&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;.%5Cimage-20210321123104572.png&#34; alt=&#34;image-20210321123104572&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;

    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/react.development.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/react-dom.development.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/babel.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;

    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/babel&amp;#34;&lt;/span&gt;&amp;gt;
    &lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        一定注意区分【js语句（代码）】与【js表达式】
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            1.表达式：一个表达式会产生一个值，可以放任何一个需要值的地方
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                下面这些都是表达式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                a
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                a+b
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                demo(1)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                arr.map()//用来处理数组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                function test(){}//定义方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            2.语句（代码）：控制代码走向，没有值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                if(){}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                for(){}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                switch(){case}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    */&lt;/span&gt;
        &lt;span style=&#34;color:#228b22&#34;&gt;//模拟一些数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; data = [&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Angular&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Vue&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;React&amp;#39;&lt;/span&gt;]
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; data2 = [&amp;lt;li&amp;gt;Angular&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;, &amp;lt;li&amp;gt;Vue&amp;lt;/li&amp;gt;, &amp;lt;li&amp;gt;React&amp;lt;/li&amp;gt;]//React可以自动遍历数组&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; obj = {name1:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Angular&amp;#39;&lt;/span&gt;,name2:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Vue&amp;#39;&lt;/span&gt;,name3:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;React&amp;#39;&lt;/span&gt;}&lt;span style=&#34;color:#228b22&#34;&gt;//对象不能作为React的节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//jsx创建虚拟DOM
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = (
            &amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;前端js框架列表&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
                &amp;lt;ul&amp;gt;
                    {
                        data.map((a,index)=&amp;gt;{
                            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;li key={index}&amp;gt;{a}&amp;lt;&lt;span style=&#34;color:#1c7e71&#34;&gt;/li&amp;gt;/&lt;/span&gt;/虚拟dom必须有唯一标识key
                        })
                    }
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
        ReactDOM.render(VDOM, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;body&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;补充&#34;&gt;补充：&lt;/h2&gt;
&lt;p&gt;1）早期传输数据的两种格式&lt;/p&gt;
&lt;p&gt;​		最早使用XML来存储与传输数据的，XML即扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。典型写法如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;student&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Tom&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/student&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		后面改为利用JSON格式。JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。主要是得益于JSON的两个重要方法：JSON.parse()和JSON.stringfy()，分别用来快速将JSON中的数据解析为数组和对象，以及快速把JS中的数组和对象转化为JSON字符串&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;name&amp;#39;:&amp;#39;gsq&amp;#39;,&amp;#39;age&amp;#39;:26&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）XML和JSON的优缺点对比&lt;/p&gt;
&lt;p&gt;(1)可读性两者基本相同，一边是建议的语法，一边是规范的标签形式，XML可读性较好些；
(2)可扩展性方面差不多；
(3)编码难度方面，不借助工具的话，XML较为复杂；
(4)解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。
(5)流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous Javascript and JSON)了；
(7)数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些；
(8)数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互；
(9)数据描述方面，JSON对数据的描述性比XML较差；
(10)传输速度方面， JSON的速度要远远快于XML。&lt;/p&gt;
- https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/ - </description>
        </item>
    
    
    
        <item>
        <title>初识Hooks</title>
        <link>https://gsemir0418.github.io/posts/reacthooks/</link>
        <pubDate>Fri, 25 Jun 2021 23:07:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/reacthooks/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/reacthooks/ -&lt;h1 id=&#34;1-hook简介&#34;&gt;1 Hook简介&lt;/h1&gt;
&lt;h2 id=&#34;11-基本概念&#34;&gt;1.1 基本概念&lt;/h2&gt;
&lt;p&gt;Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使⽤ state 以及其他的 React 特性。&lt;/p&gt;
&lt;h2 id=&#34;12-react-hooks优势&#34;&gt;1.2 React Hooks优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数组件不能使⽤state，⼀般只⽤于⼀些简单⽆交互的组件，⽤作信息展示，即我们上⾯说的傻⽠组件使⽤，如果需要交互更改状态等复杂逻辑时就需要使⽤class组件了&lt;/p&gt;
&lt;p&gt;React Hooks让我们更好的拥抱函数式编程，让函数式组件也能使⽤state功能，因为函数式组件⽐class组件更简洁好⽤，因为React Hooks的出现，相信未来我们会更多的使⽤函数式组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副作⽤问题&lt;/p&gt;
&lt;p&gt;我们⼀般称数据获取、订阅、定时执⾏任务、⼿动修改ReactDOM这些⾏为都可以称为副作⽤由于React Hooks的出现，我们可以使⽤useEffect来处理组件副作⽤问题，所以我们的函数式组件也能进⾏副作⽤逻辑的处理了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有状态的逻辑重⽤组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复杂的状态管理&lt;/p&gt;
&lt;p&gt;之前我们使⽤redux、dva、mobx第三⽅状态管理器来进⾏复杂的状态管理&lt;/p&gt;
&lt;p&gt;现在我们可以使⽤useReducer、useContext配合使⽤实现复杂状态管理，不⽤再依赖第三⽅状态管理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发效率和质量问题&lt;/p&gt;
&lt;p&gt;函数式组件⽐class组件简洁，开发的体验更好，效率更⾼同时应⽤的性能也更好&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-usestate&#34;&gt;2 useState&lt;/h1&gt;
&lt;h2 id=&#34;21-定义&#34;&gt;2.1 定义&lt;/h2&gt;
&lt;p&gt;useState：组件状态管理钩⼦，使函数组件能够使⽤state&lt;/p&gt;
&lt;h2 id=&#34;22-基本使用&#34;&gt;2.2 基本使用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [state,setState]=useState(initState)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;state是要设置的状态&lt;/li&gt;
&lt;li&gt;setState是更新state的⽅法，只是⼀个⽅法名，可以随意更改&lt;/li&gt;
&lt;li&gt;initState是初始的state，可以是随意的数据类型，也可以是回调函数，但是函数必须是有返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23-实际应用&#34;&gt;2.3 实际应用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React, { useState } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; UseS() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [count, setState] = useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;你点击了{count}次&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;onClick&lt;/span&gt;={() =&amp;gt; setState(count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)}&amp;gt;点 击&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;3-useeffect&#34;&gt;3 useEffect&lt;/h1&gt;
&lt;h2 id=&#34;31-定义&#34;&gt;3.1 定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;useEffect：副作⽤处理钩⼦&lt;/li&gt;
&lt;li&gt;数据获取、订阅、定时执⾏任务、⼿动修改ReactDOM这些⾏为都可以称为副作⽤。⽽useEffect就是为了处理这些副作⽤⽽⽣的&lt;/li&gt;
&lt;li&gt;useEffect也是componentDidMount、componentDidUpdate和componentWillUnmount这⼏个⽣命周期⽅法的统⼀&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-基本使用&#34;&gt;3.2 基本使用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;useEffect(callback,array)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;callback：回调函数，作⽤是处理副作⽤逻辑。可以返回⼀个函数，⽤作清理&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;useEffect(() =&amp;gt;{
	&lt;span style=&#34;color:#228b22&#34;&gt;//副作⽤逻辑
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	xxxxxx
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ()=&amp;gt;{
		&lt;span style=&#34;color:#228b22&#34;&gt;//清理副作⽤需要清理的内容
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//类似于componentWillUnmount，组件渲染和组件卸载前执⾏的代码
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
},[array])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;array(可选参数)：数组，⽤于控制useEffect的执⾏。分三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空数组，则只会执⾏⼀次（即初次渲染render）,相当于componentDidMount&lt;/li&gt;
&lt;li&gt;⾮空数组，useEffect会在数组发⽣改变后执⾏，相当于componentDidUpdate&lt;/li&gt;
&lt;li&gt;不填array这个数组，useEffect每次渲染都会执⾏&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33-实际应用&#34;&gt;3.3 实际应用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; { useState, useEffect } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; UseE = () =&amp;gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [count, setState] = useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)

    useEffect(() =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//更新⻚⾯标题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.title = &lt;span style=&#34;color:#cd5555&#34;&gt;`您点击了&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;count&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;次了哦`&lt;/span&gt;
    }, [count])
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;你点击了{count}次&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;onClick&lt;/span&gt;={() =&amp;gt; setState(count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)}&amp;gt;点 击&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    )
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; UseE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;4-usecontext&#34;&gt;4 useContext&lt;/h1&gt;
&lt;h2 id=&#34;41-定义&#34;&gt;4.1 定义&lt;/h2&gt;
&lt;p&gt;context就是⽤来更⽅便的实现全局数据共享的，但是由于他并不是那么好⽤，所以我们⼀般会使⽤第三⽅状态管理器来实现全局数据共享&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redux&lt;/li&gt;
&lt;li&gt;dva&lt;/li&gt;
&lt;li&gt;mobx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是针对context上下⽂提出的⼀个Hooks提出的⼀个API，它接受React.createContext()的返回值作为参数，即context对象，并返回最近的context&lt;/p&gt;
&lt;p&gt;使⽤useContext是不需要再使⽤Provider和Consumer的&lt;/p&gt;
&lt;p&gt;当最近的context更新时，那么使⽤该context的hook将会重新渲染&lt;/p&gt;
&lt;h2 id=&#34;42-基本使用&#34;&gt;4.2 基本使用&lt;/h2&gt;
&lt;p&gt;store.js中创建数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Context = React.createContext({ age: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;18&amp;#39;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;jerry&amp;#39;&lt;/span&gt; })
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; Context
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;组件中使用useContext接收数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React, { useContext } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; Context from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;./store&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; UseC = () =&amp;gt; {
    &lt;span style=&#34;color:#228b22&#34;&gt;//使⽤useContext
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; ctx = useContext(Context)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;姓名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h2&lt;/span&gt;&amp;gt;{ctx.name}&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h2&lt;/span&gt;&amp;gt;年龄&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{ctx.age}岁&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    )
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; UseC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gsemir0418.github.io/posts/reacthooks/ - </description>
        </item>
    
    
    
        <item>
        <title>Node文件模块</title>
        <link>https://gsemir0418.github.io/posts/node%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/</link>
        <pubDate>Fri, 25 Jun 2021 14:40:55 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/node%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/node%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/ -&lt;h1 id=&#34;1-待办事项命令行程序需求&#34;&gt;1 待办事项命令行程序需求&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以列出所有的todo；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增、编辑、删除todo；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改todo状态为已完成/未完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;t
t add 任务名
t clear
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-创建命令行项目&#34;&gt;2 创建命令行项目&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;空文件夹下，执行：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;yarn init -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;-y&lt;/code&gt;表示跳过交互式对话（确定版本等信息），根据默认值生成&lt;code&gt;package.json&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;index.js&lt;/code&gt;，引入&lt;code&gt;commanderjs&lt;/code&gt;库，添加&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;clear&lt;/code&gt;子命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; program = require(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;commander&amp;#39;&lt;/span&gt;);

program
	.option(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;-x,--xxx&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;desc of x&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;// x选项 即在node index命令后输入的选项
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;program
	.command(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;add&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;// 子命令
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	.description(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;add a task&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;// 子命令描述
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	.action((...args) =&amp;gt; { &lt;span style=&#34;color:#228b22&#34;&gt;//拿到用户输入的所有字符串参数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; words = args.slice(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;).join(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;// 由于最后一个参数默认是command对象，因此需要对参数进行预处理
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	})
program
	.command(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;clear&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;// 子命令
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	.description(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;clear all tasks&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;// 子命令描述
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	.action(() =&amp;gt; {
    	&lt;span style=&#34;color:#228b22&#34;&gt;// 执行clear操作
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	})

program.parse(process.argv);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;3-实现创建任务功能&#34;&gt;3 实现创建任务功能&lt;/h1&gt;
&lt;p&gt;一般命令行程序的入口文件为&lt;code&gt;cli.js&lt;/code&gt;，而&lt;code&gt;index.js&lt;/code&gt;中写主要功能实现，因此将index重命名为&lt;code&gt;cli.js&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;31-nodejs读取文件api&#34;&gt;3.1 &lt;code&gt;nodejs&lt;/code&gt;读取文件api：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210625131432414.png&#34; alt=&#34;image-20210625131432414&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;fs.readFile(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;/etc/passwd&amp;#39;&lt;/span&gt;, (err, data) =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (err) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; err;
  console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回调会传入两个参数 &lt;code&gt;(err, data)&lt;/code&gt;，其中 &lt;code&gt;data&lt;/code&gt; 是文件的内容。&lt;/p&gt;
&lt;p&gt;如果没有指定 &lt;code&gt;encoding&lt;/code&gt;，则返回原始的 buffer。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;options&lt;/code&gt; 中的当&lt;code&gt;flag&lt;/code&gt; 选项采用字符串时，可用以下标志：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;a&#39;&lt;/code&gt; - 打开文件用于追加。如果文件不存在，则创建该文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;ax&#39;&lt;/code&gt; - 与 &lt;code&gt;&#39;a&#39;&lt;/code&gt; 相似，但如果路径已存在则失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;a+&#39;&lt;/code&gt; - 打开文件用于读取和追加。如果文件不存在，则创建该文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;ax+&#39;&lt;/code&gt; - 与 &lt;code&gt;&#39;a+&#39;&lt;/code&gt; 相似，但如果路径已存在则失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;as&#39;&lt;/code&gt; - 以同步模式打开文件用于追加。如果文件不存在，则创建该文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;as+&#39;&lt;/code&gt; - 以同步模式打开文件用于读取和追加。如果文件不存在，则创建该文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;r&#39;&lt;/code&gt; - 打开文件用于读取。如果文件不存在，则出现异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;r+&#39;&lt;/code&gt; - 打开文件用于读取和写入。如果文件不存在，则出现异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;rs+&#39;&lt;/code&gt; - 以同步模式打开文件用于读取和写入。指示操作系统绕过本地的文件系统缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-获取home路径下的todo文件&#34;&gt;3.2 获取home路径下的.todo文件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nodejs&lt;/code&gt;获取系统home目录路径：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; homedir = require(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;os&amp;#39;&lt;/span&gt;).homedir()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nodejs&lt;/code&gt;获取用户home目录路径，如果未获取到，则使用系统home路径&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; home = process.env.HOME || homedir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;处理路径格式问题，以适配任意系统：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; p = require(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;path&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; dbPath = p.join(home,&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.todo&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;33-nodejs写文件api&#34;&gt;3.3 &lt;code&gt;nodejs&lt;/code&gt;写文件api&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210625133113444.png&#34; alt=&#34;image-20210625133113444&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-创建任务功能初步实现&#34;&gt;3.4 创建任务功能初步实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; fs = require(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;)
module.exports.add = (title) =&amp;gt; {
	fs.readFile(dbPath, {flag:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;a+&amp;#39;&lt;/span&gt;}, (error,data) =&amp;gt; {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(error) { console.log(error) }
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; list
            &lt;span style=&#34;color:#228b22&#34;&gt;// 如果文件是空的，则创建一个数组来存数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
              	&lt;span style=&#34;color:#228b22&#34;&gt;// 尝试让list等于data中的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				list = JSON.parse(data.toString())&lt;span style=&#34;color:#228b22&#34;&gt;// 字符串=&amp;gt;数组对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt;(error2) {
                &lt;span style=&#34;color:#228b22&#34;&gt;// 如果出错（说明data为空，解析失败），则让list成为空数组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				list = []
			}
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在list中添加一个任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; task = { title, done:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; }
			list.push(task)
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; string = JSON.stringfy(list)&lt;span style=&#34;color:#228b22&#34;&gt;// 数组对象=&amp;gt;字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// 储存任务到文件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			fs.writeFile(dbPath, string+&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;, (error3) =&amp;gt; {
				&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(error3){ console.log(error) }
			})
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;35-优化代码&#34;&gt;3.5 优化代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;理清功能需求，从而&lt;strong&gt;面向接口&lt;/strong&gt;编程，最终优化结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; db = require(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;./db.js&amp;#39;&lt;/span&gt;)
module.exports.add = (title) =&amp;gt; {
  &lt;span style=&#34;color:#228b22&#34;&gt;// 读取之前的任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; list = db.read()
  &lt;span style=&#34;color:#228b22&#34;&gt;// 添加一个title任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  list.push({ title, done: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; })
  &lt;span style=&#34;color:#228b22&#34;&gt;// 存储任务到文件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  db.write(list)

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;db&lt;/code&gt;对象，内置读写两个接口，并使用&lt;code&gt;Promise&lt;/code&gt;进行封装，db.js:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; db = {
    &lt;span style=&#34;color:#228b22&#34;&gt;// 读文件接口
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    read(path = dbPath) {&lt;span style=&#34;color:#228b22&#34;&gt;// 指定默认参数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
            &lt;span style=&#34;color:#228b22&#34;&gt;// 读取之前的任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            fs.readFile(path, { flag: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;a+&amp;#39;&lt;/span&gt; }, (error, data) =&amp;gt; {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (error) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; reject(error)
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; list
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
                    list = JSON.parse(data.toString())

                } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (error) {
                    list = []
                    &lt;span style=&#34;color:#228b22&#34;&gt;// 这是个异步函数，list不能直接返回，因为这是存在于回调函数中的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                }
                resolve(list)&lt;span style=&#34;color:#228b22&#34;&gt;// 如果成功了，则解析并返回list给外面
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            })
        })
    },
	&lt;span style=&#34;color:#228b22&#34;&gt;// 写文件接口
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    write(list, path = dbPath) {&lt;span style=&#34;color:#228b22&#34;&gt;// 指定默认参数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; string = JSON.stringify(list)
            fs.writeFile(path, string + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;, (error) =&amp;gt; {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (error)  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; reject(error) 
                &lt;span style=&#34;color:#228b22&#34;&gt;// return表示如果到这个if里面的话就终止，不用往后面走了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                resolve()
            })
        })
    }
}
module.exports = db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;4实现其他功能&#34;&gt;4.实现其他功能&lt;/h1&gt;
&lt;h2 id=&#34;41-清除全部任务&#34;&gt;4.1 清除全部任务&lt;/h2&gt;
&lt;p&gt;实际上就是写一个空数组将其覆盖即可，同样也是异步的:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;module.exports.clear = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;await&lt;/span&gt; db.write([])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;42-交互列表及交互功能实现&#34;&gt;4.2 交互列表及交互功能实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引入制作命令行交互功能的库：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; inquirer = require(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;inquirer&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;用户在执行&lt;code&gt;node cli&lt;/code&gt;命令时，进入交互界面，则需要对用户输入的命令条数进行判断
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process.argv&lt;/code&gt;能够获取到用户输入的参数数组，在&lt;code&gt;cli.js&lt;/code&gt;中对其长度进行判断：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (process.argv.length === &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) {
	api.showAll()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;index.js&lt;/code&gt;中编写主要实现逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;module.exports.showAll = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#228b22&#34;&gt;// 读取之前的任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; list = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;await&lt;/span&gt; db.read()
    &lt;span style=&#34;color:#228b22&#34;&gt;// 打印之前的任务，并变为可操作列表
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    printTasks(list)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;交互列表首页：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; printTasks(list) {
    inquirer&lt;span style=&#34;color:#228b22&#34;&gt;// 制作控制台交互功能的库
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        .prompt({
            type: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;list&amp;#39;&lt;/span&gt;,
            name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;index&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#228b22&#34;&gt;// 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            message: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;请选择你想操作的任务：&amp;#39;&lt;/span&gt;,
            choices: [
                { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;退出&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;-1&amp;#39;&lt;/span&gt; },
                ...list.map((task, index) =&amp;gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { name: &lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;task.done ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;[x]&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;[_]&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;index + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;task.title&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;, value: index.toString() } }),
                { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;+创建任务&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;-2&amp;#39;&lt;/span&gt; }
            ]
        }).then(answer =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; index = &lt;span style=&#34;color:#658b00&#34;&gt;parseInt&lt;/span&gt;(answer.index)&lt;span style=&#34;color:#228b22&#34;&gt;// 把选中的index转换成数字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (index &amp;gt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) {
                &lt;span style=&#34;color:#228b22&#34;&gt;// 说明选中了一个任务，继续进入操作列表
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                askForAction(list, index)
            } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (index === -&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) {
                &lt;span style=&#34;color:#228b22&#34;&gt;// 说明选择的是创建任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                askForCreate(list, index)
            }
        })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;选中任务时的操作列表：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; askForAction(list, index) {
    inquirer.prompt({
        type: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;list&amp;#39;&lt;/span&gt;,
        name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;action&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#228b22&#34;&gt;// 用户选中后返回的value的名称
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        message: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;请选择操作&amp;#39;&lt;/span&gt;,
        choices: [
            { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;退出&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;quit&amp;#39;&lt;/span&gt; },
            { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;已完成&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;markAsDone&amp;#39;&lt;/span&gt; },
            { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;未完成&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;markAsUnDone&amp;#39;&lt;/span&gt; },
            { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;修改标题&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;updateTitle&amp;#39;&lt;/span&gt; },
            { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;删除任务&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;remove&amp;#39;&lt;/span&gt; },
        ],
    }).then(answer =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt; (answer.action) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;markAsDone&amp;#39;&lt;/span&gt;:
                list[index].done = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
                db.write(list)
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;markAsUnDone&amp;#39;&lt;/span&gt;:
                list[index].done = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;
                db.write(list)
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;updateTitle&amp;#39;&lt;/span&gt;:
                &lt;span style=&#34;color:#228b22&#34;&gt;// 更新标题需要一个输入框
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                inquirer.prompt({
                    type: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;input&amp;#39;&lt;/span&gt;,
                    name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;title&amp;#39;&lt;/span&gt;,
                    message: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;设置新标题：&amp;#39;&lt;/span&gt;,
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt;: list[index].title&lt;span style=&#34;color:#228b22&#34;&gt;// 默认值为原标题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                }).then(answer1 =&amp;gt; {
                    list[index].title = answer1.title
                    db.write(list)
                })
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;remove&amp;#39;&lt;/span&gt;:
                list.splice(index, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)
                db.write(list)
                console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;删除成功！&amp;#39;&lt;/span&gt;)
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;选择创建任务时的操作：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; askForCreate(list) {
    inquirer.prompt({
        type: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;input&amp;#39;&lt;/span&gt;,
        name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;title&amp;#39;&lt;/span&gt;,
        message: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;输入任务标题：&amp;#39;&lt;/span&gt;
    }).then(answer =&amp;gt; {
        list.push({ title: answer.title, done: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; })
        db.write(list)
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;5-发布至npm&#34;&gt;5 发布至npm&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;修改&lt;code&gt;package.json&lt;/code&gt;，添加&lt;code&gt;”bin“&lt;/code&gt;，指定命令行程序最终命令是什么；添加”files“，声明哪些文件在发布时是有用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;bin&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;:&lt;/span&gt;{
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;#34;t&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cli.js&amp;#34;&lt;/span&gt;
}&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;,&lt;/span&gt;
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;files&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;:&lt;/span&gt;[ &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;*.js&amp;#34;&lt;/span&gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;cli.js&lt;/code&gt;第一行加入&lt;code&gt;shebang&lt;/code&gt;，告诉命令行使用什么来运行&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;#!/usr/bin/env node
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;正式发布前，需要使用yrm或nrm将淘宝源修改为原始源&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;nrm ls
nrm use npm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;登录&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;npm adduser / yarn login
yarn publish / npm publish
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;下载&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;yarn global add node-todo-gsq 
npm i -g node-todo-gsq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;卸载&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;yarn global remove node-todo-gsq
npm uninstall -g node-todo-gsq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;升级&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;yarn upgrade node-todo-gsq
npm update node-todo-gsq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;或安装时指定版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;npm i -g node-todo-gsq@0.0.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gsemir0418.github.io/posts/node%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/ - </description>
        </item>
    
    
    
        <item>
        <title>React组件生命周期</title>
        <link>https://gsemir0418.github.io/posts/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
        <pubDate>Fri, 25 Jun 2021 11:09:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ -&lt;h1 id=&#34;1-生命周期的理解&#34;&gt;1 生命周期的理解&lt;/h1&gt;
&lt;h2 id=&#34;11-引出生命周期&#34;&gt;1.1 引出生命周期&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让指定的文本做显示* */* 隐藏的渐变动画&lt;/li&gt;
&lt;li&gt;从完全可见，到彻底消失，耗时2S&lt;/li&gt;
&lt;li&gt;点击“不活了”按钮从界面中卸载组件&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码及笔记如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Life &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//只要页面发生更新，则说明是状态在驱动
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        state = {
            opacity: &lt;span style=&#34;color:#b452cd&#34;&gt;0.5&lt;/span&gt;
        }

        death = () =&amp;gt; {
            ReactDOM.unmountComponentAtNode(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//和render一样 是由React帮忙调用的 因此不用写成箭头函数的形式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//执行时机：组件挂载到页面后
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidMount() {
            &lt;span style=&#34;color:#228b22&#34;&gt;//起个名字 挂到实例自身 方便清除时用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.timer = setInterval(() =&amp;gt; {
                &lt;span style=&#34;color:#228b22&#34;&gt;//获取状态值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; opacity = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.opacity
                &lt;span style=&#34;color:#228b22&#34;&gt;//每次-0.1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                opacity -= &lt;span style=&#34;color:#b452cd&#34;&gt;0.1&lt;/span&gt;
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (opacity &amp;lt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) opacity = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
                &lt;span style=&#34;color:#228b22&#34;&gt;//设置新的透明度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ opacity })
            }, &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt;)
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//执行时机：组件将要被卸载
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUnmount() {
            clearInterval(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.timer)
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//执行时机：初始化渲染、状态更新后
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        render() {
            &lt;span style=&#34;color:#228b22&#34;&gt;//如果将定时器函数放到render中，那么由于定时器中更新了state值，render函数就会不断被调用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//从而形成无限递归
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// setInterval(() =&amp;gt; {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     //获取状态值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     let opacity = this.state.opacity
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     //每次-0.1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     opacity -= 0.1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     if (opacity &amp;lt;= 0) opacity = 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     //设置新的透明度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     this.setState({ opacity })
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// }, 200)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;h2 style={{ opacity: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.opacity }}&amp;gt;React学不会怎么办&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.death}&amp;gt;不活了&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }
    }
    ReactDOM.render(&amp;lt;Life /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;12-生命周期的理解&#34;&gt;1.2 生命周期的理解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;合适的时间节点做合适的事&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组件从创建到死亡它会经历一些特定的阶段。&lt;/li&gt;
&lt;li&gt;React 组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。&lt;/li&gt;
&lt;li&gt;我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-react生命周期旧&#34;&gt;2 React生命周期（旧）&lt;/h1&gt;
&lt;h2 id=&#34;21-react生命周期图旧&#34;&gt;2.1 React生命周期图（旧）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;.%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png&#34; alt=&#34;react生命周期(旧)&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Count &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//构造器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        constructor(props) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---constructor&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { count: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; }
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要挂载的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillMount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentWillMount&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件是否更新的钩子 相当于&amp;#34;阀门&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        shouldComponentUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---shouldComponentUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要更新的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentWillUpdate&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;// 加一事件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        add = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ count: count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; })
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//强制更新组件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        force = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.forceUpdate()
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件更新完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidUpdate&amp;#39;&lt;/span&gt;);
        }

        render() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---render&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;h2&amp;gt;当前求和为&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{count}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.add}&amp;gt;点我+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.death}&amp;gt;卸载组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.force}&amp;gt;不更新状态&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;只是强制更新一下组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件挂载完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidMount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidMount&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要卸载的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUnmount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---conponentWillUnmount&amp;#39;&lt;/span&gt;);
        }

        death = () =&amp;gt; {
            ReactDOM.unmountComponentAtNode(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
        }
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//父组件A
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; A &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        state = {
            carName: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;奔驰&amp;#39;&lt;/span&gt;
        }

        changeCar = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ carName: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;奥迪&amp;#39;&lt;/span&gt; })
        }

        render() {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;div&amp;gt;我是A组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeCar}&amp;gt;点我切换汽车信息&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;B carName={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.carName} /&amp;gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//子组件B
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; B &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {

        &lt;span style=&#34;color:#228b22&#34;&gt;//第一次打开界面 发现其未运行 点击按钮后才会运行此钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//改名为componentWillReceiveNewProps更为准确
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要接收新的props的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillReceiveProps() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---componentWillReceiveProps&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//控制组件更新的阀门
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        shouldComponentUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---shouldComponentUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#228b22&#34;&gt;//只要写了此钩子 必须return一个布尔值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要更新的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---componentWillUpdate&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件更新完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---componentDidUpdate&amp;#39;&lt;/span&gt;);
        }

        render() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---render&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;我是B组件&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;接受到的汽车是{&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props.carName}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }
    }

    ReactDOM.render(&amp;lt;Count /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;22-总结生命周期旧&#34;&gt;2.2 总结生命周期（旧）&lt;/h2&gt;
&lt;p&gt;生命周期的三个阶段（旧）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化阶段: 由 ReactDOM.render()触发&amp;mdash;初次渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    	1. constructor()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 2. componentWillMount() 
   
 3. render()
   
 4. **componentDidMount**()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​        		一般在此钩子中做一些初始化的事：开启定时器，发送网络请求、订阅消息&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发&lt;/p&gt;
&lt;p&gt;​	1. shouldComponentUpdate()&lt;/p&gt;
&lt;p&gt;​    2. componentWillUpdate()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 3. **render**()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    		4. componentDidUpdate()&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;卸载组件: 由 ReactDOM.unmountComponentAtNode()触发&lt;/p&gt;
&lt;p&gt;​    1. &lt;strong&gt;componentWillUnmount&lt;/strong&gt;()&lt;/p&gt;
&lt;p&gt;​        	一般做一些收尾的事：关闭定时器、取消订阅消息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;23-react生命周期图新&#34;&gt;2.3 React生命周期图（新）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;.%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png&#34; alt=&#34;react生命周期(新)&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Count &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//构造器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        constructor(props) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---constructor&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { count: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; }
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//通过props获取派生状态对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; getDerivedStateFromProps(props, state) {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---getDerivedStateFromProps&amp;#39;&lt;/span&gt;, props, state);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//必须有返回值，返回值可以是null也可以是state对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//return {count:2}//会覆盖初始化的state，且影响更新过程，setState方法失效（因为横跨挂载和更新过程）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//return props //可以接收props作为参数并返回 使得state值在任何时候都取决于props
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//在更新之前获取快照
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        getSnapshotBeforeUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---getSnapshotBeforeUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;atguigu&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//返回null或者snapshot值（任何值）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件是否更新的钩子 相当于&amp;#34;阀门&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        shouldComponentUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---shouldComponentUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;// 加一事件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        add = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ count: count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; })
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//强制更新组件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        force = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.forceUpdate()
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件更新完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//默认接收两个参数，分别是prevProps，prevState和snapshot值（例如滚轮位置）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidUpdate(prevProps, prevState, snapshot) {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidUpdate&amp;#39;&lt;/span&gt;, prevProps, prevState, snapshot);
        }

        render() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---render&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;h2&amp;gt;当前求和为&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{count}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.add}&amp;gt;点我+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.death}&amp;gt;卸载组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.force}&amp;gt;不更新状态&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;只是强制更新一下组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件挂载完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidMount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidMount&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要卸载的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUnmount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---conponentWillUnmount&amp;#39;&lt;/span&gt;);
        }

        death = () =&amp;gt; {
            ReactDOM.unmountComponentAtNode(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
        }
    }

    ReactDOM.render(&amp;lt;Count count={&lt;span style=&#34;color:#b452cd&#34;&gt;199&lt;/span&gt;} /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;24-总结生命周期新&#34;&gt;2.4 总结生命周期（新）&lt;/h2&gt;
&lt;p&gt;生命周期的三个阶段（新）&lt;/p&gt;
&lt;p&gt;1.初始化阶段: 由 ReactDOM.render()触发&amp;mdash;初次渲染&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1. constructor() 
  
 2. **getDerivedStateFromProps**() 
  
 3. render() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		4. &lt;strong&gt;componentDidMount&lt;/strong&gt;() 即将出生的那一刻&lt;/p&gt;
&lt;p&gt;2.更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发&lt;/p&gt;
&lt;p&gt;​    	1. getDerivedStateFromProps ()&lt;/p&gt;
&lt;p&gt;​    	2. shouldComponentUpdate()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 3. **render**() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​    	4. &lt;strong&gt;getSnapshotBeforeUpdate&lt;/strong&gt;()&lt;/p&gt;
&lt;p&gt;​    	5. componentDidUpdate()&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;卸载组件: 由 ReactDOM.unmountComponentAtNode()触发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. **componentWillUnmount**() 即将离去的那一刻
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;25-新旧生命周期对比&#34;&gt;2.5 新旧生命周期对比&lt;/h2&gt;
&lt;p&gt;即将在18版本废除三个钩子（willmount，willupdate，willreceiveprops）&lt;/p&gt;
&lt;p&gt;新增了两个钩子（getDerivedStateFromProps，getSnapshotBeforeUpdate）&lt;/p&gt;
- https://gsemir0418.github.io/posts/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ - </description>
        </item>
    
    
    
        <item>
        <title>React Hooks全解</title>
        <link>https://gsemir0418.github.io/posts/%E6%96%B9%E6%96%B9%E7%9A%84hooks/</link>
        <pubDate>Tue, 01 Jun 2021 17:02:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/%E6%96%B9%E6%96%B9%E7%9A%84hooks/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/%E6%96%B9%E6%96%B9%E7%9A%84hooks/ -&lt;h1 id=&#34;1usestate&#34;&gt;1.useState&lt;/h1&gt;
&lt;h2 id=&#34;使用状态&#34;&gt;使用状态&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [n, setN] = React.useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [user, setUser] = React.useState({name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;F&amp;#39;&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;注意事项1不可局部更新&#34;&gt;注意事项1：不可局部更新&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [user, setUser] = useState({name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;,age:&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;})

setState({
	name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Sam&amp;#39;&lt;/span&gt;
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结果得到的是{name:&amp;lsquo;Sam&amp;rsquo;}，age属性消失了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（可以在之前加上&amp;hellip;user，表示复制user的全部属性到这个新对象中）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说明对于state不能部分setState，因为setState&lt;strong&gt;不会帮我们合并属性&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际上React中所有hooks都不能自动合并属性，需要我们自己去操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;注意事项2地址要变&#34;&gt;注意事项2：地址要变&lt;/h2&gt;
&lt;p&gt;setState(obj)如果obj地址不变，那么React就认为数据没有变化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [user, setUser] = useState({name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;,age:&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;})

user.name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Sam&amp;#39;&lt;/span&gt;

setState(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;表面上我们先改变了user对象的name属性（实际上也确实改变了），再将user对象setState进去，setState之后的user对象并没有改变。&lt;/li&gt;
&lt;li&gt;对于React来说，对象还是user（地址没变），因此React不认为user改变了，依然加载的是原来的user。&lt;/li&gt;
&lt;li&gt;上一个例子，是在setState中创建了一个新对象，因此React会直接加载新的对象（这也反映了&lt;strong&gt;setState并不会直接修改state，而是生成一个新的state&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;usestate接受函数&#34;&gt;useState接受函数&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [state, setState] = useState(() =&amp;gt; {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; initState
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数返回初始state，且只执行一次，节约反复更新渲染组件时js引擎的解析时间（首次渲染时会解析，再次更新组件时js就不会解析这个匿名函数了）&lt;/p&gt;
&lt;h2 id=&#34;setstate接受函数&#34;&gt;setState接受函数&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [n, setN] = useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)

setN(n + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)

setN(n + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然运行了两次setN，但运行结果为1，并不是预想中的2，原因同样是由于setN并不会改变n的值，n始终为0&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;setN(i =&amp;gt; i + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;传入函数的方式并&lt;strong&gt;没有直接传入state进行计算&lt;/strong&gt;，仅仅是一个&lt;strong&gt;形式化的操作&lt;/strong&gt;而已，建议优先选用此种方式进行setState&lt;/p&gt;
&lt;h1 id=&#34;2usereducer&#34;&gt;2.useReducer&lt;/h1&gt;
&lt;h2 id=&#34;用来践行fluxredux的思想&#34;&gt;(用来践行Flux/Redux的思想)&lt;/h2&gt;
&lt;h2 id=&#34;1创建初始值initialstate&#34;&gt;1.创建初始值initialState&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; initial = { n = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2创建所有操作reducerstateaction&#34;&gt;2.创建所有操作reducer(state,action)&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; reducer = (state, action) =&amp;gt;{&lt;span style=&#34;color:#228b22&#34;&gt;//旧状态，操作的类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(action.type === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;add&amp;#39;&lt;/span&gt;){
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { n: state.n+action.number}
	}&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(action.type === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;mult&amp;#39;&lt;/span&gt;){
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { n: state.n*&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; }
	}&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Error&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;unknown type&amp;#39;&lt;/span&gt;)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3传给usereducer得到读和写api调用写type--操作类型-&#34;&gt;3.传给useReducer，得到读和写API，调用写（{type : &amp;lsquo;操作类型&amp;rsquo; }）&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; App(){
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [state, dispatch] = useReducer(reducer,initial)
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; onClick = ()=&amp;gt;{
		dispatch({type: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;add&amp;#39;&lt;/span&gt;, number : &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;})&lt;span style=&#34;color:#228b22&#34;&gt;//参数为action对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4总的来说usereducer是usestate的复杂版&#34;&gt;4.总的来说，useReducer是useState的复杂版&lt;/h2&gt;
&lt;h1 id=&#34;3usecontext&#34;&gt;3.useContext&lt;/h1&gt;
&lt;h2 id=&#34;1上下文是局部的全局变量&#34;&gt;1.上下文是局部的全局变量&lt;/h2&gt;
&lt;h2 id=&#34;2使用方法&#34;&gt;2.使用方法&lt;/h2&gt;
&lt;p&gt;1.使用C = createContext(initial)创建上下文&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; C = createContext(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.使用&amp;lt;C.Provider/&amp;gt;圈定作用域&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [n, setN] = useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)

&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;C.Provider&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;value&lt;/span&gt;={{n, setN}}&amp;gt;&lt;span style=&#34;color:#228b22&#34;&gt;//将state和setState作为对象值传入上下文C中
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;App&lt;/span&gt;/&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;C.Provider&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.在作用域内使用useContext(C)来使用上下文&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {n, setN} = useContext(C)

onClick = () =&amp;gt;{setN(n =&amp;gt; n + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3注意事项&#34;&gt;3.注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不是响应式&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;在一个模块中将C里面的值改变，另一个模块不会感知到这个变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4useeffect&#34;&gt;4.useEffect&lt;/h1&gt;
&lt;h2 id=&#34;1副作用&#34;&gt;1.副作用&lt;/h2&gt;
&lt;p&gt;实际上叫做afterRender更好，每次render后运行&lt;/p&gt;
&lt;p&gt;（对环境的改变即为副作用，如修改document.title&lt;/p&gt;
&lt;p&gt;但我们不一定非要把副作用放在useEffect里&lt;/p&gt;
&lt;h2 id=&#34;2用途&#34;&gt;2.用途&lt;/h2&gt;
&lt;p&gt;1.替代componentDidMount使用，[ ]作为第二个参数，表示除第一次渲染后执行外，之后不会再执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;useEffect(() =&amp;gt;{
	console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;第一次渲染后执行&amp;#39;&lt;/span&gt;)
},[])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当第二个参数为空时，表示组件的任何状态变化后都会执行，包括第一次渲染后&lt;/p&gt;
&lt;p&gt;2.替代componentDidUpdate使用，可指定依赖，当n变化是执行，包括第一次渲染后&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;useEffect(() =&amp;gt;{
	console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;n变化后执行&amp;#39;&lt;/span&gt;)
},[n])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.替代componentWillUnmount使用，通过return&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;useEffect(() =&amp;gt;{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; id = setInterval(() =&amp;gt;{
		console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;hi&amp;#39;&lt;/span&gt;)
    },&lt;span style=&#34;color:#b452cd&#34;&gt;2000&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; () =&amp;gt;{&lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;.clearInterval(id)}
  },[])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上三种用途可同时存在&lt;/p&gt;
&lt;h2 id=&#34;3特点&#34;&gt;3.特点&lt;/h2&gt;
&lt;p&gt;如果同时存在多个useEffect，会&lt;strong&gt;按照出现次序执行&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;5uselayouteffect&#34;&gt;5.useLayoutEffect&lt;/h1&gt;
&lt;h2 id=&#34;布局副作用&#34;&gt;布局副作用&lt;/h2&gt;
&lt;p&gt;会在浏览器渲染前（屏幕像素改变之前）执行&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;useLayoutEffect&lt;strong&gt;总是比&lt;/strong&gt;useEffect要先执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;useLayoutEffect中的任务最好确实影响了Layout&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;经验&#34;&gt;经验&lt;/h2&gt;
&lt;p&gt;为了用户体验，优先使用useEffect（先将画面渲染给用户，再进行副作用）&lt;/p&gt;
&lt;h1 id=&#34;6usememo&#34;&gt;6.useMemo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;React中默认有多余的render，导致依赖其他状态的无关组件会被再次执行渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用React.memo(Child)将无关组件进行封装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Child2 = React.memo(Child)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Bug：但如果Child的props中有接收到的是函数时，但随着父组件的执行渲染，函数表达虽然没变，但此时地址改变了，故仍被再次执行，导致Child仍再次渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用useMemo封装此函数解决这个问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; onClickChild = useMemo(() =&amp;gt;{
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; () =&amp;gt;{ ...}
},[m])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个参数是()=&amp;gt;value&lt;/p&gt;
&lt;p&gt;第二个参数是依赖[m,n]&lt;/p&gt;
&lt;p&gt;只有当依赖变化时，才会计算出新的value；如果依赖不变，那就重用之前的value&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与Vue2中的computed相似&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般先memo组件，再useMemo函数&lt;/p&gt;
&lt;h1 id=&#34;7usecallback&#34;&gt;7.useCallBack&lt;/h1&gt;
&lt;p&gt;如果value是个函数，useMemo就要写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;useMemo( () = &amp;gt; (x) =&amp;gt;{console.log(x) } )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;写起来很复杂，因此使用useCallback解决&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; onClickChild = useCallback ( (x) = &amp;gt; { log(x) }, [m] )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;8useref&#34;&gt;8.useRef&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果需要一个值，在组件不断render时保持不变，用useRef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; count = useRef(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;读取：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;count.current
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;也可以将ref作为属性绑定到元素上，使用此ref能够引用到组件对应的DOM对象，类似document.getElementById&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9forwardref&#34;&gt;9.forwardRef&lt;/h1&gt;
&lt;p&gt;由于props无法传递ref属性，导致不能直接在子组件上定义ref&lt;/p&gt;
&lt;p&gt;可以使用forwarRef将组件封装成新组件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Button2 = React.forwardRef((props,ref)=&amp;gt;{
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;ref&lt;/span&gt;={ref} {&lt;span style=&#34;color:#658b00&#34;&gt;...props&lt;/span&gt;}/&amp;gt;
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上只是允许了子组件接受一个新参数ref&lt;/p&gt;
&lt;h1 id=&#34;10替代redux&#34;&gt;10.替代Redux&lt;/h1&gt;
&lt;p&gt;1.将数据集中在store对象&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; store = {
	user:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,
	books:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,
	movies:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.将所有操作集中在reducer&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; reducer = (state, action) =&amp;gt; {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt; (action.type) {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;setUser&amp;#34;&lt;/span&gt;:
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { ...state, user: action.user };
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;setBooks&amp;#34;&lt;/span&gt;:
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { ...state, books: action.books };
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;setMovies&amp;#34;&lt;/span&gt;:
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { ...state, movies: action.movies };
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt;:
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Error&lt;/span&gt;();
	}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.创建Context&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Context = React.createContext(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4.创建对数据的读写API（只能写在函数组件中）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [state, dispatch] = useReducer(reducer, store)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.将第四步的内容放到第三步的Context（把读写API赋值给Context.Provider）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Context.Provider&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;value&lt;/span&gt;={{state,dispatch}}&amp;gt;
	...
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Context.Provider&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6.用Context.Provider将Context提供给所有组件（包起来）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Context.Provider&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;value&lt;/span&gt;={{state,dispatch}}&amp;gt;
	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;User&lt;/span&gt;/&amp;gt;
	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Books&lt;/span&gt;/&amp;gt;
	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Movies&lt;/span&gt;/&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Context.Provider&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;7.各个组件用useContext获取读写API&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; User() {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { state, dispatch } = useContext(Context);
	useEffect(() =&amp;gt; {
		ajax(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/user&amp;#34;&lt;/span&gt;).then(user =&amp;gt; {
		dispatch({ type: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;setUser&amp;#34;&lt;/span&gt;, user: user });
		});
	}, [ ]);
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
		&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt;&amp;gt;个人信息&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt;&amp;gt;
			&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;name: {state.user ? state.user.name : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;}&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
	)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;8.模块化&lt;/p&gt;
&lt;p&gt;![priceless-jennings-gyls6 - CodeSandbox - Google Chrome 2021_6_2 14_29_21](article_img/priceless-jennings-gyls6 - CodeSandbox - Google Chrome 2021_6_2 14_29_21-1622626575090.png)&lt;/p&gt;
&lt;h1 id=&#34;11自定义hooks&#34;&gt;11.自定义hooks&lt;/h1&gt;
&lt;p&gt;index.jsx:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;react&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; ReactDOM from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;react-dom&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; useList from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;./hooks/useList&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; App() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { list, deleteIndex, addItem } = useList();
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;className&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;App&amp;#34;&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt;&amp;gt;List&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;
        &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;submit&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#658b00&#34;&gt;onClick&lt;/span&gt;={() =&amp;gt; {
          addItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;jack&amp;#34;&lt;/span&gt;);
        }}
      &amp;gt;
        添加
      &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
      {list ? (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ol&lt;/span&gt;&amp;gt;
          {list.map((item, index) =&amp;gt; (
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;li&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;key&lt;/span&gt;={item.id}&amp;gt;
              {item.name}
              &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;
                &lt;span style=&#34;color:#658b00&#34;&gt;onClick&lt;/span&gt;={() =&amp;gt; {
                  deleteIndex(index);
                }}
              &amp;gt;
                删除
              &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
            &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;li&lt;/span&gt;&amp;gt;
          ))}
        &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ol&lt;/span&gt;&amp;gt;
      ) : (
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;加载中...&amp;#34;&lt;/span&gt;
      )}
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
  );
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; rootElement = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;);
ReactDOM.render(&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;App&lt;/span&gt; /&amp;gt;, rootElement);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;hooks/useList.js:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; { useState, useEffect } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;react&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; useList = () =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [list, setList] = useState(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;);
  useEffect(() =&amp;gt; {
    ajax(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/list&amp;#34;&lt;/span&gt;).then((list) =&amp;gt; {
      setList(list);
    });
  }, []); &lt;span style=&#34;color:#228b22&#34;&gt;// [] 确保只在第一次运行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; {
    list: list,
    addItem: (name) =&amp;gt; {
      setList([...list, { id: &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.random(), name: name }]);
      &lt;span style=&#34;color:#228b22&#34;&gt;//先复制一遍之前的list，再z后面写一个新的对象即可
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    },
    deleteIndex: (index) =&amp;gt; {
      setList(list.slice(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, index).concat(list.slice(index + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)));
      &lt;span style=&#34;color:#228b22&#34;&gt;//截取从开头到被删对象的部分数组（不包括被删对象）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#228b22&#34;&gt;//截取从被删对象下一个开始到最后的部分数组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#228b22&#34;&gt;//通过concat将两个数组合并
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
  };
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; useList;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; ajax() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve([
        { id: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Frank&amp;#34;&lt;/span&gt; },
        { id: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Jack&amp;#34;&lt;/span&gt; },
        { id: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt; },
        { id: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;4&amp;#34;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt; }
      ]);
    }, &lt;span style=&#34;color:#b452cd&#34;&gt;2000&lt;/span&gt;);
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gsemir0418.github.io/posts/%E6%96%B9%E6%96%B9%E7%9A%84hooks/ - </description>
        </item>
    
    
    
        <item>
        <title>可视化大屏技术</title>
        <link>https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E6%8A%80%E6%9C%AF/</link>
        <pubDate>Fri, 28 May 2021 09:30:55 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E6%8A%80%E6%9C%AF/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E6%8A%80%E6%9C%AF/ -&lt;h1 id=&#34;1-背景和意义&#34;&gt;1 背景和意义&lt;/h1&gt;
&lt;p&gt;数据可视化即把相对复杂、抽象的数据通过可视化的方式以人们更易理解的形式展示出来的一系列手段，旨在更形象地表达数据内在的信息和规律，促进数据信息的传播和应用。在当前Web前端可视化技术的支持下，数据可视化除了“可视”，还有可交流、可互动的特点。数据可视化的本质是数据空间到图形空间的映射。是抽象数据的具象表达。&lt;/p&gt;
&lt;p&gt;大屏数据可视化是以大屏为主要展示载体的数据可视化设计。基于大屏展示“大面积、炫酷动效、丰富色彩”等主要特征，通过关键信息大屏共享的方式可方便企业团队讨论与决策，因此大屏也常应用与数据分析监测领域。目前大屏数据可视化主要分为信息展示、数据分析及监控预警三大类。&lt;/p&gt;
&lt;p&gt;随着大数据的发展，可视化大屏在各个行业的应用越来越广泛，尤其是在政府、商业、金融、制造等行业的业务场景中。例如，可视化大屏作为传递信息的有效手段，在城市智能运营中心、应急指挥中心、公安监控中心、电力调度中心、金融交易大厅等部门和机构中发挥着重要作用；同时它具有日常监测、分析判断、应急指挥、展示汇报等多种功能，在提高科学管理方面也发挥着重要作用。&lt;/p&gt;
&lt;h1 id=&#34;2-技术原理&#34;&gt;2 技术原理&lt;/h1&gt;
&lt;p&gt;数据可视化展示大屏主要基于&lt;code&gt;React&lt;/code&gt;框架、&lt;code&gt;ECharts&lt;/code&gt;可视化图表库、&lt;code&gt;CSS&lt;/code&gt;布局与适配以及特效制作等Web前端可视化开发技术。&lt;/p&gt;
&lt;h2 id=&#34;21-react框架&#34;&gt;2.1 React框架&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;是一个声明式，高效且灵活的用于构建用户界面的JavaScript库。使用React可以将一些简短、独立的代码片段组合成复杂的UI界面，这些代码片段被称作“组件”。数据可视化展示大屏中的每个展示模块均可封装为独立的组件，方便复用与后期维护。&lt;/p&gt;
&lt;h2 id=&#34;22-大屏适配公式&#34;&gt;2.2 大屏适配公式&lt;/h2&gt;
&lt;p&gt;可视化大屏设计稿的比例通常为16:9，为了保证其在不同分辨率及屏幕比例上的展示效果，在开发时需运用大屏适配算法对大屏尺寸信息进行换算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./ksh1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;公式1.1&lt;/code&gt;为大屏尺寸适配公式，其中&lt;code&gt;Wp&lt;/code&gt;为页面有效宽度，&lt;code&gt;Hp&lt;/code&gt;为页面有效高度。&lt;/p&gt;
&lt;h2 id=&#34;23-元素适配公式&#34;&gt;2.3 元素适配公式&lt;/h2&gt;
&lt;p&gt;锁定好大屏尺寸后，需要利用到&lt;code&gt;CSS3&lt;/code&gt;中新增的rem单位结合适配公式，对大屏内部各元素的尺寸针对不同比例的屏幕进行适配。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rem&lt;/code&gt;（Root em）是&lt;code&gt;CSS3&lt;/code&gt;新增的一个相对单位，使用&lt;code&gt;rem&lt;/code&gt;为元素设定相对尺寸时，相对的只是HTML根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。&lt;code&gt;公式1.2&lt;/code&gt;为内部元素尺寸适配公式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./ksh2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-echarts可视化图表库&#34;&gt;2.4 ECharts可视化图表库&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ECharts&lt;/code&gt;是一个使用JavaScript实现的开源可视化库，涵盖各行业图表，满足各种需求。其主要特点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丰富的可视化类型：提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于BI的漏斗图，仪表盘，并且支持图与图之间的混搭。&lt;/li&gt;
&lt;li&gt;多种数据格式无需转换直接使用：内置的dataset属性（4.0+）支持直接传入包括二维表，key-value等多种格式的数据源，此外还支持输入TypedArray格式的数据。&lt;/li&gt;
&lt;li&gt;千万数据的前端展现：通过增量渲染技术（4.0+），配合各种细致的优化，ECharts能够展现千万级的数据量。&lt;/li&gt;
&lt;li&gt;移动端优化：针对移动端交互做了细致的优化，例如移动端小屏上适于用手指在坐标系中进行缩放、平移。PC端也可以用鼠标在图中进行缩放（用鼠标滚轮）、平移等。&lt;/li&gt;
&lt;li&gt;多渲染方案，跨平台使用：支持以Canvas、SVG（4.0+）、VML的形式渲染图表。&lt;/li&gt;
&lt;li&gt;深度的交互式数据探索：提供了图例、视觉映射、数据区域缩放、tooltip、数据刷选等开箱即用的交互组件，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。&lt;/li&gt;
&lt;li&gt;多维数据的支持以及丰富的视觉编码手段：对于传统的散点图等，传入的数据也可以是多个维度的。&lt;/li&gt;
&lt;li&gt;动态数据：数据的改变驱动图表展现的改变。&lt;/li&gt;
&lt;li&gt;绚丽的特效：针对线数据，点数据等地理数据的可视化提供了吸引眼球的特效。&lt;/li&gt;
&lt;li&gt;通过GL实现更多更强大绚丽的三维可视化：在VR，大屏场景里实现三维的可视化效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-技术实现方案&#34;&gt;3 技术实现方案&lt;/h1&gt;
&lt;h2 id=&#34;31-大屏设计流程&#34;&gt;3.1 大屏设计流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据业务场景抽取关键指标&lt;/p&gt;
&lt;p&gt;关键指标是一些概括性词语，是对一组或者一系列数据的统称。一般情况下，一个指标在大屏上独占一块区域。以supAPS为例，这里的关键指标有：原料库存、计划实际对比、产品库存与库存成本等。确定关键指标后，根据业务需求拟定各个指标展示的优先级（主、次、辅）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选定可视化图表类型&lt;/p&gt;
&lt;p&gt;同一个指标的数据，从不同维度分析就有不同结果。当确定好各项指标的分析维度后，事实上图表类型也就基本确定了。如库存成本选用柱状图的形式，装置加工选用表格的形式，计划实际对比选择折线图的形式等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面布局&lt;/p&gt;
&lt;p&gt;图表类型和屏幕尺寸确立后，接下来要对设计稿进行页面布局的划分。核心业务指标安排在中间位置、占较大面积；其余的指标按优先级依次在核心指标周围展开。一般把有关联的指标让其相邻或靠近，把图表类型相近的指标放一起，这样能减少观者认知上的负担并提高信息传递的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面开发&lt;/p&gt;
&lt;p&gt;在定义好分析指标、确定页面布局后，进行前端样式的开发工作，将数据接入到前端并呈现出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整体细节调优与测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面开发完成后，将真实页面投放到大屏进行的测试与优化。主要分为两部分：&lt;/p&gt;
&lt;p&gt;1）视觉方面的测试：关键视觉元素、字体字号、页面动效、图形图表等是否按预期显示、有无变形、错位等情况。&lt;/p&gt;
&lt;p&gt;2）性能与数据方面的测试：图形图表动画是否流畅、数据加载、刷新有无异常；页面长时间展示是否存在奔溃、卡死等情况；后台控制系统能否正常切换前端页面显示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;32-大屏适配&#34;&gt;3.2 大屏适配&lt;/h2&gt;
&lt;p&gt;基于大屏适配公式，计算页面尺寸。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; clientWidth = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.documentElement.clientWidth
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; clientHeight = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.documentElement.clientHeight
	&lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;.pageWidth =
		clientWidth / clientHeight &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt; / &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;
		 ? clientHeight * (&lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt; / &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;)
 : clientWidth
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; pageHeight = pageWidth / (&lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt; / &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;)
&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.write(&lt;span style=&#34;color:#cd5555&#34;&gt;`&amp;lt;style&amp;gt;html{font-size:&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;pageWidth / &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;px&amp;lt;/style&amp;gt;`&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在通用&lt;code&gt;SCSS&lt;/code&gt;文件中定义实际尺寸&lt;code&gt;rem&lt;/code&gt;与设计稿&lt;code&gt;px&lt;/code&gt;单位之间的换算关系函数，默认选用分辨率为1920*1080。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-less&#34; data-lang=&#34;less&#34;&gt;@function px($n) {@return $n / 1920 * 100rem;}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;33-css布局&#34;&gt;3.3 CSS布局&lt;/h2&gt;
&lt;p&gt;对于内部展示区块，采用&lt;code&gt;CSS3&lt;/code&gt;的&lt;code&gt;Grid&lt;/code&gt;布局方式。&lt;code&gt;Grid&lt;/code&gt; 布局是将容器划分成&amp;quot;行&amp;quot;和&amp;quot;列&amp;quot;，产生单元格，然后指定&amp;quot;项目所在&amp;quot;的单元格，可以看作是二维布局。利用&lt;code&gt;grid-template-areas&lt;/code&gt;属性定义区域，通过&lt;code&gt;fr&lt;/code&gt;关键字确定区块间的比例关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./ksh3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-特效制作&#34;&gt;3.4 特效制作&lt;/h2&gt;
&lt;h3 id=&#34;1-边框制作&#34;&gt;1 边框制作&lt;/h3&gt;
&lt;p&gt;利用css中&lt;code&gt;box-shadow&lt;/code&gt;可以无限叠加的机制，在原来边框的基础上，四角分别叠加两层不同颜色的边框阴影，实现边框效果的制作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./ksh4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;box-shadow&lt;/span&gt;: 
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;20px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-18px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;133661&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-20px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-18px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;0e325f&lt;/span&gt;,
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;20px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-18px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;0e325f&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-20px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-18px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;0e325f&lt;/span&gt;, 
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;10px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-8px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;164b88&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-10px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-8px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;0d4483&lt;/span&gt;,
 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;10px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-8px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;0d4483&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-10px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;-8px&lt;/span&gt; #&lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;0d4483&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-霓虹字体&#34;&gt;2 霓虹字体&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;@keyframes&lt;/code&gt;编写文本阴影动画，实现标题文本的霓虹闪烁的特效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./ksh5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;@&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;keyframes&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;shining&lt;/span&gt; {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-shadow&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;182&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;211&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;207&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.9&lt;/span&gt;),
        &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;182&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;211&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;207&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.3&lt;/span&gt;), &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.5&lt;/span&gt;),
        &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;21&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.9&lt;/span&gt;), &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;34&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.8&lt;/span&gt;),
        &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;54&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.9&lt;/span&gt;);
 	 }
 	 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;to&lt;/span&gt; {
         &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-shadow&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;182&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;211&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;207&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;),
         &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;182&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;211&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;207&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.4&lt;/span&gt;), &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;22&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.6&lt;/span&gt;),
         &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.8&lt;/span&gt;), &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;48&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0.9&lt;/span&gt;),
         &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;70&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rgba&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;115&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;223&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
 	 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3-表格滚动特效&#34;&gt;3 表格滚动特效&lt;/h3&gt;
&lt;p&gt;大屏展示中的表格数据显示范围有限，因此需要使表格自动滚动来动态展示表格数据。根据表格滚动条与顶端距离，即判断&lt;code&gt;scrollHeight&lt;/code&gt;与&lt;code&gt;scrollTop&lt;/code&gt;的大小关系，通过设置定时器的方式不断增加&lt;code&gt;scrollTop&lt;/code&gt;的值，从而实现表格数据自动滚动的效果。&lt;/p&gt;
&lt;h2 id=&#34;35-echarts图表的制作&#34;&gt;3.5 ECharts图表的制作&lt;/h2&gt;
&lt;p&gt;引入&lt;code&gt;ECharts&lt;/code&gt;库后，通过&lt;code&gt;echarts.init&lt;/code&gt;方法初始化&lt;code&gt;ECharts实例&lt;/code&gt;并通过&lt;code&gt;setOption&lt;/code&gt;方法生成图表。参考官网的option示例配置，根据需求调整坐标轴与系列图形样式的属性参数即可。&lt;/p&gt;
&lt;p&gt;将图表本身与其所处区块元素视为一个整体的组件进行开发，提高复用性，方便后期维护。组件采用React函数组件形式，结合&lt;code&gt;useRef&lt;/code&gt;、&lt;code&gt;useEffect&lt;/code&gt;等&lt;code&gt;hooks&lt;/code&gt;函数，实现图表的初始化与参数配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./khs6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;36-实时更新数据&#34;&gt;3.6 实时更新数据&lt;/h2&gt;
&lt;p&gt;实时更新数据由于没有实际后端数据，因此使用定时器与随机数的方式模拟实时数据的更新。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;setInterval(() =&amp;gt; {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; newData = [
		{ name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;甲&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.random() * &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt; },
		{ name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;乙&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.random() * &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt; },
		{ name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;丙&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.random() * &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt; },
   	]
    renderMyChart(newData)
}, &lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
- https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E6%8A%80%E6%9C%AF/ - </description>
        </item>
    
    
    
        <item>
        <title>React基础</title>
        <link>https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Thu, 29 Apr 2021 23:11:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/ -&lt;h1 id=&#34;1-react定义组件&#34;&gt;1 React定义组件&lt;/h1&gt;
&lt;h2 id=&#34;11-函数式组件&#34;&gt;1.1 函数式组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数式组件适用于简单组件的定义，其首字母需大写，且虚拟DOM元素必须有结束标签&lt;/li&gt;
&lt;li&gt;函数组件中的this指向为window，但babel编译后默认开启了严格模式，因此结果为undefined&lt;/li&gt;
&lt;li&gt;返回的虚拟DOM元素只能有一个根元素&lt;/li&gt;
&lt;li&gt;渲染函数式组件的过程：
&lt;ol&gt;
&lt;li&gt;React解析组件标签，找到了Demo组件&lt;/li&gt;
&lt;li&gt;发现组件式使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM。随后呈现在页面中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Demo(){
	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1&amp;gt;函数式组件&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;适用于简单组件的定义&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
}
ReactDOM.render(&amp;lt;Demo/&amp;gt;,&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;12-类式组件&#34;&gt;1.2 类式组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;继承&lt;strong&gt;React.Component&lt;/strong&gt;类，组件名首字母必须&lt;strong&gt;大写&lt;/strong&gt;，且虚拟DOM元素必须有&lt;strong&gt;结束标签&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须有&lt;strong&gt;render()&lt;strong&gt;方法，且render方法必须有&lt;/strong&gt;返回值&lt;/strong&gt;，返回的虚拟DOM元素只能&lt;strong&gt;有一个根元素&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渲染类式组件的过程&lt;/p&gt;
&lt;p&gt;1.React 内部会创建组件实例对象&lt;/p&gt;
&lt;p&gt;2.调用 render()得到虚拟 DOM, 并解析为真实 DOM&lt;/p&gt;
&lt;p&gt;3.插入到指定的页面元素内部&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; MyComponent &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component{
	render(){
	&lt;span style=&#34;color:#228b22&#34;&gt;//render放在MyComponent的原型对象（React.Component）上，供实例使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//render中的this指向MyComponent实例对象（组件实例对象）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;render方法中的this指向：&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1&amp;gt;类式组件&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;适用于复杂组件的定义&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
	}
}
ReactDOM.render(&amp;lt;MyComponent/&amp;gt;,&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;2-组件实例三大属性&#34;&gt;2 组件实例三大属性&lt;/h1&gt;
&lt;h2 id=&#34;21-state&#34;&gt;2.1 state&lt;/h2&gt;
&lt;h3 id=&#34;211-state基本使用&#34;&gt;2.1.1 state基本使用&lt;/h3&gt;
&lt;p&gt;state 是组件对象最重要的属性，值是对象(可以包含多个 key-value 的组合)&lt;/p&gt;
&lt;p&gt;组件被称为&amp;quot;状态机&amp;quot;，通过更新组件的 state 来更新对应的页面显示(重新渲染组件)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：定义一个展示天气信息的组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认展示天气炎热 或 凉爽&lt;/li&gt;
&lt;li&gt;点击文字切换天气&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码如下：（无效）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Weather &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
	constructor(props) {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; }&lt;span style=&#34;color:#228b22&#34;&gt;//this指向当前类的实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//解决方案
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//利用bind将原型对象上的changeWeather方法的this指向强行绑定为实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//从而形成一个新函数，再将其赋值给新的变量changeWeather
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather.bind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }
	changeWeather() {
        &lt;span style=&#34;color:#228b22&#34;&gt;//changWeather方法放在Weather的原型对象上，供实例对象使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//由于changeWeather是作为onClick的回调，所以是直接调用的，而不是通过实例调用的，此时this应该指向window对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//又因为类中的方法默认开启了局部严格模式，所以结果为undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
	render() {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state&lt;span style=&#34;color:#228b22&#34;&gt;//this是组件实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
		&lt;span style=&#34;color:#228b22&#34;&gt;//绑定默认事件时，要注意C大写，如onBlur；
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//事件的回调函数不需要加括号，否则react会将方法执行后的返回值（这里是undefined）赋给onClick，使得单击事件失效
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1 onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
	}
}
ReactDOM.render(&amp;lt;Weather /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;212-注意&#34;&gt;2.1.2 注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件中 render 方法中的 this 为组件实例对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件自定义的方法中 this 为 undefined，如何解决？&lt;/p&gt;
&lt;p&gt;1.强制绑定 this: 通过函数对象的 bind()&lt;/p&gt;
&lt;p&gt;2.箭头函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态数据，不能直接修改或更新，需要在方法中使用**this.setState({})**来修改，修改后代码如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Weather &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {

    &lt;span style=&#34;color:#228b22&#34;&gt;//构造器调用几次？————1次
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    constructor(props) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
        &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;, wind: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;微风&amp;#39;&lt;/span&gt; }&lt;span style=&#34;color:#228b22&#34;&gt;//this指向当前类的实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//解决this指向问题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather.bind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//render调用几次？————1+n次 1是指初始化的那次 n是状态更新的次数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    render() {
        &lt;span style=&#34;color:#228b22&#34;&gt;//读取状态，ES6的解构赋值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot, wind } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state&lt;span style=&#34;color:#228b22&#34;&gt;//this是组件实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1 onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;{wind}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//changeWeather调用几次？————点几次调用几次
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeWeather() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//获取原来的isHot值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; isHot = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.isHot
        &lt;span style=&#34;color:#228b22&#34;&gt;//严重注意，state状态值不能直接更改，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//this.state.isHot = !isHot是错误的,react是严格的单向绑定，值在这变化虽然有效，但react不认
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//状态值必须通过setState方法进行更新，且更新是一种合并状态，而不是替换，否则微风也就不会显示了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ isHot: !isHot })
    }
}
ReactDOM.render(&amp;lt;Weather /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;213-state的简写方式&#34;&gt;2.1.3 state的简写方式：&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Weather &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//利用类的特性，可以直接写赋值语句，表示在该类的每一个实例对象中添加state属性
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;, wind: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;微风&amp;#39;&lt;/span&gt; }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot, wind } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1 onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;{wind}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//自定义方法（只能作为事件的回调，因为react只会帮我们new实例之后执行render方法）：赋值语句+箭头函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//由于箭头函数没有自己的this，回去找外层的this，正是实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeWeather = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; isHot = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.isHot
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ isHot: !isHot })
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
    }
}
ReactDOM.render(&amp;lt;Weather/&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;22-props&#34;&gt;2.2 props&lt;/h2&gt;
&lt;h3 id=&#34;221-props基本使用&#34;&gt;2.2.1 props基本使用&lt;/h3&gt;
&lt;p&gt;每个组件对象都会有 props(properties 的简写)属性，&lt;strong&gt;组件标签的所有属性都保存在 props 中&lt;/strong&gt;，可以通过标签属性从组件外向组件内传递变化的数据&lt;/p&gt;
&lt;p&gt;注意: 组件内部不要修改 props 数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：自定义用来显示一个人员信息的组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Person &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
        &lt;span style=&#34;color:#228b22&#34;&gt;//console.log(this);//均指向实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//this.props.name = &amp;#34;haha&amp;#34;会报错，因为props是只读的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { name, age, gender } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;name:{name}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
                &amp;lt;li&amp;gt;age:{age + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
                &amp;lt;li&amp;gt;gender:{gender}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
        )
    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;//注意传参时的age要用{}包裹起来
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;ReactDOM.render(&amp;lt;Person name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tom&amp;#39;&lt;/span&gt; age={&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;} gender=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
ReactDOM.render(&amp;lt;Person name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt; age={&lt;span style=&#34;color:#b452cd&#34;&gt;20&lt;/span&gt;} gender=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test2&amp;#39;&lt;/span&gt;))

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; personAjax = { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;ajax&amp;#39;&lt;/span&gt;, age: &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;, gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; }
&lt;span style=&#34;color:#228b22&#34;&gt;//可以使用展开运算符批量传递props
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;ReactDOM.render(&amp;lt;Person {...personAjax} /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test3&amp;#39;&lt;/span&gt;))
&lt;span style=&#34;color:#228b22&#34;&gt;//注意，此处的{...personajax}并不是展开运算符的克隆对象用法，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//而是babel和react允许展开运算符展开对象并赋值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(...personAjax);&lt;span style=&#34;color:#228b22&#34;&gt;//为空，虽然允许展开，但不能让你随意操作
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;222-对props进行限制&#34;&gt;2.2.2 对props进行限制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;姓名必须指定，且为字符串类型&lt;/li&gt;
&lt;li&gt;性别为字符串类型，如果性别没有指定，默认为男&lt;/li&gt;
&lt;li&gt;年龄为字符串类型，且为数字类型，默认值为 18&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!--&lt;/span&gt; 引入propstype&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;用来对props进行限制&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;（&lt;/span&gt;其实就是弹出一些警告&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;）&lt;/span&gt; --&amp;gt;
&amp;lt;script src=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/prop-types.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/script&amp;gt;&lt;/span&gt;
...
	&lt;span style=&#34;color:#228b22&#34;&gt;//对标签属性进行类型、必要性等的限制
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    Person.propTypes = {&lt;span style=&#34;color:#228b22&#34;&gt;//此处的p小写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        name:PropTypes.string.isRequired,&lt;span style=&#34;color:#228b22&#34;&gt;//别忘逗号和P和T都大写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        gender:PropTypes.string,
        age:PropTypes.number,
        eat:PropTypes.func&lt;span style=&#34;color:#228b22&#34;&gt;//如果要限制传递方法，注意方法的名字是func
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//指定默认标签属性值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    Person.defaultProps={
        gender:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;不男不女&amp;#39;&lt;/span&gt;,
        age:&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;223-props的简写方式&#34;&gt;2.2.3 props的简写方式&lt;/h3&gt;
&lt;p&gt;就是将定义在类之外的限制props的语句作为静态方法，写到类中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若要给类的原型对象自身加属性，用static关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Person &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//对标签属性进行类型、必要性等的限制
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; propTypes = {&lt;span style=&#34;color:#228b22&#34;&gt;//此处的p小写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        name: PropTypes.string.isRequired,&lt;span style=&#34;color:#228b22&#34;&gt;//别忘逗号和P和T都大写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        gender: PropTypes.string,
        age: PropTypes.number,
        eat: PropTypes.func&lt;span style=&#34;color:#228b22&#34;&gt;//如果要限制传递方法，注意方法的名字是func
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//指定默认标签属性值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; defaultProps = {
        gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;不男不女&amp;#39;&lt;/span&gt;,
        age: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { name, age, gender } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;ul&amp;gt;
            	&amp;lt;li&amp;gt;name:{name}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
				&amp;lt;li&amp;gt;age:{age + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
				&amp;lt;li&amp;gt;gender:{gender}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
			&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
		)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;224-类式组件中的构造器与props&#34;&gt;2.2.4 类式组件中的构造器与props&lt;/h3&gt;
&lt;p&gt;类中的构造器可以省略&lt;/p&gt;
&lt;p&gt;如果写了构造器，同时接受props并传递给super，那么就可以通过this.props访问实例对象的props了（几乎用不到）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;constructor(props) {
    &lt;span style=&#34;color:#228b22&#34;&gt;//构造器是否接受props，是否传递给super，取决于：
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//是否希望在构造器中通过this访问props（即访问每个实例对象的props）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//一般能不写就不写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;constractor&amp;#39;&lt;/span&gt;,props);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;225-函数组件使用props&#34;&gt;2.2.5 函数组件使用props&lt;/h3&gt;
&lt;p&gt;函数组件因为自身能够传参，因此可以使用props属性&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//函数组件因为自身能够传参，因此可以使用props属性
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Person(props) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {name,gender,age} = props
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;姓名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{name}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
            &amp;lt;li&amp;gt;性别&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{gender}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
            &amp;lt;li&amp;gt;年龄&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{age}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
        &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
    )
}
&lt;span style=&#34;color:#228b22&#34;&gt;//对props进行限制，只能放到函数外面了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;Person.propTypes = {&lt;span style=&#34;color:#228b22&#34;&gt;//此处的p小写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    name: PropTypes.string.isRequired,&lt;span style=&#34;color:#228b22&#34;&gt;//别忘逗号和P和T都大写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    gender: PropTypes.string,
    age: PropTypes.number,
    eat: PropTypes.func&lt;span style=&#34;color:#228b22&#34;&gt;//如果要限制传递方法，注意方法的名字是func
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
Person.defaultProps = {
    gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;不男不女&amp;#39;&lt;/span&gt;,
    age: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
}
ReactDOM.render(&amp;lt;Person age={&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;} gender=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;23-refs&#34;&gt;2.3 refs&lt;/h2&gt;
&lt;p&gt;组件内的标签可以定义 ref 属性来&lt;strong&gt;标识自己&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求: 自定义组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;点击按钮, 提示第一个输入框中的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当第 2 个输入框失去焦点时, 提示这个输入框中的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;231-字符串形式的ref&#34;&gt;2.3.1 字符串形式的ref&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
                &amp;lt;input ref=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;inp1&amp;#34;&lt;/span&gt; type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
                &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&amp;amp;nbsp;&lt;/span&gt;
                &amp;lt;input ref=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;inp2&amp;#34;&lt;/span&gt; onBlur={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2} placeholder=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;失去焦点弹出输入内容&amp;#34;&lt;/span&gt; type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
    }
    showData = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {inp1} = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.refs
        alert(inp1.value)
    }
    showData2 = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {inp2} = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.refs
        alert(inp2.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;232-回调函数形式的ref&#34;&gt;2.3.2 回调函数形式的ref&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
                {&lt;span style=&#34;color:#228b22&#34;&gt;/* c表示currentNode，this表示组件实例对象，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                把ref当前所处节点(c)挂在了实例自身上，并命名为inp1 */&lt;/span&gt;}
                &amp;lt;input ref={c =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.inp1 = c} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
                &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
    }
    showData = () =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//const { inp1 } = this.refs不用从refs中取了，从实例自身取即可
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { inp1 } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        alert(inp1.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;233-回调形式ref调用次数的问题&#34;&gt;2.3.3 回调形式ref调用次数的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;初始化时，ref的回调会执行一次。但是当更新组件时，ref的回调会执行两次，分别返回null和currentNode，因为每次渲染时都会创建一个新的函数实例，所以React清空旧的ref并设置新的。&lt;/li&gt;
&lt;li&gt;可以定义成class的绑定函数的方法来解决，但一般就用内联就可以了，多此一举。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt; }
    &lt;span style=&#34;color:#228b22&#34;&gt;//不用管它 只是为了更新组件方便些
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeWeather = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ isHot: !isHot })
    }
    showData = () =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//const { inp1 } = this.refs不用从refs中取了，从实例自身取即可
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { inp1 } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        alert(inp1.value)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//只是将将内联形式提取出来而已，可以解决此问题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    saveRef = (c) =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.inp2 = c&lt;span style=&#34;color:#228b22&#34;&gt;//将传入的c节点挂载到实例对象上，命名为inp2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@@&amp;#34;&lt;/span&gt;, c);
    }
    showData2 = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { inp2 } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        alert(inp2.value)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
            &amp;lt;h2&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;单击切换天气&amp;lt;&lt;span style=&#34;color:#1c7e71&#34;&gt;/button&amp;gt;&amp;lt;br /&lt;/span&gt;&amp;gt;
            {&lt;span style=&#34;color:#228b22&#34;&gt;/*初始化时，ref的回调会执行一次
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            但是当更新组件时，ref的回调会执行两次，分别返回null和currentNode，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            因为每次渲染时都会创建一个新的函数实例，所以React清空旧的ref并设置新的*/&lt;/span&gt;}

            {&lt;span style=&#34;color:#228b22&#34;&gt;/*传统内联回调形式*/&lt;/span&gt;}
            &amp;lt;input ref={c =&amp;gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.inp1 = c, console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@&amp;#34;&lt;/span&gt;, c); }} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;

            {&lt;span style=&#34;color:#228b22&#34;&gt;/*可以定义成class的绑定函数的方法来解决 但一般就用内联就可以了 多此一举*/&lt;/span&gt;}
            &amp;lt;input type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveRef} /&amp;gt;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
    	)	
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;234-createref&#34;&gt;2.3.4 createRef&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;React.createRef()调用后，返回一个容器，该容器可以存储被ref所标识的节点&lt;/li&gt;
&lt;li&gt;一个容器只能存一个节点&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    React.createRef()调用后，返回一个容器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    该容器可以存储被ref所标识的节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    一个容器只能存一个节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    */&lt;/span&gt;
    myRef1 = React.createRef()
    myRef2 = React.createRef()
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
                &amp;lt;input ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
                &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;input ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef2} onBlur={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;/&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
    }
    showData = () =&amp;gt; {
    	alert(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1.current.value)
    }
    showData2 = ()=&amp;gt;{
    	alert(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef2.current.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;235-事件处理&#34;&gt;2.3.5 事件处理&lt;/h3&gt;
&lt;p&gt;1.通过onXxx属性指定事件处理函数（注意大小写）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React使用的是自定义事件，而不是原生DOM事件——为了更好的兼容性&lt;/li&gt;
&lt;li&gt;React中的事件是通过事件委托方式处理的（委托给组件最外层的元素）——为了高效率&lt;/li&gt;
&lt;li&gt;事件委托的原理是事件冒泡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.通过event.target（发生事件的事件源）得到发生事件的DOM元素对象——不要过度使用ref&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当发生事件的元素正好是我们要操作的元素，就可以省略ref，例如下面的失去焦点事件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//创建ref容器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    myRef1 = React.createRef()
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
            &amp;lt;input ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;input onBlur={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;
        	&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
    	)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//展示左侧输入框的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    showData = () =&amp;gt; {
        alert(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1.current.value)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//展示右侧输入框的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//react在调用这个回调的同时会传入event事件对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    showData2 = (e) =&amp;gt; {
        alert(event.target.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;3-react收集表单数据&#34;&gt;3 React收集表单数据&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;需求: 定义一个包含表单的组件&lt;/p&gt;
&lt;p&gt;输入用户名密码后，点击登录提示输入信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;31-非受控组件&#34;&gt;3.1 非受控组件&lt;/h2&gt;
&lt;p&gt;输入类型的DOM（表单），对其值现用现取（username.value）的组件，称其为非受控组件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    handleSubmit = () =&amp;gt; {
        event.preventDefault()&lt;span style=&#34;color:#228b22&#34;&gt;//阻止表单的默认提交动作
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;{username,password} = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        &lt;span style=&#34;color:#228b22&#34;&gt;// alert(username)是错误的，因为挂载到实例自身的是username节点，表示的是用户名输入框这个节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 所以要通过.value显示其值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        alert(&lt;span style=&#34;color:#cd5555&#34;&gt;`username:&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;username.value&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;,password:&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;password.value&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;form action=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.atguigu.com&amp;#34;&lt;/span&gt; onSubmit={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.handleSubmit}&amp;gt;
                用户名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input ref={c =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.username = c} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; /&amp;gt;
                密码&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input ref={c =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.password = c} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/form&amp;gt;&lt;/span&gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;32-受控组件&#34;&gt;3.2 受控组件&lt;/h2&gt;
&lt;p&gt;页面中所有输入类的dom，随着我们的输入，就能把数据维护到状态中，需要用时直接在状态中取出即可&lt;/p&gt;
&lt;p&gt;即实现&lt;strong&gt;双向数据绑定&lt;/strong&gt;的组件称之为受控组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Login extends React.Component {
	//初始化状态
    state = {
        username:&amp;quot;&amp;quot;,
        password:&amp;quot;&amp;quot;
    }
    //保存用户名到状态中
    saveUsername = (event) =&amp;gt; {
    	this.setState({ username: event.target.value })
    }
    //保存密码到状态中
    savePassword = (event) =&amp;gt; {
    	this.setState({ password: event.target.value })
    }
    //表单提交的回调
    handleSubmit = () =&amp;gt; {
    	event.preventDefault()
    	const { username, password } = this.state
    	alert(`username=${username},password=${password}`)
    }
    //页面中所有输入类的dom，随着我们的输入，就能把数据维护到状态中，需要用时直接在状态中取出即可
    //即双向数据绑定
    render() {
        return (
            &amp;lt;form action=&amp;quot;http://www.atguigu.com&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
                用户名：&amp;lt;input onChange={this.saveUsername} type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;
                密码：&amp;lt;input onChange={this.savePassword} type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, document.getElementById(&#39;test&#39;))
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&#34;4-高阶函数以及函数柯里化&#34;&gt;4 高阶函数以及函数柯里化&lt;/h1&gt;
&lt;p&gt;上文中的方法过于冗杂，不适于输入项较多的表单&lt;/p&gt;
&lt;p&gt;可以只写一个函数，通过表单项&lt;strong&gt;回调函数的参数&lt;/strong&gt;来界定保存的数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    state = {
        username: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
        password: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//保存表单数据到状态中
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    saveFormData = (dataType) =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//当我们给onchange事件的回调函数加上括号，实际表示将其返回值作为onchange事件的回调了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//因此我们索性将此回调函数的返回值写作一个新回调函数，作为onchange事件真正的回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; () =&amp;gt; {
            &lt;span style=&#34;color:#228b22&#34;&gt;//dataType需要加中括号，因为{}对象中左侧的默认是字符串类型，加不加引号都属于字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ [dataType]: event.target.value })
        }
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//表单提交的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    handleSubmit = () =&amp;gt; {
        event.preventDefault()
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { username, password } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        alert(&lt;span style=&#34;color:#cd5555&#34;&gt;`username=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;username&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;,password=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;password&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;form action=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.atguigu.com&amp;#34;&lt;/span&gt; onSubmit={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.handleSubmit}&amp;gt;
                用户名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;username&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; /&amp;gt;
                密码&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/form&amp;gt;&lt;/span&gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;41-高阶函数与函数柯里化的定义&#34;&gt;4.1 高阶函数与函数柯里化的定义&lt;/h2&gt;
&lt;p&gt;1.高阶函数：如果一个函数符合下面规范中的任何一个，那该函数就是高阶函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若A函数，接受的参数是一个函数，那么A就称为高阶函数&lt;/li&gt;
&lt;li&gt;若A函数，调用的返回值依然是一个函数，那么A就称为高阶函数&lt;/li&gt;
&lt;li&gt;常见的高阶函数有：Promise、setTimeout、arr.map&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.函数的柯里化：通过函数调用继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式&lt;/p&gt;
&lt;h2 id=&#34;42-不使用柯里化的写法&#34;&gt;4.2 不使用柯里化的写法&lt;/h2&gt;
&lt;p&gt;直接将返回值中的回调函数写成内联的形式，并传出event对象.&lt;/p&gt;
&lt;p&gt;柯里化的核心点在于，事件的回调必须是一个函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    state = {
        username: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
        password: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//保存表单数据到状态中
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    saveFormData = (dataType) =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//当我们给onchange事件的回调函数加上括号，实际表示将其返回值作为onchange事件的回调了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//因此我们索性将此回调函数的返回值写作一个新回调函数，作为onchange事件真正的回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; () =&amp;gt; {
            &lt;span style=&#34;color:#228b22&#34;&gt;//dataType需要加中括号，因为{}对象中左侧的默认是字符串类型，加不加引号都属于字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ [dataType]: event.target.value })
        }
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//表单提交的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    handleSubmit = () =&amp;gt; {
        event.preventDefault()
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { username, password } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        alert(&lt;span style=&#34;color:#cd5555&#34;&gt;`username=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;username&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;,password=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;password&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;form action=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.atguigu.com&amp;#34;&lt;/span&gt; onSubmit={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.handleSubmit}&amp;gt;
                用户名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;username&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; /&amp;gt;
                密码&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/form&amp;gt;&lt;/span&gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;补充&#34;&gt;补充：&lt;/h1&gt;
&lt;h2 id=&#34;1-类的基本知识&#34;&gt;1 类的基本知识&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类中的构造器不是必须写的，如果要对实例进行一些初始化的操作，如添加指定属性时再写&lt;/li&gt;
&lt;li&gt;若A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须调用的&lt;/li&gt;
&lt;li&gt;类中所定义的方法，都是放在类的原型对象上，供实例去使用&lt;/li&gt;
&lt;li&gt;类中允许直接写赋值语句&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//创建一个Person类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Person {
    &lt;span style=&#34;color:#228b22&#34;&gt;//构造器方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    constructor(name, age) {
        &lt;span style=&#34;color:#228b22&#34;&gt;//构造器中的this指向实例对象，因为在new的时候实际上是实例对象调用的构造器方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age = age
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//一般方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    speak() {
        console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;`我叫&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;，我今年&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;岁了`&lt;/span&gt;);
        &lt;span style=&#34;color:#228b22&#34;&gt;//speak方法写在类的的原型对象上，供实例使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//实例在调用自身不存在的方法时，会自动去原型链上找
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//通过Person的实例调用speak方法时，speak中的this就是person实例
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//具体情况需要看是谁调用的，call bind apply都可以改变this的指向
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;//创建一个Person的实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; p1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Person(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;25&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; p2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Person(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;zs&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;26&lt;/span&gt;)
console.log(p1);
console.log(p2);
p1.speak()
p2.speak()

&lt;span style=&#34;color:#228b22&#34;&gt;//创建一个Student类，继承于Person类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Student &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Person {
	constructor(name, age, grade) {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(name, age)&lt;span style=&#34;color:#228b22&#34;&gt;//必须调用super，且必须写在第一句
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.grade = grade
	}
	&lt;span style=&#34;color:#228b22&#34;&gt;//方法的重写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	speak() {
		console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;`我叫&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;，我今年&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;岁，今年上&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.grade&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;);
	}
	study() {
		console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;正在学习&amp;#34;&lt;/span&gt;);
	}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; s1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Student(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;26&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;研三&amp;#34;&lt;/span&gt;)
s1.speak()
s1.study()
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;总结：
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;1.类中的构造器不是必须写的，如果要对实例进行一些初始化的操作，如添加指定属性时再写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;2.若A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须调用的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;3.类中所定义的方法，都是放在类的原型对象上，供实例去使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;

&lt;span style=&#34;color:#228b22&#34;&gt;//另，类中允许直接写赋值语句，应用如下
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Car {
    constructor(name, price) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.price = price
	}
	a = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
	wheels = &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//类中允许直接写赋值语句，此属性会给每个实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//若要给类的原型对象自身加属性，用static关键字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; b = &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
	fn1() {
	&lt;span style=&#34;color:#228b22&#34;&gt;//这是放在类的原型对象上的方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
	fn2 = () =&amp;gt; {
	&lt;span style=&#34;color:#228b22&#34;&gt;//这是放在类的实例对象上的方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; c1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Car(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;benz&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;10000&lt;/span&gt;)
console.log(c1);&lt;span style=&#34;color:#228b22&#34;&gt;//可以利用此特性，简化react中state的编写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(Car.b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-原生事件绑定&#34;&gt;2 原生事件绑定&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;addEventListener（事件监听器）&lt;/li&gt;
&lt;li&gt;onclick（js动态绑定）&lt;/li&gt;
&lt;li&gt;直接在标签上绑定（行内绑定）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&amp;lt;button id=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;btn1&amp;#34;&lt;/span&gt;&amp;gt;按钮1&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
&amp;lt;button id=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;btn2&amp;#34;&lt;/span&gt;&amp;gt;按钮2&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
&amp;lt;button onclick=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demo()&amp;#34;&lt;/span&gt;&amp;gt;按钮3&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
&amp;lt;script&amp;gt;
    &lt;span style=&#34;color:#228b22&#34;&gt;//方式1，addEventListener（事件监听器）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; btn1 = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;btn1&amp;#39;&lt;/span&gt;)
	btn1.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;,()=&amp;gt;{
    	alert(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;按钮1被点击了&amp;#39;&lt;/span&gt;)
	})
	&lt;span style=&#34;color:#228b22&#34;&gt;//方式2，onclick（js动态绑定）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; btn2 = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;btn2&amp;#39;&lt;/span&gt;)
	btn2.onclick = ()=&amp;gt;{
    	alert(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;按钮2被点击了&amp;#39;&lt;/span&gt;)
	}
	&lt;span style=&#34;color:#228b22&#34;&gt;//方式3，直接在标签上绑定（行内绑定）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; demo(){
    	alert(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;按钮3被点击了&amp;#39;&lt;/span&gt;)
	}
	&lt;span style=&#34;color:#228b22&#34;&gt;//react推荐使用方法3
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-类中方法的this指向&#34;&gt;3 类中方法的this指向&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Student{
    constructor(name,age){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age = age
	}
    study(){&lt;span style=&#34;color:#228b22&#34;&gt;//study方法在Student类的原型对象上，供实例对象使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//这里的this指向Student实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; s1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Student(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;)
s1.study()&lt;span style=&#34;color:#228b22&#34;&gt;//通过实例调用原型对象上的study方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; x = s1.study&lt;span style=&#34;color:#228b22&#34;&gt;//将study方法赋值给了x
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;x()&lt;span style=&#34;color:#228b22&#34;&gt;//undefined，因为这属于直接调用study方法，由于类中默认开启严格模式，所以是undefined（不然应该是window对象）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//关于局部开启严格模式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; demo1(){
	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//this指向window对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
demo1()

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; demo2(){
	&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//局部开启严格模式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//此时是undefined，因为严格模型不让this指向window
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
demo2()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-展开运算符的用法&#34;&gt;4 展开运算符的用法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;展开一个数组&lt;/li&gt;
&lt;li&gt;数组的拼接&lt;/li&gt;
&lt;li&gt;函数传参（批量传入参数）&lt;/li&gt;
&lt;li&gt;复制对象（深复制）&lt;/li&gt;
&lt;li&gt;复制一个对象的同时修改器属性&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr1 = [&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;]    
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr2 = [&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;]    

&lt;span style=&#34;color:#228b22&#34;&gt;//1.展开一个数组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(arr1)&lt;span style=&#34;color:#228b22&#34;&gt;//[1,3,5,7,9]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(...arr1)&lt;span style=&#34;color:#228b22&#34;&gt;//1 3 5 7 9
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//2.数组的拼接
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(...[...arr1,...arr2])&lt;span style=&#34;color:#228b22&#34;&gt;//展开拼接后的数组1 3 5 7 9 2 4 6 8 10
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//3.函数传参，批量传入参数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//需求：数组求和
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; sum(...numbers) {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; numbers.reduce((preValue,currentValue) =&amp;gt; {&lt;span style=&#34;color:#228b22&#34;&gt;//这是数组中非常重要的一个方法reduce
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; preValue + currentValue
	})
}
console.log(sum(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;));&lt;span style=&#34;color:#228b22&#34;&gt;//10
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//4.复制对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; p1 = {name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt;,age:&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;}
&lt;span style=&#34;color:#228b22&#34;&gt;//console.log(...p1);//报错，因为在原生js中，展开运算符不可以展开对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//但如果在外面包上一层展开运算符，就可以克隆一个对象（深复制），
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; p2 = {...p1}
p1.name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;zs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//更改p1的值，p2并不会受影响
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(p2,p1);

&lt;span style=&#34;color:#228b22&#34;&gt;//5.复制一个对象的同时修改其属性
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//实质上是两个对象的合并
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; p3 = {...p1,name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsqzs&amp;#39;&lt;/span&gt;}
console.log(p3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5 对象相关知识&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; a = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; obj = {} &lt;span style=&#34;color:#228b22&#34;&gt;//需求是将其变成{name:&amp;#39;tom&amp;#39;}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 不可直接obj.a = &amp;#34;tom&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;obj[a] = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tom&amp;#34;&lt;/span&gt;
console.log(obj)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6 显示函数柯里化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//正常写法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; sum(a, b, c) {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a + b + c
}
console.log(sum(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;));

&lt;span style=&#34;color:#228b22&#34;&gt;//函数柯里化写法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; sum2(a) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (b) =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (c) =&amp;gt; {
        	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a + b + c
        }
    }
}
console.log(sum2(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)(&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gsemir0418.github.io/posts/react%E5%9F%BA%E7%A1%80/ - </description>
        </item>
    
    
    
        <item>
        <title>展示平台说明文档</title>
        <link>https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 08 Jan 2021 23:15:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/ -&lt;h1 id=&#34;1-模型展示页面&#34;&gt;1. 模型展示页面&lt;/h1&gt;
&lt;p&gt;​		模型展示页面是基于There.js库、模型和材质加载器以及控制器，实现模型在web端的简单展示。具体实现逻辑已写好，用户只需修改obj模型路径等简单操作即可实现模型展示demo。obj模型导出及注意事项见&lt;code&gt;3dsMax技术文档&lt;/code&gt;。模板已发布到GitHub供读者学习参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GSemir0418/TemplateProjects&#34;&gt;https://github.com/GSemir0418/TemplateProjects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		下图为项目目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210108184425370.png&#34; alt=&#34;image-20210108184425370&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		其中，js文件夹包含全部Javascript脚本文件，models文件夹用来存储obj模型，index.html是项目的主页。&lt;/p&gt;
&lt;p&gt;​		js文件夹中，除index.js外，均是由Three.js为我们提供的模型加载器和控制器脚本文件。而页面的主要逻辑全部封装到了index.js中。&lt;/p&gt;
&lt;h2 id=&#34;11-更改网页名称&#34;&gt;1.1 更改网页名称&lt;/h2&gt;
&lt;p&gt;​		在index.html文件中，修改&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签内的内容即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;XXX村寨模型展示&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;12-修改模型路径&#34;&gt;1.2 修改模型路径&lt;/h2&gt;
&lt;p&gt;​		首先将obj模型拷贝至models文件夹下。&lt;/p&gt;
&lt;p&gt;​		在js/index.js文件中，修改15和16行的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//模型路径
let mat1 = &#39;./models/testobj/lancuiting.mtl&#39;;
let obj1 = &#39;./models/testobj/lancuiting.obj&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		注意路径使用&lt;strong&gt;相对路径&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;13-控制模型体积&#34;&gt;1.3 控制模型体积&lt;/h2&gt;
&lt;p&gt;​		js/index.js文件中，修改51行代码中的参数即可，注意三个数字应保持一致：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;model1.scale.set(1.4, 1.4, 1.4);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;14-其他可配置选项&#34;&gt;1.4 其他可配置选项&lt;/h2&gt;
&lt;p&gt;​		如需修改灯光位置及强度，可以修改js/index.js文件中46和47行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//括号中的2为强度
let dLight = new THREE.DirectionalLight(0xFFFFFF, 2);
//光源的位置
dLight.position.set(500, 1000, 4000);
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&#34;2-turnjs翻页特效&#34;&gt;2. Turn.js翻页特效&lt;/h1&gt;
&lt;p&gt;​		展示平台的第一个模块是&lt;strong&gt;少数民族建筑特征分析&lt;/strong&gt;。针对大量的图文资料，传统的页面布局得不到很好的展示与交互效果。为提高用户体验，选择类似书本翻页的形式作为展示图文视频资料的方式。Turn.js是一个JavaScript库，利用HTML5的所有优点，可以使内容呈现起来像一本真正的书或杂志。&lt;/p&gt;
&lt;p&gt;​		关于Turn.js的入门教程可以看siki学院的免费课程，也可以通过官网进行学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;siki学院：http://www.sikiedu.com/course/517/tasks&lt;/p&gt;
&lt;p&gt;Turn.js官网：http://www.turnjs.com/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		由于少数民族建筑资料篇幅较多，文章内容比较复杂，且Turn.js并没有为用户提供书页模板，全部样式都是用户在CSS中定义的。考虑到书页制作的便捷性与美观性，选择PPT来制作展示书籍的内容，再以加载图片的方式将内容加载到网页端，实现具有翻页效果的少数民族建筑特征分析资料展示模块。&lt;/p&gt;
&lt;p&gt;整个模块的制作流程主要分两部分，&lt;strong&gt;图文内容的准备工作&lt;/strong&gt;与&lt;strong&gt;翻页效果的实现&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;21-图文内容的准备工作&#34;&gt;2.1 图文内容的准备工作&lt;/h2&gt;
&lt;p&gt;​		PPT模板及主要实现代码已与平台源代码一同发布至GIthub供大家学习参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GSemir0418/TemplateProjects&#34;&gt;https://github.com/GSemir0418/TemplateProjects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		模板的样式已经设计制作完成，包括封面的设计、内容的布局和字体的选择。也可以根据自己的审美，重新设计排版布局。注意页面设计中的方向要保证是纵向，具体尺寸取决于Turn.js中定义的宽和高。参考配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210109193919127.png&#34; alt=&#34;image-20210109193919127&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		将撰写好的少数民族建筑特征分析图文资料复制到PPT模板中，进行排版布局后，完成图文内容的准备工作。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		点击右上角&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;另存为&lt;/code&gt;，设置导出路径后，考虑到网页端的加载效率，文件类型选择较小的&lt;code&gt;.jpg&lt;/code&gt;。单击&lt;code&gt;保存&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出的提示框中，选择&lt;code&gt;每张幻灯片&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210109203901828.png&#34; alt=&#34;image-20210109203901828&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		导出完成后如下图。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		为了加载图片的代码编写的简洁性，需要批量修改每张图片的名字。网上有很多批量修改文件名的方法，这里选择一款解压缩软件&lt;code&gt;好压&lt;/code&gt;内置的&lt;code&gt;批量文件改名&lt;/code&gt;功能，可以在&lt;code&gt;开始&lt;/code&gt;菜单中找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210109204553287.png&#34; alt=&#34;image-20210109204553287&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		首先根据提示，批量&lt;code&gt;添加&lt;/code&gt;所有图片文件；在命名规则中填入&lt;code&gt;#&lt;/code&gt;。单击&lt;code&gt;开始重命名&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		至此，完成翻页效果的素材准备工作。&lt;/p&gt;
&lt;h2 id=&#34;22-翻页效果的实现&#34;&gt;2.2 翻页效果的实现&lt;/h2&gt;
&lt;p&gt;​		将图片文件夹重命名为英文名称，例如miao_img，将其拷贝到/ADP/turn_img路径下。批量加载的代码已写好，需要调整page/miao_turn_page.html中的几行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//line 47 修改路径&amp;quot;turn_img/miao_img&amp;quot;
&amp;quot;&amp;lt;img src=\&amp;quot;../turn_img/miao_img/&amp;quot; + i + &amp;quot;.jpg\&amp;quot; alt=\&amp;quot; \&amp;quot; width=\&amp;quot;525\&amp;quot; height=\&amp;quot;700\&amp;quot;&amp;gt;\n&amp;quot; +

//line 100 修改路径&amp;quot;turn_img/miao_img&amp;quot;
&amp;lt;img src=&amp;quot;../turn_img/miao_img/1.jpg&amp;quot; alt=&amp;quot; &amp;quot; width=&amp;quot;525&amp;quot; height=&amp;quot;700&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		加载完成后，根据实际页码，调整目录页数及跳转按钮的页码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//line 89-91 pageTo(修改这里面的数字)
&amp;lt;a href=&amp;quot;javascript:pageTo(1)&amp;quot; class=&amp;quot;btn btn-secondary&amp;quot; role=&amp;quot;button&amp;quot;&amp;gt;封面&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;javascript:pageTo(2)&amp;quot; class=&amp;quot;btn btn-secondary&amp;quot; role=&amp;quot;button&amp;quot;&amp;gt;目录&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;javascript:pageTo(72)&amp;quot; class=&amp;quot;btn btn-secondary&amp;quot; role=&amp;quot;button&amp;quot;&amp;gt;封底&amp;lt;/a&amp;gt;

//line 112-119 pageTo(修改这里面的数字) 修改目录文字内容
&amp;lt;div class=&amp;quot;list-group&amp;quot; style=&amp;quot;left: 50%&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:pageTo(4)&amp;quot;
    class=&amp;quot;list-group-item list-group-item-action&amp;quot;&amp;gt;1.村寨概述-1&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:pageTo(40)&amp;quot;
    class=&amp;quot;list-group-item list-group-item-action&amp;quot;&amp;gt;2.村落及居住建筑分析-37&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:pageTo(56)&amp;quot;
    class=&amp;quot;list-group-item list-group-item-action&amp;quot;&amp;gt;3.建筑遗传特征-53&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		完成翻书效果展示少数民族建筑特征模块的制作。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3建筑展示平台&#34;&gt;3.建筑展示平台&lt;/h1&gt;
&lt;p&gt;​		展示平台的第二部分是&lt;strong&gt;建筑结构体系展示部分&lt;/strong&gt;，也是平台的核心部分。包括模型爆炸、构件动态拆分以及模型剖切三大功能模块。由于具体实现逻辑已封装完毕，只需修改模板中的几行代码即可。模板下载链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GSemir0418/TemplateProjects&#34;&gt;https://github.com/GSemir0418/TemplateProjects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;31-自定义主页样式&#34;&gt;3.1 自定义主页样式&lt;/h2&gt;
&lt;p&gt;​		模板中的主页样式如下图：&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		文字部分及插图内容均可自定义，具体替换位置在根目录下的index.html中很明显，这里不再赘述。值得一提的是背景图片的修改路径，需要修改index_assets/css/main.css文件的1627行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-image: linear-gradient(to top, rgba(46, 49, 65, 0.8), rgba(46, 49, 65, 0.8)), url(&amp;quot;../../index_images/bg.jpg&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;32-替换obj模型&#34;&gt;3.2 替换obj模型&lt;/h2&gt;
&lt;p&gt;​		首先将obj模型及DAE模型拷贝至models文件夹下。&lt;/p&gt;
&lt;p&gt;​		在js/miao_model1.js以及js/miao_model2.js文件中，修改变量mat1和obj1的值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//模型路径
let mat1 = &#39;../models/testModel/objTest/objTest.mtl&#39;;
let obj1 = &#39;../models/testModel/objTest/objTest.obj&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		注意路径使用&lt;strong&gt;相对路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		模型剖切模块使用DAE格式的模型文件，在js/miao_simulation.js文件中，修改第28行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;loader.load( &#39;../models/testModel/DAETest/DAEtest.DAE&#39;, function ( collada ) {
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;33-其他可配置选项&#34;&gt;3.3 其他可配置选项&lt;/h3&gt;
&lt;p&gt;​		可参考本文第一章节中的部分内容。&lt;/p&gt;
- https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/ - </description>
        </item>
    
    
    
        <item>
        <title>3dsMax技术文档</title>
        <link>https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 08 Jan 2021 16:41:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ -&lt;h1 id=&#34;1-3dsmax概述&#34;&gt;1. 3dsMax概述&lt;/h1&gt;
&lt;p&gt;​		3dsMax是由&lt;code&gt;AutoDesk&lt;/code&gt;公司开发的&lt;strong&gt;三维模型与动画制作渲染软件&lt;/strong&gt;，它被广泛应用于多个领域，包括游戏设计、广告设计、建筑设计和影视制作等。其&lt;strong&gt;优点&lt;/strong&gt;是具有强大的材质编辑和灯光处理功能，并且相关的学习资源非常丰富。在后期的模型渲染上功能强大，能够得到逼真的模型。同其他建模软件相比，3dsMax创建的模型面片数量较少，占用空间小，模型的处理速度也比较快。本课题正是应用其强大的模型兼容性以及材质编辑功能，作为单体建筑模型&lt;strong&gt;后期纹理映射&lt;/strong&gt;和&lt;strong&gt;OBJ模型导出&lt;/strong&gt;的重要软件。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-3dsmax软件安装&#34;&gt;2. 3dsMax软件安装&lt;/h1&gt;
&lt;p&gt;​		3dsMax软件发展至今，从最初的3D Studio MAX 1.0开始，其版本迭代更新二十余次，截至文章发布前，Autodesk公司已推出3dsMax 2021。考虑到兼容性、稳定性等问题，推荐安装&lt;code&gt;3dsMax 2016&lt;/code&gt;之后的版本。&lt;/p&gt;
&lt;p&gt;​		本章以&lt;code&gt;3dsMax 2020&lt;/code&gt;软件安装为例，详细介绍软件安装的过程及注意事项。&lt;/p&gt;
&lt;h2 id=&#34;21-解压缩安装包&#34;&gt;2.1 解压缩安装包&lt;/h2&gt;
&lt;p&gt;​		将安装包及注册机文件解压缩至目标文件夹，注意&lt;strong&gt;目标文件夹名称及路径应保证全英文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		为防止安装破解过程中出现未知错误，建议&lt;strong&gt;安装前关闭所有杀毒软件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;22-安装软件&#34;&gt;2.2 安装软件&lt;/h2&gt;
&lt;p&gt;​		进入安装包文件夹，右键单击&lt;code&gt;Setup.exe&lt;/code&gt;，选择以管理员身份运行；&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;在打开的窗口中选择&lt;code&gt;安装（在此计算机安装）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;许可协议选择&lt;code&gt;我接受&lt;/code&gt;，单击&lt;code&gt;下一步&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;设置安装路径后，点击安装即可。&lt;strong&gt;注意路径仍要保证全英文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，选择&lt;code&gt;立即启动&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-破解软件&#34;&gt;2.3 破解软件&lt;/h2&gt;
&lt;p&gt;​		第一次进入软件后，选择&lt;code&gt;enter a serial number&lt;/code&gt;输入序列号。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		选择 &lt;code&gt;I Agree&lt;/code&gt;我同意。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		进入激活页面，选择&lt;code&gt;Activate&lt;/code&gt;激活。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在&lt;code&gt;Serial Number&lt;/code&gt;栏中填写序列号&lt;code&gt;666-69696969&lt;/code&gt;，单击&lt;code&gt;Next&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		第一次会提醒”检测到无效的序列号“，此时选择&lt;code&gt;重新输入&lt;/code&gt;，将序列号再次输入即可。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		当进入到激活选项窗口，复制&lt;code&gt;Request code&lt;/code&gt;请求码。右键单击安装包中的&lt;code&gt;xf-adesk20.exe&lt;/code&gt;破解工具，选择以管理员身份运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103222250253.png&#34; alt=&#34;image-20210103222250253&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		将请求码复制到破解工具中的&lt;code&gt;Request&lt;/code&gt;栏后，先单击&lt;code&gt;Patch&lt;/code&gt;，再点击&lt;code&gt;Generate&lt;/code&gt;，复制Activation栏中自动生成的激活码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103222411949.png&#34; alt=&#34;image-20210103222411949&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		拿到激活码后，回到激活选项页面，选择&lt;code&gt;I have an activation code from Autodesk&lt;/code&gt;，把激活码复制到输入框后，点击&lt;code&gt;Next&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103222438931.png&#34; alt=&#34;image-20210103222438931&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		激活完成，选择&lt;code&gt;Finish&lt;/code&gt;退出激活窗口。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		至此，3dsMax 2020安装完成。&lt;/p&gt;
&lt;h2 id=&#34;24-修改软件语言&#34;&gt;2.4 修改软件语言&lt;/h2&gt;
&lt;p&gt;​		3dsMax软件支持简体中文，切换中文版本也很简单，点击&lt;code&gt;开始&lt;/code&gt;，找到&lt;code&gt;Autodesk&lt;/code&gt;文件夹，选择&lt;code&gt;3dMax 2020 - simplified Chinese&lt;/code&gt;即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3-fbx模型导入&#34;&gt;3. FBX模型导入&lt;/h1&gt;
&lt;p&gt;​		导入FBX模型到3dmax有两种方法供大家参考。&lt;/p&gt;
&lt;h2 id=&#34;31-拖拽导入&#34;&gt;3.1 拖拽导入&lt;/h2&gt;
&lt;p&gt;​		直接将模型文件拖至任意视图窗口后，在弹出的选项中选择“导入文件”；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103224446456.png&#34; alt=&#34;image-20210103224446456&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-选项导入&#34;&gt;3.2 选项导入&lt;/h2&gt;
&lt;p&gt;​		单击菜单栏&lt;code&gt;文件&lt;/code&gt;选项，选择&lt;code&gt;导入&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在随后弹出来的导入选项中，&lt;strong&gt;注意将“动画”、“摄像机”及“灯光”选项取消勾选。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		导入后效果如下图，此时每个构件都没有贴图，修改器属性均为“可编辑网格”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103224800108.png&#34; alt=&#34;image-20210103224800108&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;4-模型预处理&#34;&gt;4. 模型预处理&lt;/h1&gt;
&lt;p&gt;​		正式贴图前，需要对模型进行初步处理，包括&lt;strong&gt;优化模型体量&lt;/strong&gt;以及构件分类命名，以提高后期平台开发过程中的显示性能，为展示功能的实现做准备。&lt;/p&gt;
&lt;h2 id=&#34;41-模型优化&#34;&gt;4.1 模型优化&lt;/h2&gt;
&lt;p&gt;​		模型优化主要是针对模型数量及面片数量较大的部分，以瓦片屋顶为例。由于瓦片模型数量多，面片数大，不方便后期的贴图及模型处理，因此首先选中一侧屋顶，在命令面板中选择&lt;code&gt;实用工具&lt;/code&gt;，依次点击&lt;code&gt;塌陷&lt;/code&gt;、&lt;code&gt;塌陷选定模型&lt;/code&gt;，使一侧的屋顶塌陷融合成一个整体。另外一侧屋顶可以以复制旋转的方式替代镜像的操作。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-构件分类命名&#34;&gt;4.2 构件分类命名&lt;/h2&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		在revit建模过程中，对于每个族构件模型都进行了命名。由于revit导出的fbx模型，其构件信息包含一些无用字段，因此需要利用3dsMax软件进行构件再次分类命名，为展示平台的构件信息显示功能做准备，从而提升用户体验。&lt;/p&gt;
&lt;p&gt;​		以门板族构件为例，可以根据其相对于建筑的不同方位与材质进行命名，如前部木制门板；&lt;/p&gt;
&lt;p&gt;​		以屋顶为例，可以根据其结构特点结合当地命名习惯进行命名，如椽子、檩条等。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;5-贴图&#34;&gt;5 贴图&lt;/h1&gt;
&lt;h2 id=&#34;51-整理贴图&#34;&gt;5.1 整理贴图&lt;/h2&gt;
&lt;p&gt;​		根据点云数据及现场调研收集到的图像等信息，搜集整理各构件的纹理贴图，注意贴图的&lt;strong&gt;名称不能出现中文&lt;/strong&gt;，考虑到在网上下载的贴图有乱码的情况，因此建议将全部贴图&lt;strong&gt;重命名为拼音字母&lt;/strong&gt;。贴图的&lt;strong&gt;路径最好也不要出现中文&lt;/strong&gt;。正式贴图之前，建议将贴图素材统一整理到模型根目录下的/tietu文件夹中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107104809527.png&#34; alt=&#34;image-20210107104809527&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-贴图步骤&#34;&gt;5.2 贴图步骤&lt;/h2&gt;
&lt;p&gt;​		在3dmax界面下，按&lt;code&gt;M&lt;/code&gt;调出材质编辑器，将贴图素材用鼠标拖放至材质球上即可，贴图与材质球一一对应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105405290.png&#34; alt=&#34;image-20210107105405290&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		随后将附好材质的材质球直接拖至对应的模型构件上。在模型构件命令面板的修改器列表中，选择&lt;code&gt;UVW贴图&lt;/code&gt;（可以提前将此按钮添加到修改器集中，节约查找UVW贴图命令的操作），调整UVW属性中&lt;code&gt;贴图&lt;/code&gt;、&lt;code&gt;长宽高&lt;/code&gt;和&lt;code&gt;UVW向平铺&lt;/code&gt;等相关参数，使效果尽可能接近真实。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105417385.png&#34; alt=&#34;image-20210107105417385&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		贴图过程中要&lt;strong&gt;及时保存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		下图为贴图完成后的效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105428481.png&#34; alt=&#34;image-20210107105428481&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		模型纹理贴图完成后，还需将模型位置调整至中心坐标位置（视窗网格的中心）。可以按&lt;code&gt;G&lt;/code&gt;显示或者隐藏视窗网格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105443894.png&#34; alt=&#34;image-20210107105443894&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105450400.png&#34; alt=&#34;image-20210107105450400&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;6-模型归档和导出&#34;&gt;6 模型归档和导出&lt;/h1&gt;
&lt;h2 id=&#34;61-模型归档&#34;&gt;6.1 模型归档&lt;/h2&gt;
&lt;p&gt;​		&lt;strong&gt;归档&lt;/strong&gt;，就是将当前场景中的模型文件、材质贴图及贴图路径整理出来，另存成为一个压缩包，方便模型的存储和传输。归档操作很简单，菜单栏中选择&lt;code&gt;文件&lt;/code&gt;→&lt;code&gt;归档&lt;/code&gt;即可；老版本（2017及之前）点击左上角图标→&lt;code&gt;另存为&lt;/code&gt;→&lt;code&gt;归档&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105534632.png&#34; alt=&#34;image-20210107105534632&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		归档的模型解压缩并打开后，在3dsMax中浏览虽然是没有问题的，但在导出obj模型前，还需&lt;strong&gt;修改模型的路径&lt;/strong&gt;，否则导出的obj模型会出现材质丢失的情况。为避免这种情况产生，建议在完成模型贴图后，直接在本机导出所需的其他格式模型；若要对原模型进行存储或传输，需要归档后在另外的机器导出模型时，就要对模型的贴图路径进行重定向。&lt;/p&gt;
&lt;p&gt;​		在右侧命令面板中，选择&lt;code&gt;实用工具&lt;/code&gt;选项（扳手的图标），点击&lt;code&gt;更多...&lt;/code&gt;选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107200949507.png&#34; alt=&#34;image-20210107200949507&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出来的窗口中选择&lt;code&gt;位图/光度学路径&lt;/code&gt;，点击确定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107201059874.png&#34; alt=&#34;image-20210107201059874&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		随后在右侧命令面板会出现&lt;code&gt;路径编辑器&lt;/code&gt;选项，点击&lt;code&gt;编辑资源&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107201231060.png&#34; alt=&#34;image-20210107201231060&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		此时弹出&lt;code&gt;位图/光度学路径编辑器&lt;/code&gt;窗口，在这里将显示全部的贴图路径信息。点击&lt;code&gt;选择丢失的文件&lt;/code&gt;，我们会看到全部的文件都变为选中状态，说明全部贴图路径均发生了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107201331968.png&#34; alt=&#34;image-20210107201331968&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		点击下方&lt;code&gt;...&lt;/code&gt;按钮，找到解压后模型贴图存放的文件夹，点击&lt;code&gt;使用路径&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		之后点击&lt;code&gt;设置路径&lt;/code&gt;，将原路径修改为正确的路径。可以再次单击&lt;code&gt;选择丢失的文件&lt;/code&gt;，此时已没有文件被选中，说明全部路径已修改完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107202036510.png&#34; alt=&#34;image-20210107202036510&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;62-obj模型导出&#34;&gt;6.2 obj模型导出&lt;/h2&gt;
&lt;p&gt;​		依次点击&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;导出&lt;/code&gt;，配置好导出路径（纯英文）及文件名后，保存类型选择&lt;code&gt;gw::OBJ-Exporter(*.OBJ)&lt;/code&gt;，单击&lt;code&gt;保存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出的窗口中，需要继续配置obj模型导出的参数。面需要改为&lt;code&gt;三角形&lt;/code&gt;，精度改为&lt;code&gt;5&lt;/code&gt;，材质导出选项中，勾选使用材质路径，并修改路径名为&lt;code&gt;./&lt;/code&gt;。配置完成后，点击&lt;code&gt;导出&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107215114429.png&#34; alt=&#34;image-20210107215114429&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		至此，obj模型文件、mtl材质文件以及贴图文件已成功导出。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		由于3dsMax软件中obj模型导出模块的字符集与网页展示平台中的字符集不匹配，导致构件信息显示错误，出现乱码的情况。之前采用的是使用JavaScript数组对象存储模型构件信息，按构件id来匹配显示构件信息，虽然解决了上述问题，但既费时又费力。所以我们选择从根本上解决此问题——修改obj文件的字符集。方法有很多，这里采用&lt;code&gt;notepad++&lt;/code&gt;来处理字符编码的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：https://notepad-plus-plus.org/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		使用&lt;code&gt;notepad++&lt;/code&gt;打开obj文件，单击&lt;code&gt;编码&lt;/code&gt;，选择&lt;code&gt;转为UTF-8编码&lt;/code&gt;后，保存文件即可。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;63-dae模型导出&#34;&gt;6.3 DAE模型导出&lt;/h2&gt;
&lt;p&gt;​		DAE模型主要用于模型剖切模块，无需导出材质。导出步骤与上文相同，依次点击&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;导出&lt;/code&gt;，配置好导出路径（纯英文）及文件名后，保存类型选择&lt;code&gt;Autodesk Collada(*.DAE)&lt;/code&gt;，单击&lt;code&gt;保存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出的导出选项中，将动画、摄像机和灯光取消勾选。单击&lt;code&gt;确定&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107221009764.png&#34; alt=&#34;image-20210107221009764&#34;&gt;&lt;/p&gt;
- https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ - </description>
        </item>
    
    
    
        <item>
        <title>Revit建模技术文档</title>
        <link>https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
        <pubDate>Sun, 03 Jan 2021 16:41:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ -&lt;h1 id=&#34;1-revit概述&#34;&gt;1. Revit概述&lt;/h1&gt;
&lt;h1 id=&#34;2安装软件&#34;&gt;2.安装软件&lt;/h1&gt;
&lt;h1 id=&#34;3点云数据导入&#34;&gt;3.点云数据导入&lt;/h1&gt;
&lt;h2 id=&#34;31-直接导入&#34;&gt;3.1 直接导入&lt;/h2&gt;
&lt;h2 id=&#34;32-recap&#34;&gt;3.2 Recap&lt;/h2&gt;
&lt;h1 id=&#34;4构件族与模型搭建&#34;&gt;4.构件族与模型搭建&lt;/h1&gt;
&lt;h2 id=&#34;41-建模流程概述&#34;&gt;4.1 建模流程概述&lt;/h2&gt;
&lt;h2 id=&#34;42-轴网布局&#34;&gt;4.2 轴网布局&lt;/h2&gt;
&lt;h2 id=&#34;43-木框架搭建&#34;&gt;4.3 木框架搭建&lt;/h2&gt;
&lt;h2 id=&#34;44-屋顶&#34;&gt;4.4 屋顶&lt;/h2&gt;
&lt;h3 id=&#34;441-歇山式屋顶&#34;&gt;4.4.1 歇山式屋顶&lt;/h3&gt;
&lt;h3 id=&#34;442-悬山式屋顶&#34;&gt;4.4.2 悬山式屋顶&lt;/h3&gt;
&lt;h2 id=&#34;45-门板&#34;&gt;4.5 门板&lt;/h2&gt;
&lt;h2 id=&#34;46-其他构件&#34;&gt;4.6 其他构件&lt;/h2&gt;
&lt;h2 id=&#34;47-fbx模型导出&#34;&gt;4.7 FBX模型导出&lt;/h2&gt;
&lt;h1 id=&#34;5绘制施工图纸&#34;&gt;5.绘制施工图纸&lt;/h1&gt;
- https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ - </description>
        </item>
    
    
  </channel>
</rss> 