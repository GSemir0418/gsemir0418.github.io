<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>stream on GSemir Blog</title>
    <link>https://gsemir0418.github.io/tags/stream/</link>
    <description>Recent content in stream on GSemir Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Jul 2021 14:07:04 +0800</lastBuildDate><atom:link href="https://gsemir0418.github.io/tags/stream/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>NodeStream模块</title>
      <link>https://gsemir0418.github.io/posts/nodejsstream%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 08 Jul 2021 14:07:04 +0800</pubDate>
      
      <guid>https://gsemir0418.github.io/posts/nodejsstream%E6%A8%A1%E5%9D%97/</guid>
      <description>1.三个示例引入Stream 1.1 创建流 // 引入fs模块 const fs = require(&amp;#39;fs&amp;#39;) // 利用fs创建流 const stream = fs.createWriteStream(&amp;#39;./big_file.txt&amp;#39;) // 写数据 for (let i = 0; i &amp;lt; 100000; i++) { stream.write(`这是第${i}行内容，我们需要很多很多内容\n`) } // 关闭流 stream.end() console.log(&amp;#39;done&amp;#39;) //命令行执行 node 1.js   分析
 流程：打开流，多次往里面塞内容，关闭流 看起来就是可以多次写，没什么大不了的 最终得到一个100M左右的文件    Stream是水流，但默认没有水
  stream.write可以让水流中有水（数据）
  每次写入的数据片段叫做chunk（块）
  产生数据的一端叫做source
  接收数据的一端叫做sink
  1.2 浏览器直接读取文件 // 引入文件模块 const fs = require(&amp;#39;fs&amp;#39;) // 引入http模块 const http = require(&amp;#39;http&amp;#39;) // 开启服务器 const server = http.</description>
    </item>
    
  </channel>
</rss>
