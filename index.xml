<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GSemir Blog</title>
    <link>https://gsemir0418.github.io/</link>
    <description>Recent content on GSemir Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Jun 2021 22:51:51 +0800</lastBuildDate>
    
        <atom:link href="https://gsemir0418.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>antdpro&#43;umi实战</title>
        <link>https://gsemir0418.github.io/posts/antdpro&#43;umi%E5%AE%9E%E6%88%98/</link>
        <pubDate>Tue, 08 Jun 2021 22:51:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/antdpro&#43;umi%E5%AE%9E%E6%88%98/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/antdpro&#43;umi%E5%AE%9E%E6%88%98/ -&lt;p&gt;本文通过一个todo list 的小项目演示，实现三个功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表功能，列出所以todo项；&lt;/li&gt;
&lt;li&gt;添加新项，添加新的todo项；&lt;/li&gt;
&lt;li&gt;更新项，更新现有的todo项状态，修改成待办、已完成或者取消&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	id : 1, // 唯一标识
	title : &amp;quot;完成antdpro实战&amp;quot;, // 待办事项标题
	status : 0 // 状态：0-待办，1-已完成，2-已取消
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;创建新项目&#34;&gt;创建新项目&lt;/h2&gt;
&lt;p&gt;新建项目目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir todo-list
cd todo-list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yarn create umi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择ant-design-pro、JavaScript、simple，完成项目的创建&lt;/p&gt;
&lt;h2 id=&#34;目录结构&#34;&gt;目录结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;├── config                   # umi 配置，包含路由，构建等配置
├── mock                     # 本地模拟数据
├── public                   # 一些公共静态资源
├── src
│   ├── assets               # 本地静态资源
│   ├── components           # 业务通用组件
│   ├── e2e                  # 集成测试用例
│   ├── layouts              # 通用布局
│   ├── models               # 全局 dva model
│   ├── pages                # 业务页面入口和常用模板
│   ├── services             # 后台接口服务
│   ├── utils                # 工具库
│   ├── locales              # 国际化资源
│   ├── global.less          # 全局样式
│   └── global.jsx            # 全局 JS
├── tests                    # 测试工具
├── README.md
└── package.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，mock、models、pages、services将是我们的主要目录。&lt;/p&gt;
&lt;h2 id=&#34;本地开发&#34;&gt;本地开发&lt;/h2&gt;
&lt;p&gt;安装依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yarn install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yarn start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;浏览器打开http://localhost:8000看到如下界面&lt;/p&gt;
&lt;p&gt;这就是脚手架为我们建好的框架，一个欢迎页面，一个空白的二级页面和一个查询表格，实际开发中我们要删掉这些页面，然后建立自己的业务界面。&lt;/p&gt;
&lt;h3 id=&#34;配置路由&#34;&gt;配置路由&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;... 
routes: [
        {
          path: &#39;/&#39;,
          component: &#39;../layouts/BasicLayout&#39;,
          authority: [&#39;admin&#39;, &#39;user&#39;],
          routes: [
            {
              path: &#39;/&#39;,
              redirect: &#39;/welcome&#39;,
            },
            {
              path: &#39;/todo&#39;,// url中path部分
              name: &#39;todo&#39;, // 名称，国际化菜单配置根据这个名称来配置，如果不配置将直菜单将直接显示这个名称
              icon: &#39;unordered-list&#39;,// 菜单图标名称
              component:&#39;./todo&#39;// 组件（页面）,路径相对于src/pages
            },
           ...
  ],
...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;添加空白页面&#34;&gt;添加空白页面&lt;/h3&gt;
&lt;p&gt;在src/pages下新建目录todo,在todo目录下新建空白index.jsx文件，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;;
import { PageContainer } from &#39;@ant-design/pro-layout&#39;;


class TodoPage extends Component {

    componentWillMount() { }

    render() {
        return (
            &amp;lt;PageHeaderWrapper&amp;gt;
                &amp;lt;div&amp;gt;空白面&amp;lt;/div&amp;gt;
            &amp;lt;/PageHeaderWrapper&amp;gt;);
    }
}

export default TodoPage
&lt;/code&gt;&lt;/pre&gt;- https://gsemir0418.github.io/posts/antdpro&#43;umi%E5%AE%9E%E6%88%98/ - </description>
        </item>
    
    
    
        <item>
        <title>可视化大屏实战</title>
        <link>https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E5%AE%9E%E6%88%98/</link>
        <pubDate>Sun, 09 May 2021 21:27:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E5%AE%9E%E6%88%98/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E5%AE%9E%E6%88%98/ -&lt;h1 id=&#34;1如何找素材&#34;&gt;1.如何找素材&lt;/h1&gt;
&lt;p&gt;1.1 著名的设计网站&lt;/p&gt;
&lt;p&gt;Dribbble（搜索关键字：big screen）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dribbble.com&#34;&gt;https://dribbble.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;站酷（关键字：大屏）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zcool.com.cn&#34;&gt;https://www.zcool.com.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2如何适配屏幕&#34;&gt;2.如何适配屏幕&lt;/h1&gt;
&lt;p&gt;1.整体的屏幕适配&lt;/p&gt;
&lt;p&gt;如果大屏很宽，就左右居中；屏幕很高，就上下居中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gsemir0418.github.io/image-20210510084113259.png&#34; alt=&#34;image-20210510084113259&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中Wp为页面有效宽度，Hp为页面有效高度&lt;/p&gt;
&lt;p&gt;页面左右居中，上下居中，四周留白即可&lt;/p&gt;
&lt;p&gt;然后在head里用JS设置1rem=Wp/100&lt;/p&gt;
&lt;p&gt;2.每个div的适配&lt;/p&gt;
&lt;p&gt;每个div是要适配页面的，因此只能用rem而不是px&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gsemir0418.github.io/image-20210510084513077.png&#34; alt=&#34;image-20210510084513077&#34;&gt;&lt;/p&gt;
&lt;p&gt;举例：假设某div在设计稿中长100px，设计稿宽度1920px&lt;/p&gt;
&lt;p&gt;​	则该div在页面中长为100/1920*100rem&lt;/p&gt;
&lt;p&gt;可以在scss中写一个px()函数来计算100px对应的rem&lt;/p&gt;
&lt;h1 id=&#34;3为什么要学&#34;&gt;3.为什么要学&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原生JS操作DOM&lt;strong&gt;繁琐、效率低&lt;/strong&gt;（&lt;strong&gt;DOM-API操作UI&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用js直接操作DOM，浏览器会进行大量的&lt;strong&gt;重绘重排&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原生js没有&lt;strong&gt;组件化&lt;/strong&gt;的编码方案，代码复用率低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块化&lt;/strong&gt;是针对js的，可以把js拆分成独立的功能模块，方便复用。但是html结构和css样式，包括字体图片音频视频等，复用率低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4react的特点&#34;&gt;4.React的特点&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用&lt;strong&gt;组件化模式&lt;/strong&gt;、&lt;strong&gt;声明式编码&lt;/strong&gt;，提高开发效率及组件复用率&lt;/p&gt;
&lt;p&gt;之前使用的是&lt;strong&gt;命令式编码&lt;/strong&gt;，面向过程。比如我想喝一杯水，需要命令别人先站起来，再走到水杯旁，把我帮我拿过来等等的步骤；但是声明式编码只需我说嗓子干了，自动就会帮我把水拿过来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;React Native&lt;/strong&gt;中可以使用React语法进行&lt;strong&gt;移动端&lt;/strong&gt;开发。&lt;/p&gt;
&lt;p&gt;React Native可以使得前端开发人员使用最熟悉的js来编写安卓和ios应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;strong&gt;虚拟DOM&lt;/strong&gt;+优秀的&lt;strong&gt;Diffing算法&lt;/strong&gt;，尽量减少与真实DOM的交互&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​	虚拟DOM发生改变后会对比之前的虚拟DOM，从而减少真实DOM的更新渲染过程&lt;/p&gt;
- https://gsemir0418.github.io/posts/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E5%AE%9E%E6%88%98/ - </description>
        </item>
    
    
    
        <item>
        <title>Hook</title>
        <link>https://gsemir0418.github.io/posts/reacthooks/</link>
        <pubDate>Fri, 07 May 2021 23:07:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/reacthooks/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/reacthooks/ -&lt;h1 id=&#34;1-hook简介&#34;&gt;1 Hook简介&lt;/h1&gt;
&lt;h2 id=&#34;11-基本概念&#34;&gt;1.1 基本概念&lt;/h2&gt;
&lt;p&gt;Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使⽤ state 以及其他的 React 特性。&lt;/p&gt;
&lt;h2 id=&#34;12-react-hooks优势&#34;&gt;1.2 React Hooks优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数组件不能使⽤state，⼀般只⽤于⼀些简单⽆交互的组件，⽤作信息展示，即我们上⾯说的傻⽠组件使⽤，如果需要交互更改状态等复杂逻辑时就需要使⽤class组件了&lt;/p&gt;
&lt;p&gt;React Hooks让我们更好的拥抱函数式编程，让函数式组件也能使⽤state功能，因为函数式组件⽐class组件更简洁好⽤，因为React Hooks的出现，相信未来我们会更多的使⽤函数式组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副作⽤问题&lt;/p&gt;
&lt;p&gt;我们⼀般称数据获取、订阅、定时执⾏任务、⼿动修改ReactDOM这些⾏为都可以称为副作⽤由于React Hooks的出现，我们可以使⽤useEffffect来处理组件副作⽤问题，所以我们的函数式组件也能进⾏副作⽤逻辑的处理了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有状态的逻辑重⽤组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复杂的状态管理&lt;/p&gt;
&lt;p&gt;之前我们使⽤redux、dva、mobx第三⽅状态管理器来进⾏复杂的状态管理&lt;/p&gt;
&lt;p&gt;现在我们可以使⽤useReducer、useContext配合使⽤实现复杂状态管理，不⽤再依赖第三⽅状态管理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发效率和质量问题&lt;/p&gt;
&lt;p&gt;函数式组件⽐class组件简洁，开发的体验更好，效率更⾼同时应⽤的性能也更好&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-usestate&#34;&gt;2 useState&lt;/h1&gt;
&lt;h2 id=&#34;21-定义&#34;&gt;2.1 定义&lt;/h2&gt;
&lt;p&gt;useState：组件状态管理钩⼦，使函数组件能够使⽤state&lt;/p&gt;
&lt;h2 id=&#34;22-基本使用&#34;&gt;2.2 基本使用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [state,setState]=useState(initState)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;state是要设置的状态&lt;/li&gt;
&lt;li&gt;setState是更新state的⽅法，只是⼀个⽅法名，可以随意更改&lt;/li&gt;
&lt;li&gt;initState是初始的state，可以是随意的数据类型，也可以是回调函数，但是函数必须是有返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23-实际应用&#34;&gt;2.3 实际应用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React, { useState } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; UseS() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [count, setState] = useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;你点击了{count}次&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;onClick&lt;/span&gt;={() =&amp;gt; setState(count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)}&amp;gt;点 击&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;3-useeffect&#34;&gt;3 useEffect&lt;/h1&gt;
&lt;h2 id=&#34;31-定义&#34;&gt;3.1 定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;useEffffect：副作⽤处理钩⼦&lt;/li&gt;
&lt;li&gt;数据获取、订阅、定时执⾏任务、⼿动修改ReactDOM这些⾏为都可以称为副作⽤。⽽useEffffect就是为了处理这些副作⽤⽽⽣的&lt;/li&gt;
&lt;li&gt;useEffffect也是componentDidMount、componentDidUpdate和componentWillUnmount这⼏个⽣命周期⽅法的统⼀&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-基本使用&#34;&gt;3.2 基本使用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;useEffect(callback,array)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;callback：回调函数，作⽤是处理副作⽤逻辑。可以返回⼀个函数，⽤作清理&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;useEffect(() =&amp;gt;{
	&lt;span style=&#34;color:#228b22&#34;&gt;//副作⽤逻辑
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	xxxxxx
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ()=&amp;gt;{
		&lt;span style=&#34;color:#228b22&#34;&gt;//清理副作⽤需要清理的内容
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//类似于componentWillUnmount，组件渲染和组件卸载前执⾏的代码
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
},[array])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;array(可选参数)：数组，⽤于控制useEffffect的执⾏。分三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空数组，则只会执⾏⼀次（即初次渲染render）,相当于componentDidMount&lt;/li&gt;
&lt;li&gt;⾮空数组，useEffffect会在数组发⽣改变后执⾏，相当于componentDidUpdate&lt;/li&gt;
&lt;li&gt;不填array这个数组，useEffffect每次渲染都会执⾏&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33-实际应用&#34;&gt;3.3 实际应用&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; { useState, useEffect } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; UseE = () =&amp;gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; [count, setState] = useState(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)

    useEffect(() =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//更新⻚⾯标题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.title = &lt;span style=&#34;color:#cd5555&#34;&gt;`您点击了&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;count&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;次了哦`&lt;/span&gt;
    }, [count])
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;你点击了{count}次&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;onClick&lt;/span&gt;={() =&amp;gt; setState(count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)}&amp;gt;点 击&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    )
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; UseE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;4-usecontext&#34;&gt;4 useContext&lt;/h1&gt;
&lt;h2 id=&#34;41-定义&#34;&gt;4.1 定义&lt;/h2&gt;
&lt;p&gt;context就是⽤来更⽅便的实现全局数据共享的，但是由于他并不是那么好⽤，所以我们⼀般会使⽤第三⽅状态管理器来实现全局数据共享&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redux&lt;/li&gt;
&lt;li&gt;dva&lt;/li&gt;
&lt;li&gt;mobx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是针对context上下⽂提出的⼀个Hooks提出的⼀个API，它接受React.createContext()的返回值作为参数，即context对象，并返回最近的context&lt;/p&gt;
&lt;p&gt;使⽤useContext是不需要再使⽤Provider和Consumer的&lt;/p&gt;
&lt;p&gt;当最近的context更新时，那么使⽤该context的hook将会重新渲染&lt;/p&gt;
&lt;h2 id=&#34;42-基本使用&#34;&gt;4.2 基本使用&lt;/h2&gt;
&lt;p&gt;store.js中创建数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Context = React.createContext({ age: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;18&amp;#39;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;jerry&amp;#39;&lt;/span&gt; })
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; Context
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;组件中使用useContext接收数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; React, { useContext } from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; Context from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;./store&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; UseC = () =&amp;gt; {
    &lt;span style=&#34;color:#228b22&#34;&gt;//使⽤useContext
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; ctx = useContext(Context)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;姓名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h2&lt;/span&gt;&amp;gt;{ctx.name}&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h2&lt;/span&gt;&amp;gt;年龄&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{ctx.age}岁&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
    )
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; UseC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gsemir0418.github.io/posts/reacthooks/ - </description>
        </item>
    
    
    
        <item>
        <title>React组件生命周期</title>
        <link>https://gsemir0418.github.io/posts/react%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
        <pubDate>Thu, 06 May 2021 11:09:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ -&lt;h1 id=&#34;1-生命周期的理解&#34;&gt;1 生命周期的理解&lt;/h1&gt;
&lt;h2 id=&#34;11-引出生命周期&#34;&gt;1.1 引出生命周期&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让指定的文本做显示* */* 隐藏的渐变动画&lt;/li&gt;
&lt;li&gt;从完全可见，到彻底消失，耗时2S&lt;/li&gt;
&lt;li&gt;点击“不活了”按钮从界面中卸载组件&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码及笔记如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Life &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//只要页面发生更新，则说明是状态在驱动
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        state = {
            opacity: &lt;span style=&#34;color:#b452cd&#34;&gt;0.5&lt;/span&gt;
        }

        death = () =&amp;gt; {
            ReactDOM.unmountComponentAtNode(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//和render一样 是由React帮忙调用的 因此不用写成箭头函数的形式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//执行时机：组件挂载到页面后
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidMount() {
            &lt;span style=&#34;color:#228b22&#34;&gt;//起个名字 挂到实例自身 方便清除时用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.timer = setInterval(() =&amp;gt; {
                &lt;span style=&#34;color:#228b22&#34;&gt;//获取状态值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; opacity = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.opacity
                &lt;span style=&#34;color:#228b22&#34;&gt;//每次-0.1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                opacity -= &lt;span style=&#34;color:#b452cd&#34;&gt;0.1&lt;/span&gt;
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (opacity &amp;lt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) opacity = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
                &lt;span style=&#34;color:#228b22&#34;&gt;//设置新的透明度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ opacity })
            }, &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt;)
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//执行时机：组件将要被卸载
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUnmount() {
            clearInterval(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.timer)
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//执行时机：初始化渲染、状态更新后
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        render() {
            &lt;span style=&#34;color:#228b22&#34;&gt;//如果将定时器函数放到render中，那么由于定时器中更新了state值，render函数就会不断被调用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//从而形成无限递归
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// setInterval(() =&amp;gt; {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     //获取状态值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     let opacity = this.state.opacity
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     //每次-0.1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     opacity -= 0.1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     if (opacity &amp;lt;= 0) opacity = 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     //设置新的透明度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//     this.setState({ opacity })
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// }, 200)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;h2 style={{ opacity: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.opacity }}&amp;gt;React学不会怎么办&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.death}&amp;gt;不活了&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }
    }
    ReactDOM.render(&amp;lt;Life /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;12-生命周期的理解&#34;&gt;1.2 生命周期的理解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;合适的时间节点做合适的事&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组件从创建到死亡它会经历一些特定的阶段。&lt;/li&gt;
&lt;li&gt;React 组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。&lt;/li&gt;
&lt;li&gt;我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-react生命周期旧&#34;&gt;2 React生命周期（旧）&lt;/h1&gt;
&lt;h2 id=&#34;21-react生命周期图旧&#34;&gt;2.1 React生命周期图（旧）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;.%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png&#34; alt=&#34;react生命周期(旧)&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Count &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//构造器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        constructor(props) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---constructor&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { count: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; }
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要挂载的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillMount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentWillMount&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件是否更新的钩子 相当于&amp;#34;阀门&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        shouldComponentUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---shouldComponentUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要更新的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentWillUpdate&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;// 加一事件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        add = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ count: count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; })
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//强制更新组件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        force = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.forceUpdate()
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件更新完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidUpdate&amp;#39;&lt;/span&gt;);
        }

        render() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---render&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;h2&amp;gt;当前求和为&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{count}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.add}&amp;gt;点我+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.death}&amp;gt;卸载组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.force}&amp;gt;不更新状态&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;只是强制更新一下组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件挂载完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidMount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidMount&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要卸载的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUnmount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---conponentWillUnmount&amp;#39;&lt;/span&gt;);
        }

        death = () =&amp;gt; {
            ReactDOM.unmountComponentAtNode(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
        }
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//父组件A
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; A &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        state = {
            carName: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;奔驰&amp;#39;&lt;/span&gt;
        }

        changeCar = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ carName: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;奥迪&amp;#39;&lt;/span&gt; })
        }

        render() {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;div&amp;gt;我是A组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeCar}&amp;gt;点我切换汽车信息&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;B carName={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.carName} /&amp;gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//子组件B
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; B &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {

        &lt;span style=&#34;color:#228b22&#34;&gt;//第一次打开界面 发现其未运行 点击按钮后才会运行此钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//改名为componentWillReceiveNewProps更为准确
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要接收新的props的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillReceiveProps() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---componentWillReceiveProps&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//控制组件更新的阀门
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        shouldComponentUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---shouldComponentUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#228b22&#34;&gt;//只要写了此钩子 必须return一个布尔值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要更新的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---componentWillUpdate&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件更新完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---componentDidUpdate&amp;#39;&lt;/span&gt;);
        }

        render() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;B---render&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;我是B组件&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;接受到的汽车是{&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props.carName}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }
    }

    ReactDOM.render(&amp;lt;Count /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;22-总结生命周期旧&#34;&gt;2.2 总结生命周期（旧）&lt;/h2&gt;
&lt;p&gt;生命周期的三个阶段（旧）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化阶段: 由 ReactDOM.render()触发&amp;mdash;初次渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    	1. constructor()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 2. componentWillMount() 
   
 3. render()
   
 4. **componentDidMount**()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​        		一般在此钩子中做一些初始化的事：开启定时器，发送网络请求、订阅消息&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发&lt;/p&gt;
&lt;p&gt;​	1. shouldComponentUpdate()&lt;/p&gt;
&lt;p&gt;​    2. componentWillUpdate()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 3. **render**()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    		4. componentDidUpdate()&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;卸载组件: 由 ReactDOM.unmountComponentAtNode()触发&lt;/p&gt;
&lt;p&gt;​    1. &lt;strong&gt;componentWillUnmount&lt;/strong&gt;()&lt;/p&gt;
&lt;p&gt;​        	一般做一些收尾的事：关闭定时器、取消订阅消息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;23-react生命周期图新&#34;&gt;2.3 React生命周期图（新）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;.%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png&#34; alt=&#34;react生命周期(新)&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Count &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
        &lt;span style=&#34;color:#228b22&#34;&gt;//构造器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        constructor(props) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---constructor&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { count: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; }
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//通过props获取派生状态对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; getDerivedStateFromProps(props, state) {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---getDerivedStateFromProps&amp;#39;&lt;/span&gt;, props, state);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//必须有返回值，返回值可以是null也可以是state对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//return {count:2}//会覆盖初始化的state，且影响更新过程，setState方法失效（因为横跨挂载和更新过程）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;//return props //可以接收props作为参数并返回 使得state值在任何时候都取决于props
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//在更新之前获取快照
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        getSnapshotBeforeUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---getSnapshotBeforeUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;atguigu&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//返回null或者snapshot值（任何值）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件是否更新的钩子 相当于&amp;#34;阀门&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        shouldComponentUpdate() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---shouldComponentUpdate&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;// 加一事件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        add = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ count: count + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; })
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//强制更新组件的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        force = () =&amp;gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.forceUpdate()
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件更新完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//默认接收两个参数，分别是prevProps，prevState和snapshot值（例如滚轮位置）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidUpdate(prevProps, prevState, snapshot) {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidUpdate&amp;#39;&lt;/span&gt;, prevProps, prevState, snapshot);
        }

        render() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---render&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { count } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
                &amp;lt;div&amp;gt;
                    &amp;lt;h2&amp;gt;当前求和为&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{count}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.add}&amp;gt;点我+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.death}&amp;gt;卸载组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                    &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.force}&amp;gt;不更新状态&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;只是强制更新一下组件&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
            )
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件挂载完毕的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentDidMount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---componentDidMount&amp;#39;&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#228b22&#34;&gt;//组件将要卸载的钩子
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        componentWillUnmount() {
            console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Count---conponentWillUnmount&amp;#39;&lt;/span&gt;);
        }

        death = () =&amp;gt; {
            ReactDOM.unmountComponentAtNode(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
        }
    }

    ReactDOM.render(&amp;lt;Count count={&lt;span style=&#34;color:#b452cd&#34;&gt;199&lt;/span&gt;} /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;24-总结生命周期新&#34;&gt;2.4 总结生命周期（新）&lt;/h2&gt;
&lt;p&gt;生命周期的三个阶段（新）&lt;/p&gt;
&lt;p&gt;1.初始化阶段: 由 ReactDOM.render()触发&amp;mdash;初次渲染&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1. constructor() 
  
 2. **getDerivedStateFromProps**() 
  
 3. render() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		4. &lt;strong&gt;componentDidMount&lt;/strong&gt;() 即将出生的那一刻&lt;/p&gt;
&lt;p&gt;2.更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发&lt;/p&gt;
&lt;p&gt;​    	1. getDerivedStateFromProps ()&lt;/p&gt;
&lt;p&gt;​    	2. shouldComponentUpdate()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 3. **render**() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​    	4. &lt;strong&gt;getSnapshotBeforeUpdate&lt;/strong&gt;()&lt;/p&gt;
&lt;p&gt;​    	5. componentDidUpdate()&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;卸载组件: 由 ReactDOM.unmountComponentAtNode()触发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. **componentWillUnmount**() 即将离去的那一刻
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;25-新旧生命周期对比&#34;&gt;2.5 新旧生命周期对比&lt;/h2&gt;
&lt;p&gt;即将在18版本废除三个钩子（willmount，willupdate，willreceiveprops）&lt;/p&gt;
&lt;p&gt;新增了两个钩子（getDerivedStateFromProps，getSnapshotBeforeUpdate）&lt;/p&gt;
- https://gsemir0418.github.io/posts/react%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ - </description>
        </item>
    
    
    
        <item>
        <title>React面向组件编程</title>
        <link>https://gsemir0418.github.io/posts/react%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Thu, 29 Apr 2021 23:11:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/ -&lt;h1 id=&#34;1-react定义组件&#34;&gt;1 React定义组件&lt;/h1&gt;
&lt;h2 id=&#34;11-函数式组件&#34;&gt;1.1 函数式组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数式组件适用于简单组件的定义，其首字母需大写，且虚拟DOM元素必须有结束标签&lt;/li&gt;
&lt;li&gt;函数组件中的this指向为window，但babel编译后默认开启了严格模式，因此结果为undefined&lt;/li&gt;
&lt;li&gt;返回的虚拟DOM元素只能有一个根元素&lt;/li&gt;
&lt;li&gt;渲染函数式组件的过程：
&lt;ol&gt;
&lt;li&gt;React解析组件标签，找到了Demo组件&lt;/li&gt;
&lt;li&gt;发现组件式使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM。随后呈现在页面中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Demo(){
	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1&amp;gt;函数式组件&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;适用于简单组件的定义&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
}
ReactDOM.render(&amp;lt;Demo/&amp;gt;,&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;12-类式组件&#34;&gt;1.2 类式组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;继承&lt;strong&gt;React.Component&lt;/strong&gt;类，组件名首字母必须&lt;strong&gt;大写&lt;/strong&gt;，且虚拟DOM元素必须有&lt;strong&gt;结束标签&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须有&lt;strong&gt;render()&lt;strong&gt;方法，且render方法必须有&lt;/strong&gt;返回值&lt;/strong&gt;，返回的虚拟DOM元素只能&lt;strong&gt;有一个根元素&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渲染类式组件的过程&lt;/p&gt;
&lt;p&gt;1.React 内部会创建组件实例对象&lt;/p&gt;
&lt;p&gt;2.调用 render()得到虚拟 DOM, 并解析为真实 DOM&lt;/p&gt;
&lt;p&gt;3.插入到指定的页面元素内部&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; MyComponent &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component{
	render(){
	&lt;span style=&#34;color:#228b22&#34;&gt;//render放在MyComponent的原型对象（React.Component）上，供实例使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//render中的this指向MyComponent实例对象（组件实例对象）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;render方法中的this指向：&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1&amp;gt;类式组件&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;适用于复杂组件的定义&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
	}
}
ReactDOM.render(&amp;lt;MyComponent/&amp;gt;,&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;2-组件实例三大属性&#34;&gt;2 组件实例三大属性&lt;/h1&gt;
&lt;h2 id=&#34;21-state&#34;&gt;2.1 state&lt;/h2&gt;
&lt;h3 id=&#34;211-state基本使用&#34;&gt;2.1.1 state基本使用&lt;/h3&gt;
&lt;p&gt;state 是组件对象最重要的属性，值是对象(可以包含多个 key-value 的组合)&lt;/p&gt;
&lt;p&gt;组件被称为&amp;quot;状态机&amp;quot;，通过更新组件的 state 来更新对应的页面显示(重新渲染组件)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：定义一个展示天气信息的组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认展示天气炎热 或 凉爽&lt;/li&gt;
&lt;li&gt;点击文字切换天气&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码如下：（无效）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Weather &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
	constructor(props) {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; }&lt;span style=&#34;color:#228b22&#34;&gt;//this指向当前类的实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//解决方案
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//利用bind将原型对象上的changeWeather方法的this指向强行绑定为实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//从而形成一个新函数，再将其赋值给新的变量changeWeather
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather.bind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }
	changeWeather() {
        &lt;span style=&#34;color:#228b22&#34;&gt;//changWeather方法放在Weather的原型对象上，供实例对象使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//由于changeWeather是作为onClick的回调，所以是直接调用的，而不是通过实例调用的，此时this应该指向window对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//又因为类中的方法默认开启了局部严格模式，所以结果为undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
	render() {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state&lt;span style=&#34;color:#228b22&#34;&gt;//this是组件实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
		&lt;span style=&#34;color:#228b22&#34;&gt;//绑定默认事件时，要注意C大写，如onBlur；
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//事件的回调函数不需要加括号，否则react会将方法执行后的返回值（这里是undefined）赋给onClick，使得单击事件失效
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1 onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
	}
}
ReactDOM.render(&amp;lt;Weather /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;212-注意&#34;&gt;2.1.2 注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件中 render 方法中的 this 为组件实例对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件自定义的方法中 this 为 undefined，如何解决？&lt;/p&gt;
&lt;p&gt;1.强制绑定 this: 通过函数对象的 bind()&lt;/p&gt;
&lt;p&gt;2.箭头函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态数据，不能直接修改或更新，需要在方法中使用**this.setState({})**来修改，修改后代码如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Weather &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {

    &lt;span style=&#34;color:#228b22&#34;&gt;//构造器调用几次？————1次
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    constructor(props) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
        &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;, wind: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;微风&amp;#39;&lt;/span&gt; }&lt;span style=&#34;color:#228b22&#34;&gt;//this指向当前类的实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//解决this指向问题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather.bind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//render调用几次？————1+n次 1是指初始化的那次 n是状态更新的次数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    render() {
        &lt;span style=&#34;color:#228b22&#34;&gt;//读取状态，ES6的解构赋值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot, wind } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state&lt;span style=&#34;color:#228b22&#34;&gt;//this是组件实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1 onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;{wind}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
    }

    &lt;span style=&#34;color:#228b22&#34;&gt;//changeWeather调用几次？————点几次调用几次
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeWeather() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//获取原来的isHot值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; isHot = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.isHot
        &lt;span style=&#34;color:#228b22&#34;&gt;//严重注意，state状态值不能直接更改，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//this.state.isHot = !isHot是错误的,react是严格的单向绑定，值在这变化虽然有效，但react不认
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//状态值必须通过setState方法进行更新，且更新是一种合并状态，而不是替换，否则微风也就不会显示了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ isHot: !isHot })
    }
}
ReactDOM.render(&amp;lt;Weather /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;213-state的简写方式&#34;&gt;2.1.3 state的简写方式：&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Weather &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//利用类的特性，可以直接写赋值语句，表示在该类的每一个实例对象中添加state属性
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;, wind: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;微风&amp;#39;&lt;/span&gt; }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot, wind } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;h1 onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;{wind}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//自定义方法（只能作为事件的回调，因为react只会帮我们new实例之后执行render方法）：赋值语句+箭头函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//由于箭头函数没有自己的this，回去找外层的this，正是实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeWeather = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; isHot = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state.isHot
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ isHot: !isHot })
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
    }
}
ReactDOM.render(&amp;lt;Weather/&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;22-props&#34;&gt;2.2 props&lt;/h2&gt;
&lt;h3 id=&#34;221-props基本使用&#34;&gt;2.2.1 props基本使用&lt;/h3&gt;
&lt;p&gt;每个组件对象都会有 props(properties 的简写)属性，&lt;strong&gt;组件标签的所有属性都保存在 props 中&lt;/strong&gt;，可以通过标签属性从组件外向组件内传递变化的数据&lt;/p&gt;
&lt;p&gt;注意: 组件内部不要修改 props 数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：自定义用来显示一个人员信息的组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Person &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
        &lt;span style=&#34;color:#228b22&#34;&gt;//console.log(this);//均指向实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//this.props.name = &amp;#34;haha&amp;#34;会报错，因为props是只读的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { name, age, gender } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;name:{name}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
                &amp;lt;li&amp;gt;age:{age + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
                &amp;lt;li&amp;gt;gender:{gender}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
        )
    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;//注意传参时的age要用{}包裹起来
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;ReactDOM.render(&amp;lt;Person name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tom&amp;#39;&lt;/span&gt; age={&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;} gender=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
ReactDOM.render(&amp;lt;Person name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt; age={&lt;span style=&#34;color:#b452cd&#34;&gt;20&lt;/span&gt;} gender=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test2&amp;#39;&lt;/span&gt;))

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; personAjax = { name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;ajax&amp;#39;&lt;/span&gt;, age: &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;, gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; }
&lt;span style=&#34;color:#228b22&#34;&gt;//可以使用展开运算符批量传递props
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;ReactDOM.render(&amp;lt;Person {...personAjax} /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test3&amp;#39;&lt;/span&gt;))
&lt;span style=&#34;color:#228b22&#34;&gt;//注意，此处的{...personajax}并不是展开运算符的克隆对象用法，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//而是babel和react允许展开运算符展开对象并赋值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(...personAjax);&lt;span style=&#34;color:#228b22&#34;&gt;//为空，虽然允许展开，但不能让你随意操作
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;222-对props进行限制&#34;&gt;2.2.2 对props进行限制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;姓名必须指定，且为字符串类型&lt;/li&gt;
&lt;li&gt;性别为字符串类型，如果性别没有指定，默认为男&lt;/li&gt;
&lt;li&gt;年龄为字符串类型，且为数字类型，默认值为 18&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!--&lt;/span&gt; 引入propstype&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;，&lt;/span&gt;用来对props进行限制&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;（&lt;/span&gt;其实就是弹出一些警告&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;）&lt;/span&gt; --&amp;gt;
&amp;lt;script src=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/prop-types.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/script&amp;gt;&lt;/span&gt;
...
	&lt;span style=&#34;color:#228b22&#34;&gt;//对标签属性进行类型、必要性等的限制
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    Person.propTypes = {&lt;span style=&#34;color:#228b22&#34;&gt;//此处的p小写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        name:PropTypes.string.isRequired,&lt;span style=&#34;color:#228b22&#34;&gt;//别忘逗号和P和T都大写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        gender:PropTypes.string,
        age:PropTypes.number,
        eat:PropTypes.func&lt;span style=&#34;color:#228b22&#34;&gt;//如果要限制传递方法，注意方法的名字是func
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//指定默认标签属性值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    Person.defaultProps={
        gender:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;不男不女&amp;#39;&lt;/span&gt;,
        age:&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;223-props的简写方式&#34;&gt;2.2.3 props的简写方式&lt;/h3&gt;
&lt;p&gt;就是将定义在类之外的限制props的语句作为静态方法，写到类中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若要给类的原型对象自身加属性，用static关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Person &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//对标签属性进行类型、必要性等的限制
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; propTypes = {&lt;span style=&#34;color:#228b22&#34;&gt;//此处的p小写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        name: PropTypes.string.isRequired,&lt;span style=&#34;color:#228b22&#34;&gt;//别忘逗号和P和T都大写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        gender: PropTypes.string,
        age: PropTypes.number,
        eat: PropTypes.func&lt;span style=&#34;color:#228b22&#34;&gt;//如果要限制传递方法，注意方法的名字是func
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//指定默认标签属性值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; defaultProps = {
        gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;不男不女&amp;#39;&lt;/span&gt;,
        age: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { name, age, gender } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.props
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;ul&amp;gt;
            	&amp;lt;li&amp;gt;name:{name}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
				&amp;lt;li&amp;gt;age:{age + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
				&amp;lt;li&amp;gt;gender:{gender}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
			&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
		)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;224-类式组件中的构造器与props&#34;&gt;2.2.4 类式组件中的构造器与props&lt;/h3&gt;
&lt;p&gt;类中的构造器可以省略&lt;/p&gt;
&lt;p&gt;如果写了构造器，同时接受props并传递给super，那么就可以通过this.props访问实例对象的props了（几乎用不到）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;constructor(props) {
    &lt;span style=&#34;color:#228b22&#34;&gt;//构造器是否接受props，是否传递给super，取决于：
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//是否希望在构造器中通过this访问props（即访问每个实例对象的props）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//一般能不写就不写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(props)
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;constractor&amp;#39;&lt;/span&gt;,props);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;225-函数组件使用props&#34;&gt;2.2.5 函数组件使用props&lt;/h3&gt;
&lt;p&gt;函数组件因为自身能够传参，因此可以使用props属性&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//函数组件因为自身能够传参，因此可以使用props属性
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Person(props) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {name,gender,age} = props
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;姓名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{name}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
            &amp;lt;li&amp;gt;性别&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{gender}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
            &amp;lt;li&amp;gt;年龄&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;{age}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
        &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
    )
}
&lt;span style=&#34;color:#228b22&#34;&gt;//对props进行限制，只能放到函数外面了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;Person.propTypes = {&lt;span style=&#34;color:#228b22&#34;&gt;//此处的p小写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    name: PropTypes.string.isRequired,&lt;span style=&#34;color:#228b22&#34;&gt;//别忘逗号和P和T都大写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    gender: PropTypes.string,
    age: PropTypes.number,
    eat: PropTypes.func&lt;span style=&#34;color:#228b22&#34;&gt;//如果要限制传递方法，注意方法的名字是func
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
Person.defaultProps = {
    gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;不男不女&amp;#39;&lt;/span&gt;,
    age: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
}
ReactDOM.render(&amp;lt;Person age={&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;} gender=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;man&amp;#39;&lt;/span&gt; /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;23-refs&#34;&gt;2.3 refs&lt;/h2&gt;
&lt;p&gt;组件内的标签可以定义 ref 属性来&lt;strong&gt;标识自己&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求: 自定义组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;点击按钮, 提示第一个输入框中的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当第 2 个输入框失去焦点时, 提示这个输入框中的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;231-字符串形式的ref&#34;&gt;2.3.1 字符串形式的ref&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
                &amp;lt;input ref=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;inp1&amp;#34;&lt;/span&gt; type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
                &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&amp;amp;nbsp;&lt;/span&gt;
                &amp;lt;input ref=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;inp2&amp;#34;&lt;/span&gt; onBlur={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2} placeholder=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;失去焦点弹出输入内容&amp;#34;&lt;/span&gt; type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
    }
    showData = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {inp1} = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.refs
        alert(inp1.value)
    }
    showData2 = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {inp2} = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.refs
        alert(inp2.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;232-回调函数形式的ref&#34;&gt;2.3.2 回调函数形式的ref&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
                {&lt;span style=&#34;color:#228b22&#34;&gt;/* c表示currentNode，this表示组件实例对象，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                把ref当前所处节点(c)挂在了实例自身上，并命名为inp1 */&lt;/span&gt;}
                &amp;lt;input ref={c =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.inp1 = c} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
                &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
    }
    showData = () =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//const { inp1 } = this.refs不用从refs中取了，从实例自身取即可
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { inp1 } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        alert(inp1.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;233-回调形式ref调用次数的问题&#34;&gt;2.3.3 回调形式ref调用次数的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;初始化时，ref的回调会执行一次。但是当更新组件时，ref的回调会执行两次，分别返回null和currentNode，因为每次渲染时都会创建一个新的函数实例，所以React清空旧的ref并设置新的。&lt;/li&gt;
&lt;li&gt;可以定义成class的绑定函数的方法来解决，但一般就用内联就可以了，多此一举。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    state = { isHot: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt; }
    &lt;span style=&#34;color:#228b22&#34;&gt;//不用管它 只是为了更新组件方便些
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeWeather = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ isHot: !isHot })
    }
    showData = () =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//const { inp1 } = this.refs不用从refs中取了，从实例自身取即可
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { inp1 } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        alert(inp1.value)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//只是将将内联形式提取出来而已，可以解决此问题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    saveRef = (c) =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.inp2 = c&lt;span style=&#34;color:#228b22&#34;&gt;//将传入的c节点挂载到实例对象上，命名为inp2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@@&amp;#34;&lt;/span&gt;, c);
    }
    showData2 = () =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { inp2 } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        alert(inp2.value)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { isHot } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
            &amp;lt;h2&amp;gt;今天天气很{isHot ? &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;炎热&amp;#39;&lt;/span&gt; : &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;寒冷&amp;#39;&lt;/span&gt;}&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h2&amp;gt;&lt;/span&gt;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.changeWeather}&amp;gt;单击切换天气&amp;lt;&lt;span style=&#34;color:#1c7e71&#34;&gt;/button&amp;gt;&amp;lt;br /&lt;/span&gt;&amp;gt;
            {&lt;span style=&#34;color:#228b22&#34;&gt;/*初始化时，ref的回调会执行一次
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            但是当更新组件时，ref的回调会执行两次，分别返回null和currentNode，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            因为每次渲染时都会创建一个新的函数实例，所以React清空旧的ref并设置新的*/&lt;/span&gt;}

            {&lt;span style=&#34;color:#228b22&#34;&gt;/*传统内联回调形式*/&lt;/span&gt;}
            &amp;lt;input ref={c =&amp;gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.inp1 = c, console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@&amp;#34;&lt;/span&gt;, c); }} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;

            {&lt;span style=&#34;color:#228b22&#34;&gt;/*可以定义成class的绑定函数的方法来解决 但一般就用内联就可以了 多此一举*/&lt;/span&gt;}
            &amp;lt;input type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveRef} /&amp;gt;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
    	)	
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;234-createref&#34;&gt;2.3.4 createRef&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;React.createRef()调用后，返回一个容器，该容器可以存储被ref所标识的节点&lt;/li&gt;
&lt;li&gt;一个容器只能存一个节点&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    React.createRef()调用后，返回一个容器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    该容器可以存储被ref所标识的节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    一个容器只能存一个节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    */&lt;/span&gt;
    myRef1 = React.createRef()
    myRef2 = React.createRef()
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
                &amp;lt;input ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
                &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
                &amp;lt;input ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef2} onBlur={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;/&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
    }
    showData = () =&amp;gt; {
    	alert(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1.current.value)
    }
    showData2 = ()=&amp;gt;{
    	alert(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef2.current.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;235-事件处理&#34;&gt;2.3.5 事件处理&lt;/h3&gt;
&lt;p&gt;1.通过onXxx属性指定事件处理函数（注意大小写）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React使用的是自定义事件，而不是原生DOM事件——为了更好的兼容性&lt;/li&gt;
&lt;li&gt;React中的事件是通过事件委托方式处理的（委托给组件最外层的元素）——为了高效率&lt;/li&gt;
&lt;li&gt;事件委托的原理是事件冒泡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.通过event.target（发生事件的事件源）得到发生事件的DOM元素对象——不要过度使用ref&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当发生事件的元素正好是我们要操作的元素，就可以省略ref，例如下面的失去焦点事件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Demo &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//创建ref容器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    myRef1 = React.createRef()
    render() {
        console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;div&amp;gt;
            &amp;lt;input ref={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;&amp;amp;nbsp;
            &amp;lt;button onClick={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData}&amp;gt;点击显示左侧内容&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;input onBlur={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.showData2} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;
        	&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
    	)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//展示左侧输入框的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    showData = () =&amp;gt; {
        alert(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.myRef1.current.value)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//展示右侧输入框的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//react在调用这个回调的同时会传入event事件对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    showData2 = (e) =&amp;gt; {
        alert(event.target.value)
    }
}
ReactDOM.render(&amp;lt;Demo /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;3-react收集表单数据&#34;&gt;3 React收集表单数据&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;需求: 定义一个包含表单的组件&lt;/p&gt;
&lt;p&gt;输入用户名密码后，点击登录提示输入信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;31-非受控组件&#34;&gt;3.1 非受控组件&lt;/h2&gt;
&lt;p&gt;输入类型的DOM（表单），对其值现用现取（username.value）的组件，称其为非受控组件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    handleSubmit = () =&amp;gt; {
        event.preventDefault()&lt;span style=&#34;color:#228b22&#34;&gt;//阻止表单的默认提交动作
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;{username,password} = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;
        &lt;span style=&#34;color:#228b22&#34;&gt;// alert(username)是错误的，因为挂载到实例自身的是username节点，表示的是用户名输入框这个节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 所以要通过.value显示其值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        alert(&lt;span style=&#34;color:#cd5555&#34;&gt;`username:&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;username.value&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;,password:&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;password.value&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;form action=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.atguigu.com&amp;#34;&lt;/span&gt; onSubmit={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.handleSubmit}&amp;gt;
                用户名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input ref={c =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.username = c} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; /&amp;gt;
                密码&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input ref={c =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.password = c} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/form&amp;gt;&lt;/span&gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;32-受控组件&#34;&gt;3.2 受控组件&lt;/h2&gt;
&lt;p&gt;页面中所有输入类的dom，随着我们的输入，就能把数据维护到状态中，需要用时直接在状态中取出即可&lt;/p&gt;
&lt;p&gt;即实现&lt;strong&gt;双向数据绑定&lt;/strong&gt;的组件称之为受控组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Login extends React.Component {
	//初始化状态
    state = {
        username:&amp;quot;&amp;quot;,
        password:&amp;quot;&amp;quot;
    }
    //保存用户名到状态中
    saveUsername = (event) =&amp;gt; {
    	this.setState({ username: event.target.value })
    }
    //保存密码到状态中
    savePassword = (event) =&amp;gt; {
    	this.setState({ password: event.target.value })
    }
    //表单提交的回调
    handleSubmit = () =&amp;gt; {
    	event.preventDefault()
    	const { username, password } = this.state
    	alert(`username=${username},password=${password}`)
    }
    //页面中所有输入类的dom，随着我们的输入，就能把数据维护到状态中，需要用时直接在状态中取出即可
    //即双向数据绑定
    render() {
        return (
            &amp;lt;form action=&amp;quot;http://www.atguigu.com&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
                用户名：&amp;lt;input onChange={this.saveUsername} type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;
                密码：&amp;lt;input onChange={this.savePassword} type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, document.getElementById(&#39;test&#39;))
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&#34;4-高阶函数以及函数柯里化&#34;&gt;4 高阶函数以及函数柯里化&lt;/h1&gt;
&lt;p&gt;上文中的方法过于冗杂，不适于输入项较多的表单&lt;/p&gt;
&lt;p&gt;可以只写一个函数，通过表单项&lt;strong&gt;回调函数的参数&lt;/strong&gt;来界定保存的数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    state = {
        username: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
        password: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//保存表单数据到状态中
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    saveFormData = (dataType) =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//当我们给onchange事件的回调函数加上括号，实际表示将其返回值作为onchange事件的回调了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//因此我们索性将此回调函数的返回值写作一个新回调函数，作为onchange事件真正的回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; () =&amp;gt; {
            &lt;span style=&#34;color:#228b22&#34;&gt;//dataType需要加中括号，因为{}对象中左侧的默认是字符串类型，加不加引号都属于字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ [dataType]: event.target.value })
        }
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//表单提交的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    handleSubmit = () =&amp;gt; {
        event.preventDefault()
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { username, password } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        alert(&lt;span style=&#34;color:#cd5555&#34;&gt;`username=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;username&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;,password=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;password&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;form action=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.atguigu.com&amp;#34;&lt;/span&gt; onSubmit={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.handleSubmit}&amp;gt;
                用户名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;username&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; /&amp;gt;
                密码&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/form&amp;gt;&lt;/span&gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;41-高阶函数与函数柯里化的定义&#34;&gt;4.1 高阶函数与函数柯里化的定义&lt;/h2&gt;
&lt;p&gt;1.高阶函数：如果一个函数符合下面规范中的任何一个，那该函数就是高阶函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若A函数，接受的参数是一个函数，那么A就称为高阶函数&lt;/li&gt;
&lt;li&gt;若A函数，调用的返回值依然是一个函数，那么A就称为高阶函数&lt;/li&gt;
&lt;li&gt;常见的高阶函数有：Promise、setTimeout、arr.map&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.函数的柯里化：通过函数调用继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式&lt;/p&gt;
&lt;h2 id=&#34;42-不使用柯里化的写法&#34;&gt;4.2 不使用柯里化的写法&lt;/h2&gt;
&lt;p&gt;直接将返回值中的回调函数写成内联的形式，并传出event对象.&lt;/p&gt;
&lt;p&gt;柯里化的核心点在于，事件的回调必须是一个函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Login &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; React.Component {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化状态
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    state = {
        username: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
        password: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//保存表单数据到状态中
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    saveFormData = (dataType) =&amp;gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;//当我们给onchange事件的回调函数加上括号，实际表示将其返回值作为onchange事件的回调了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//因此我们索性将此回调函数的返回值写作一个新回调函数，作为onchange事件真正的回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; () =&amp;gt; {
            &lt;span style=&#34;color:#228b22&#34;&gt;//dataType需要加中括号，因为{}对象中左侧的默认是字符串类型，加不加引号都属于字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.setState({ [dataType]: event.target.value })
        }
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//表单提交的回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    handleSubmit = () =&amp;gt; {
        event.preventDefault()
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; { username, password } = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.state
        alert(&lt;span style=&#34;color:#cd5555&#34;&gt;`username=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;username&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;,password=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;password&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    }
    render() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (
            &amp;lt;form action=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.atguigu.com&amp;#34;&lt;/span&gt; onSubmit={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.handleSubmit}&amp;gt;
                用户名&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;username&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; /&amp;gt;
                密码&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;：&lt;/span&gt;&amp;lt;input onChange={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.saveFormData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;)} type=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; /&amp;gt;
                &amp;lt;button&amp;gt;登录&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/form&amp;gt;&lt;/span&gt;
        )
    }
}
ReactDOM.render(&amp;lt;Login /&amp;gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;补充&#34;&gt;补充：&lt;/h1&gt;
&lt;h2 id=&#34;1-类的基本知识&#34;&gt;1 类的基本知识&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类中的构造器不是必须写的，如果要对实例进行一些初始化的操作，如添加指定属性时再写&lt;/li&gt;
&lt;li&gt;若A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须调用的&lt;/li&gt;
&lt;li&gt;类中所定义的方法，都是放在类的原型对象上，供实例去使用&lt;/li&gt;
&lt;li&gt;类中允许直接写赋值语句&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//创建一个Person类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Person {
    &lt;span style=&#34;color:#228b22&#34;&gt;//构造器方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    constructor(name, age) {
        &lt;span style=&#34;color:#228b22&#34;&gt;//构造器中的this指向实例对象，因为在new的时候实际上是实例对象调用的构造器方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age = age
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//一般方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    speak() {
        console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;`我叫&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;，我今年&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;岁了`&lt;/span&gt;);
        &lt;span style=&#34;color:#228b22&#34;&gt;//speak方法写在类的的原型对象上，供实例使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//实例在调用自身不存在的方法时，会自动去原型链上找
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//通过Person的实例调用speak方法时，speak中的this就是person实例
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//具体情况需要看是谁调用的，call bind apply都可以改变this的指向
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;//创建一个Person的实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; p1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Person(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;25&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; p2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Person(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;zs&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;26&lt;/span&gt;)
console.log(p1);
console.log(p2);
p1.speak()
p2.speak()

&lt;span style=&#34;color:#228b22&#34;&gt;//创建一个Student类，继承于Person类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Student &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Person {
	constructor(name, age, grade) {
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;(name, age)&lt;span style=&#34;color:#228b22&#34;&gt;//必须调用super，且必须写在第一句
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.grade = grade
	}
	&lt;span style=&#34;color:#228b22&#34;&gt;//方法的重写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	speak() {
		console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;`我叫&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;，我今年&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;岁，今年上&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.grade&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;);
	}
	study() {
		console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;正在学习&amp;#34;&lt;/span&gt;);
	}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; s1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Student(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;26&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;研三&amp;#34;&lt;/span&gt;)
s1.speak()
s1.study()
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;总结：
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;1.类中的构造器不是必须写的，如果要对实例进行一些初始化的操作，如添加指定属性时再写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;2.若A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须调用的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;3.类中所定义的方法，都是放在类的原型对象上，供实例去使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;

&lt;span style=&#34;color:#228b22&#34;&gt;//另，类中允许直接写赋值语句，应用如下
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Car {
    constructor(name, price) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.price = price
	}
	a = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
	wheels = &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//类中允许直接写赋值语句，此属性会给每个实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//若要给类的原型对象自身加属性，用static关键字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; b = &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
	fn1() {
	&lt;span style=&#34;color:#228b22&#34;&gt;//这是放在类的原型对象上的方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
	fn2 = () =&amp;gt; {
	&lt;span style=&#34;color:#228b22&#34;&gt;//这是放在类的实例对象上的方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; c1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Car(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;benz&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;10000&lt;/span&gt;)
console.log(c1);&lt;span style=&#34;color:#228b22&#34;&gt;//可以利用此特性，简化react中state的编写
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(Car.b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-原生事件绑定&#34;&gt;2 原生事件绑定&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;addEventListener（事件监听器）&lt;/li&gt;
&lt;li&gt;onclick（js动态绑定）&lt;/li&gt;
&lt;li&gt;直接在标签上绑定（行内绑定）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&amp;lt;button id=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;btn1&amp;#34;&lt;/span&gt;&amp;gt;按钮1&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
&amp;lt;button id=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;btn2&amp;#34;&lt;/span&gt;&amp;gt;按钮2&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
&amp;lt;button onclick=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demo()&amp;#34;&lt;/span&gt;&amp;gt;按钮3&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/button&amp;gt;&lt;/span&gt;
&amp;lt;script&amp;gt;
    &lt;span style=&#34;color:#228b22&#34;&gt;//方式1，addEventListener（事件监听器）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; btn1 = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;btn1&amp;#39;&lt;/span&gt;)
	btn1.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;,()=&amp;gt;{
    	alert(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;按钮1被点击了&amp;#39;&lt;/span&gt;)
	})
	&lt;span style=&#34;color:#228b22&#34;&gt;//方式2，onclick（js动态绑定）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; btn2 = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;btn2&amp;#39;&lt;/span&gt;)
	btn2.onclick = ()=&amp;gt;{
    	alert(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;按钮2被点击了&amp;#39;&lt;/span&gt;)
	}
	&lt;span style=&#34;color:#228b22&#34;&gt;//方式3，直接在标签上绑定（行内绑定）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; demo(){
    	alert(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;按钮3被点击了&amp;#39;&lt;/span&gt;)
	}
	&lt;span style=&#34;color:#228b22&#34;&gt;//react推荐使用方法3
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-类中方法的this指向&#34;&gt;3 类中方法的this指向&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Student{
    constructor(name,age){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.age = age
	}
    study(){&lt;span style=&#34;color:#228b22&#34;&gt;//study方法在Student类的原型对象上，供实例对象使用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//这里的this指向Student实例对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; s1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Student(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;)
s1.study()&lt;span style=&#34;color:#228b22&#34;&gt;//通过实例调用原型对象上的study方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; x = s1.study&lt;span style=&#34;color:#228b22&#34;&gt;//将study方法赋值给了x
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;x()&lt;span style=&#34;color:#228b22&#34;&gt;//undefined，因为这属于直接调用study方法，由于类中默认开启严格模式，所以是undefined（不然应该是window对象）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//关于局部开启严格模式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; demo1(){
	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//this指向window对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
demo1()

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; demo2(){
	&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//局部开启严格模式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	console.log(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//此时是undefined，因为严格模型不让this指向window
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
demo2()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-展开运算符的用法&#34;&gt;4 展开运算符的用法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;展开一个数组&lt;/li&gt;
&lt;li&gt;数组的拼接&lt;/li&gt;
&lt;li&gt;函数传参（批量传入参数）&lt;/li&gt;
&lt;li&gt;复制对象（深复制）&lt;/li&gt;
&lt;li&gt;复制一个对象的同时修改器属性&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr1 = [&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;]    
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr2 = [&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;]    

&lt;span style=&#34;color:#228b22&#34;&gt;//1.展开一个数组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(arr1)&lt;span style=&#34;color:#228b22&#34;&gt;//[1,3,5,7,9]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(...arr1)&lt;span style=&#34;color:#228b22&#34;&gt;//1 3 5 7 9
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//2.数组的拼接
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(...[...arr1,...arr2])&lt;span style=&#34;color:#228b22&#34;&gt;//展开拼接后的数组1 3 5 7 9 2 4 6 8 10
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//3.函数传参，批量传入参数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//需求：数组求和
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; sum(...numbers) {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; numbers.reduce((preValue,currentValue) =&amp;gt; {&lt;span style=&#34;color:#228b22&#34;&gt;//这是数组中非常重要的一个方法reduce
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; preValue + currentValue
	})
}
console.log(sum(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;));&lt;span style=&#34;color:#228b22&#34;&gt;//10
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//4.复制对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; p1 = {name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsq&amp;#39;&lt;/span&gt;,age:&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;}
&lt;span style=&#34;color:#228b22&#34;&gt;//console.log(...p1);//报错，因为在原生js中，展开运算符不可以展开对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//但如果在外面包上一层展开运算符，就可以克隆一个对象（深复制），
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; p2 = {...p1}
p1.name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;zs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//更改p1的值，p2并不会受影响
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(p2,p1);

&lt;span style=&#34;color:#228b22&#34;&gt;//5.复制一个对象的同时修改其属性
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//实质上是两个对象的合并
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; p3 = {...p1,name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gsqzs&amp;#39;&lt;/span&gt;}
console.log(p3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5 对象相关知识&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; a = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; obj = {} &lt;span style=&#34;color:#228b22&#34;&gt;//需求是将其变成{name:&amp;#39;tom&amp;#39;}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 不可直接obj.a = &amp;#34;tom&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;obj[a] = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tom&amp;#34;&lt;/span&gt;
console.log(obj)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6 显示函数柯里化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//正常写法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; sum(a, b, c) {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a + b + c
}
console.log(sum(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;));

&lt;span style=&#34;color:#228b22&#34;&gt;//函数柯里化写法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; sum2(a) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (b) =&amp;gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (c) =&amp;gt; {
        	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a + b + c
        }
    }
}
console.log(sum2(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)(&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://gsemir0418.github.io/posts/react%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/ - </description>
        </item>
    
    
    
        <item>
        <title>React入门</title>
        <link>https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/</link>
        <pubDate>Sat, 20 Mar 2021 23:11:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/ -&lt;h1 id=&#34;1-react基本使用&#34;&gt;1. React基本使用&lt;/h1&gt;
&lt;h2 id=&#34;11-js库引入注意引入顺序&#34;&gt;1.1 js库引入（注意引入顺序）&lt;/h2&gt;
&lt;p&gt;1.react.development.js：react核心库&lt;/p&gt;
&lt;p&gt;2.react-dom.development.js：提供操作DOM的react扩展库&lt;/p&gt;
&lt;p&gt;3.babel.min.js：解析JSX语法代码转为js代码的库&lt;/p&gt;
&lt;h2 id=&#34;12-虚拟dom的创建&#34;&gt;1.2 虚拟DOM的创建&lt;/h2&gt;
&lt;h3 id=&#34;121-关于虚拟dom&#34;&gt;1.2.1 关于虚拟DOM&lt;/h3&gt;
&lt;p&gt;（1）本质上是object类型的&lt;strong&gt;一般对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是react内部在用，无需真实DOM上那么多属性&lt;/p&gt;
&lt;p&gt;（3）虚拟DOM最终会被React转化为真实DOM，呈现在页面上&lt;/p&gt;
&lt;h3 id=&#34;122-创建的两种方式&#34;&gt;1.2.2 创建的两种方式&lt;/h3&gt;
&lt;p&gt;（1）纯js方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = React.createElement(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;标签名&amp;#39;&lt;/span&gt;,{标签属性},&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;标签内容&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = React.createElement(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;,{id:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;title&amp;#39;&lt;/span&gt;},&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;React.createElement(&amp;#39;&lt;/span&gt;span&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;,{},&amp;#39;&lt;/span&gt;HELLO REACT!&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		可以看到，若遇标签嵌套情况，利用纯js来写非常复杂。&lt;/p&gt;
&lt;p&gt;（2）JSX方式&lt;/p&gt;
&lt;p&gt;​		是react 定义的一种类似于 XML 的 JS 扩展语法: JS + XML。本质是React.createElement(&amp;lsquo;标签名&amp;rsquo;,{标签属性},&amp;lsquo;标签内容&amp;rsquo;)方法的语法糖，极大地简化了创建虚拟DOM过程。&lt;strong&gt;在利用JSX创建之前，需要将&lt;!-- raw HTML omitted --&gt;标签的type属性由默认的text/javascript改为text/babel&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;1）JSX创建虚拟DOM的写法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = (
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;title&amp;#34;&lt;/span&gt;&amp;gt;
    	&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;span&lt;/span&gt;&amp;gt;hello,react&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;span&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt;&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）&lt;strong&gt;JSX语法&lt;/strong&gt;如下：&lt;/p&gt;
&lt;p&gt;1.遇到 &amp;lt;开头的代码，以标签的语法解析：html 同名标签转换为 html 同名元素，其它标签需要特别解析：若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。&lt;/p&gt;
&lt;p&gt;2.遇到以 { 开头的代码，以 JS 语法解析: &lt;strong&gt;标签中的 js 表达式必须用{ }包含&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;只有一个根标签&lt;/strong&gt;，若想在虚拟DOM中再新增标签，外面需要统一包一个标签&lt;/p&gt;
&lt;p&gt;4.标签必须&lt;strong&gt;闭合&lt;/strong&gt;（自闭合也行）&lt;/p&gt;
&lt;p&gt;5.标签内样式的类名指定不要用class，要用&lt;strong&gt;className&lt;/strong&gt;，例如&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;6.标签中内联样式要用**style={{key:value}}**的形式去写，多个单词的要用小驼峰,例如style={{fontSize:&amp;lsquo;29px&amp;rsquo;}}&lt;/p&gt;
&lt;h2 id=&#34;13-渲染虚拟dom&#34;&gt;1.3 渲染虚拟DOM&lt;/h2&gt;
&lt;p&gt;基本语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;ReactDOM.render(VirtualDOM,containerDOM)
ReactDOM.render(VDOM,&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;14-模块与组件的理解&#34;&gt;1.4 模块与组件的理解&lt;/h2&gt;
&lt;p&gt;模块指的是向外提供特定功能的js程序，一般就是一个js文件，模块化是为了更好地复用js，简化js的编写，提高js运行效率。模块化只针对js；而组件指的是用来实现局部功能效果的代码和资源的集合（html、css、js、image、video等），组件化是为了复用编码，简化项目编码，提高运行效率&lt;/p&gt;
&lt;p&gt;1.5 jsx练习&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;.%5Cimage-20210321123104572.png&#34; alt=&#34;image-20210321123104572&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;

    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/react.development.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/react-dom.development.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;../js/babel.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;

    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/babel&amp;#34;&lt;/span&gt;&amp;gt;
    &lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        一定注意区分【js语句（代码）】与【js表达式】
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            1.表达式：一个表达式会产生一个值，可以放任何一个需要值的地方
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                下面这些都是表达式
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                a
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                a+b
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                demo(1)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                arr.map()//用来处理数组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                function test(){}//定义方法
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;            2.语句（代码）：控制代码走向，没有值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                if(){}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                for(){}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;                switch(){case}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;    */&lt;/span&gt;
        &lt;span style=&#34;color:#228b22&#34;&gt;//模拟一些数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; data = [&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Angular&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Vue&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;React&amp;#39;&lt;/span&gt;]
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; data2 = [&amp;lt;li&amp;gt;Angular&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;, &amp;lt;li&amp;gt;Vue&amp;lt;/li&amp;gt;, &amp;lt;li&amp;gt;React&amp;lt;/li&amp;gt;]//React可以自动遍历数组&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; obj = {name1:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Angular&amp;#39;&lt;/span&gt;,name2:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Vue&amp;#39;&lt;/span&gt;,name3:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;React&amp;#39;&lt;/span&gt;}&lt;span style=&#34;color:#228b22&#34;&gt;//对象不能作为React的节点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;//jsx创建虚拟DOM
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; VDOM = (
            &amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;前端js框架列表&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/h1&amp;gt;&lt;/span&gt;
                &amp;lt;ul&amp;gt;
                    {
                        data.map((a,index)=&amp;gt;{
                            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;lt;li key={index}&amp;gt;{a}&amp;lt;&lt;span style=&#34;color:#1c7e71&#34;&gt;/li&amp;gt;/&lt;/span&gt;/虚拟dom必须有唯一标识key
                        })
                    }
                &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/div&amp;gt;&lt;/span&gt;
        )
        ReactDOM.render(VDOM, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;))
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;body&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;补充&#34;&gt;补充：&lt;/h2&gt;
&lt;p&gt;1）早期传输数据的两种格式&lt;/p&gt;
&lt;p&gt;​		最早使用XML来存储与传输数据的，XML即扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。典型写法如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;student&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Tom&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/student&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		后面改为利用JSON格式。JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。主要是得益于JSON的两个重要方法：JSON.parse()和JSON.stringfy()，分别用来快速将JSON中的数据解析为数组和对象，以及快速把JS中的数组和对象转化为JSON字符串&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;name&amp;#39;:&amp;#39;gsq&amp;#39;,&amp;#39;age&amp;#39;:26&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）XML和JSON的优缺点对比&lt;/p&gt;
&lt;p&gt;(1)可读性两者基本相同，一边是建议的语法，一边是规范的标签形式，XML可读性较好些；
(2)可扩展性方面差不多；
(3)编码难度方面，不借助工具的话，XML较为复杂；
(4)解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。
(5)流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous Javascript and JSON)了；
(7)数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些；
(8)数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互； 
(9)数据描述方面，JSON对数据的描述性比XML较差；
(10)传输速度方面， JSON的速度要远远快于XML。&lt;/p&gt;
- https://gsemir0418.github.io/posts/react%E5%85%A5%E9%97%A8/ - </description>
        </item>
    
    
    
        <item>
        <title>React简介</title>
        <link>https://gsemir0418.github.io/posts/react%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Thu, 18 Feb 2021 21:18:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/react%E7%AE%80%E4%BB%8B/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/react%E7%AE%80%E4%BB%8B/ -&lt;h1 id=&#34;1react是什么&#34;&gt;1.React是什么&lt;/h1&gt;
&lt;p&gt;用于构建&lt;strong&gt;用户界面&lt;/strong&gt;的JS库（操作DOM呈现页面）&lt;/p&gt;
&lt;p&gt;是一个将数据渲染为HTML视图的开源的JavaScript库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：https://react.docschina.org/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2谁开发的&#34;&gt;2.谁开发的&lt;/h1&gt;
&lt;p&gt;Facebook&lt;/p&gt;
&lt;h1 id=&#34;3为什么要学&#34;&gt;3.为什么要学&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原生JS操作DOM&lt;strong&gt;繁琐、效率低&lt;/strong&gt;（&lt;strong&gt;DOM-API操作UI&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用js直接操作DOM，浏览器会进行大量的&lt;strong&gt;重绘重排&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原生js没有&lt;strong&gt;组件化&lt;/strong&gt;的编码方案，代码复用率低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块化&lt;/strong&gt;是针对js的，可以把js拆分成独立的功能模块，方便复用。但是html结构和css样式，包括字体图片音频视频等，复用率低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4react的特点&#34;&gt;4.React的特点&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用&lt;strong&gt;组件化模式&lt;/strong&gt;、&lt;strong&gt;声明式编码&lt;/strong&gt;，提高开发效率及组件复用率&lt;/p&gt;
&lt;p&gt;之前使用的是&lt;strong&gt;命令式编码&lt;/strong&gt;，面向过程。比如我想喝一杯水，需要命令别人先站起来，再走到水杯旁，把我帮我拿过来等等的步骤；但是声明式编码只需我说嗓子干了，自动就会帮我把水拿过来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;React Native&lt;/strong&gt;中可以使用React语法进行&lt;strong&gt;移动端&lt;/strong&gt;开发。&lt;/p&gt;
&lt;p&gt;React Native可以使得前端开发人员使用最熟悉的js来编写安卓和ios应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;strong&gt;虚拟DOM&lt;/strong&gt;+优秀的&lt;strong&gt;Diffing算法&lt;/strong&gt;，尽量减少与真实DOM的交互&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​	虚拟DOM发生改变后会对比之前的虚拟DOM，从而减少真实DOM的更新渲染过程&lt;/p&gt;
- https://gsemir0418.github.io/posts/react%E7%AE%80%E4%BB%8B/ - </description>
        </item>
    
    
    
        <item>
        <title>展示平台说明文档</title>
        <link>https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 08 Jan 2021 23:15:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/ -&lt;h1 id=&#34;1-模型展示页面&#34;&gt;1. 模型展示页面&lt;/h1&gt;
&lt;p&gt;​		模型展示页面是基于There.js库、模型和材质加载器以及控制器，实现模型在web端的简单展示。具体实现逻辑已写好，用户只需修改obj模型路径等简单操作即可实现模型展示demo。obj模型导出及注意事项见&lt;code&gt;3dsMax技术文档&lt;/code&gt;。模板已发布到GitHub供读者学习参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GSemir0418/TemplateProjects&#34;&gt;https://github.com/GSemir0418/TemplateProjects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		下图为项目目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210108184425370.png&#34; alt=&#34;image-20210108184425370&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		其中，js文件夹包含全部Javascript脚本文件，models文件夹用来存储obj模型，index.html是项目的主页。&lt;/p&gt;
&lt;p&gt;​		js文件夹中，除index.js外，均是由Three.js为我们提供的模型加载器和控制器脚本文件。而页面的主要逻辑全部封装到了index.js中。&lt;/p&gt;
&lt;h2 id=&#34;11-更改网页名称&#34;&gt;1.1 更改网页名称&lt;/h2&gt;
&lt;p&gt;​		在index.html文件中，修改&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签内的内容即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;XXX村寨模型展示&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;12-修改模型路径&#34;&gt;1.2 修改模型路径&lt;/h2&gt;
&lt;p&gt;​		首先将obj模型拷贝至models文件夹下。&lt;/p&gt;
&lt;p&gt;​		在js/index.js文件中，修改15和16行的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//模型路径
let mat1 = &#39;./models/testobj/lancuiting.mtl&#39;;
let obj1 = &#39;./models/testobj/lancuiting.obj&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		注意路径使用&lt;strong&gt;相对路径&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;13-控制模型体积&#34;&gt;1.3 控制模型体积&lt;/h2&gt;
&lt;p&gt;​		js/index.js文件中，修改51行代码中的参数即可，注意三个数字应保持一致：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;model1.scale.set(1.4, 1.4, 1.4);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;14-其他可配置选项&#34;&gt;1.4 其他可配置选项&lt;/h2&gt;
&lt;p&gt;​		如需修改灯光位置及强度，可以修改js/index.js文件中46和47行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//括号中的2为强度
let dLight = new THREE.DirectionalLight(0xFFFFFF, 2);
//光源的位置
dLight.position.set(500, 1000, 4000);
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&#34;2-turnjs翻页特效&#34;&gt;2. Turn.js翻页特效&lt;/h1&gt;
&lt;p&gt;​		展示平台的第一个模块是&lt;strong&gt;少数民族建筑特征分析&lt;/strong&gt;。针对大量的图文资料，传统的页面布局得不到很好的展示与交互效果。为提高用户体验，选择类似书本翻页的形式作为展示图文视频资料的方式。Turn.js是一个JavaScript库，利用HTML5的所有优点，可以使内容呈现起来像一本真正的书或杂志。&lt;/p&gt;
&lt;p&gt;​		关于Turn.js的入门教程可以看siki学院的免费课程，也可以通过官网进行学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;siki学院：http://www.sikiedu.com/course/517/tasks&lt;/p&gt;
&lt;p&gt;Turn.js官网：http://www.turnjs.com/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		由于少数民族建筑资料篇幅较多，文章内容比较复杂，且Turn.js并没有为用户提供书页模板，全部样式都是用户在CSS中定义的。考虑到书页制作的便捷性与美观性，选择PPT来制作展示书籍的内容，再以加载图片的方式将内容加载到网页端，实现具有翻页效果的少数民族建筑特征分析资料展示模块。&lt;/p&gt;
&lt;p&gt;整个模块的制作流程主要分两部分，&lt;strong&gt;图文内容的准备工作&lt;/strong&gt;与&lt;strong&gt;翻页效果的实现&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;21-图文内容的准备工作&#34;&gt;2.1 图文内容的准备工作&lt;/h2&gt;
&lt;p&gt;​		PPT模板及主要实现代码已与平台源代码一同发布至GIthub供大家学习参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GSemir0418/TemplateProjects&#34;&gt;https://github.com/GSemir0418/TemplateProjects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		模板的样式已经设计制作完成，包括封面的设计、内容的布局和字体的选择。也可以根据自己的审美，重新设计排版布局。注意页面设计中的方向要保证是纵向，具体尺寸取决于Turn.js中定义的宽和高。参考配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210109193919127.png&#34; alt=&#34;image-20210109193919127&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		将撰写好的少数民族建筑特征分析图文资料复制到PPT模板中，进行排版布局后，完成图文内容的准备工作。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		点击右上角&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;另存为&lt;/code&gt;，设置导出路径后，考虑到网页端的加载效率，文件类型选择较小的&lt;code&gt;.jpg&lt;/code&gt;。单击&lt;code&gt;保存&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出的提示框中，选择&lt;code&gt;每张幻灯片&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210109203901828.png&#34; alt=&#34;image-20210109203901828&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		导出完成后如下图。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		为了加载图片的代码编写的简洁性，需要批量修改每张图片的名字。网上有很多批量修改文件名的方法，这里选择一款解压缩软件&lt;code&gt;好压&lt;/code&gt;内置的&lt;code&gt;批量文件改名&lt;/code&gt;功能，可以在&lt;code&gt;开始&lt;/code&gt;菜单中找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210109204553287.png&#34; alt=&#34;image-20210109204553287&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		首先根据提示，批量&lt;code&gt;添加&lt;/code&gt;所有图片文件；在命名规则中填入&lt;code&gt;#&lt;/code&gt;。单击&lt;code&gt;开始重命名&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		至此，完成翻页效果的素材准备工作。&lt;/p&gt;
&lt;h2 id=&#34;22-翻页效果的实现&#34;&gt;2.2 翻页效果的实现&lt;/h2&gt;
&lt;p&gt;​		将图片文件夹重命名为英文名称，例如miao_img，将其拷贝到/ADP/turn_img路径下。批量加载的代码已写好，需要调整page/miao_turn_page.html中的几行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//line 47 修改路径&amp;quot;turn_img/miao_img&amp;quot;
&amp;quot;&amp;lt;img src=\&amp;quot;../turn_img/miao_img/&amp;quot; + i + &amp;quot;.jpg\&amp;quot; alt=\&amp;quot; \&amp;quot; width=\&amp;quot;525\&amp;quot; height=\&amp;quot;700\&amp;quot;&amp;gt;\n&amp;quot; +

//line 100 修改路径&amp;quot;turn_img/miao_img&amp;quot;
&amp;lt;img src=&amp;quot;../turn_img/miao_img/1.jpg&amp;quot; alt=&amp;quot; &amp;quot; width=&amp;quot;525&amp;quot; height=&amp;quot;700&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		加载完成后，根据实际页码，调整目录页数及跳转按钮的页码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//line 89-91 pageTo(修改这里面的数字)
&amp;lt;a href=&amp;quot;javascript:pageTo(1)&amp;quot; class=&amp;quot;btn btn-secondary&amp;quot; role=&amp;quot;button&amp;quot;&amp;gt;封面&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;javascript:pageTo(2)&amp;quot; class=&amp;quot;btn btn-secondary&amp;quot; role=&amp;quot;button&amp;quot;&amp;gt;目录&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;javascript:pageTo(72)&amp;quot; class=&amp;quot;btn btn-secondary&amp;quot; role=&amp;quot;button&amp;quot;&amp;gt;封底&amp;lt;/a&amp;gt;

//line 112-119 pageTo(修改这里面的数字) 修改目录文字内容
&amp;lt;div class=&amp;quot;list-group&amp;quot; style=&amp;quot;left: 50%&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:pageTo(4)&amp;quot;
    class=&amp;quot;list-group-item list-group-item-action&amp;quot;&amp;gt;1.村寨概述-1&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:pageTo(40)&amp;quot;
    class=&amp;quot;list-group-item list-group-item-action&amp;quot;&amp;gt;2.村落及居住建筑分析-37&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;javascript:pageTo(56)&amp;quot;
    class=&amp;quot;list-group-item list-group-item-action&amp;quot;&amp;gt;3.建筑遗传特征-53&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		完成翻书效果展示少数民族建筑特征模块的制作。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3建筑展示平台&#34;&gt;3.建筑展示平台&lt;/h1&gt;
&lt;p&gt;​		展示平台的第二部分是&lt;strong&gt;建筑结构体系展示部分&lt;/strong&gt;，也是平台的核心部分。包括模型爆炸、构件动态拆分以及模型剖切三大功能模块。由于具体实现逻辑已封装完毕，只需修改模板中的几行代码即可。模板下载链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GSemir0418/TemplateProjects&#34;&gt;https://github.com/GSemir0418/TemplateProjects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;31-自定义主页样式&#34;&gt;3.1 自定义主页样式&lt;/h2&gt;
&lt;p&gt;​		模板中的主页样式如下图：&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		文字部分及插图内容均可自定义，具体替换位置在根目录下的index.html中很明显，这里不再赘述。值得一提的是背景图片的修改路径，需要修改index_assets/css/main.css文件的1627行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-image: linear-gradient(to top, rgba(46, 49, 65, 0.8), rgba(46, 49, 65, 0.8)), url(&amp;quot;../../index_images/bg.jpg&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;32-替换obj模型&#34;&gt;3.2 替换obj模型&lt;/h2&gt;
&lt;p&gt;​		首先将obj模型及DAE模型拷贝至models文件夹下。&lt;/p&gt;
&lt;p&gt;​		在js/miao_model1.js以及js/miao_model2.js文件中，修改变量mat1和obj1的值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//模型路径
let mat1 = &#39;../models/testModel/objTest/objTest.mtl&#39;;
let obj1 = &#39;../models/testModel/objTest/objTest.obj&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​		注意路径使用&lt;strong&gt;相对路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		模型剖切模块使用DAE格式的模型文件，在js/miao_simulation.js文件中，修改第28行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;loader.load( &#39;../models/testModel/DAETest/DAEtest.DAE&#39;, function ( collada ) {
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;33-其他可配置选项&#34;&gt;3.3 其他可配置选项&lt;/h3&gt;
&lt;p&gt;​		可参考本文第一章节中的部分内容。&lt;/p&gt;
- https://gsemir0418.github.io/posts/%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/ - </description>
        </item>
    
    
    
        <item>
        <title>3dsMax技术文档</title>
        <link>https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 08 Jan 2021 16:41:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ -&lt;h1 id=&#34;1-3dsmax概述&#34;&gt;1. 3dsMax概述&lt;/h1&gt;
&lt;p&gt;​		3dsMax是由&lt;code&gt;AutoDesk&lt;/code&gt;公司开发的&lt;strong&gt;三维模型与动画制作渲染软件&lt;/strong&gt;，它被广泛应用于多个领域，包括游戏设计、广告设计、建筑设计和影视制作等。其&lt;strong&gt;优点&lt;/strong&gt;是具有强大的材质编辑和灯光处理功能，并且相关的学习资源非常丰富。在后期的模型渲染上功能强大，能够得到逼真的模型。同其他建模软件相比，3dsMax创建的模型面片数量较少，占用空间小，模型的处理速度也比较快。本课题正是应用其强大的模型兼容性以及材质编辑功能，作为单体建筑模型&lt;strong&gt;后期纹理映射&lt;/strong&gt;和&lt;strong&gt;OBJ模型导出&lt;/strong&gt;的重要软件。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-3dsmax软件安装&#34;&gt;2. 3dsMax软件安装&lt;/h1&gt;
&lt;p&gt;​		3dsMax软件发展至今，从最初的3D Studio MAX 1.0开始，其版本迭代更新二十余次，截至文章发布前，Autodesk公司已推出3dsMax 2021。考虑到兼容性、稳定性等问题，推荐安装&lt;code&gt;3dsMax 2016&lt;/code&gt;之后的版本。&lt;/p&gt;
&lt;p&gt;​		本章以&lt;code&gt;3dsMax 2020&lt;/code&gt;软件安装为例，详细介绍软件安装的过程及注意事项。&lt;/p&gt;
&lt;h2 id=&#34;21-解压缩安装包&#34;&gt;2.1 解压缩安装包&lt;/h2&gt;
&lt;p&gt;​		将安装包及注册机文件解压缩至目标文件夹，注意&lt;strong&gt;目标文件夹名称及路径应保证全英文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		为防止安装破解过程中出现未知错误，建议&lt;strong&gt;安装前关闭所有杀毒软件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;22-安装软件&#34;&gt;2.2 安装软件&lt;/h2&gt;
&lt;p&gt;​		进入安装包文件夹，右键单击&lt;code&gt;Setup.exe&lt;/code&gt;，选择以管理员身份运行；&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;在打开的窗口中选择&lt;code&gt;安装（在此计算机安装）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;许可协议选择&lt;code&gt;我接受&lt;/code&gt;，单击&lt;code&gt;下一步&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;设置安装路径后，点击安装即可。&lt;strong&gt;注意路径仍要保证全英文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，选择&lt;code&gt;立即启动&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-破解软件&#34;&gt;2.3 破解软件&lt;/h2&gt;
&lt;p&gt;​		第一次进入软件后，选择&lt;code&gt;enter a serial number&lt;/code&gt;输入序列号。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		选择 &lt;code&gt;I Agree&lt;/code&gt;我同意。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		进入激活页面，选择&lt;code&gt;Activate&lt;/code&gt;激活。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在&lt;code&gt;Serial Number&lt;/code&gt;栏中填写序列号&lt;code&gt;666-69696969&lt;/code&gt;，单击&lt;code&gt;Next&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		第一次会提醒”检测到无效的序列号“，此时选择&lt;code&gt;重新输入&lt;/code&gt;，将序列号再次输入即可。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		当进入到激活选项窗口，复制&lt;code&gt;Request code&lt;/code&gt;请求码。右键单击安装包中的&lt;code&gt;xf-adesk20.exe&lt;/code&gt;破解工具，选择以管理员身份运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103222250253.png&#34; alt=&#34;image-20210103222250253&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		将请求码复制到破解工具中的&lt;code&gt;Request&lt;/code&gt;栏后，先单击&lt;code&gt;Patch&lt;/code&gt;，再点击&lt;code&gt;Generate&lt;/code&gt;，复制Activation栏中自动生成的激活码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103222411949.png&#34; alt=&#34;image-20210103222411949&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		拿到激活码后，回到激活选项页面，选择&lt;code&gt;I have an activation code from Autodesk&lt;/code&gt;，把激活码复制到输入框后，点击&lt;code&gt;Next&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103222438931.png&#34; alt=&#34;image-20210103222438931&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		激活完成，选择&lt;code&gt;Finish&lt;/code&gt;退出激活窗口。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		至此，3dsMax 2020安装完成。&lt;/p&gt;
&lt;h2 id=&#34;24-修改软件语言&#34;&gt;2.4 修改软件语言&lt;/h2&gt;
&lt;p&gt;​		3dsMax软件支持简体中文，切换中文版本也很简单，点击&lt;code&gt;开始&lt;/code&gt;，找到&lt;code&gt;Autodesk&lt;/code&gt;文件夹，选择&lt;code&gt;3dMax 2020 - simplified Chinese&lt;/code&gt;即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3-fbx模型导入&#34;&gt;3. FBX模型导入&lt;/h1&gt;
&lt;p&gt;​		导入FBX模型到3dmax有两种方法供大家参考。&lt;/p&gt;
&lt;h2 id=&#34;31-拖拽导入&#34;&gt;3.1 拖拽导入&lt;/h2&gt;
&lt;p&gt;​		直接将模型文件拖至任意视图窗口后，在弹出的选项中选择“导入文件”；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103224446456.png&#34; alt=&#34;image-20210103224446456&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-选项导入&#34;&gt;3.2 选项导入&lt;/h2&gt;
&lt;p&gt;​		单击菜单栏&lt;code&gt;文件&lt;/code&gt;选项，选择&lt;code&gt;导入&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在随后弹出来的导入选项中，&lt;strong&gt;注意将“动画”、“摄像机”及“灯光”选项取消勾选。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		导入后效果如下图，此时每个构件都没有贴图，修改器属性均为“可编辑网格”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210103224800108.png&#34; alt=&#34;image-20210103224800108&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;4-模型预处理&#34;&gt;4. 模型预处理&lt;/h1&gt;
&lt;p&gt;​		正式贴图前，需要对模型进行初步处理，包括&lt;strong&gt;优化模型体量&lt;/strong&gt;以及构件分类命名，以提高后期平台开发过程中的显示性能，为展示功能的实现做准备。&lt;/p&gt;
&lt;h2 id=&#34;41-模型优化&#34;&gt;4.1 模型优化&lt;/h2&gt;
&lt;p&gt;​		模型优化主要是针对模型数量及面片数量较大的部分，以瓦片屋顶为例。由于瓦片模型数量多，面片数大，不方便后期的贴图及模型处理，因此首先选中一侧屋顶，在命令面板中选择&lt;code&gt;实用工具&lt;/code&gt;，依次点击&lt;code&gt;塌陷&lt;/code&gt;、&lt;code&gt;塌陷选定模型&lt;/code&gt;，使一侧的屋顶塌陷融合成一个整体。另外一侧屋顶可以以复制旋转的方式替代镜像的操作。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-构件分类命名&#34;&gt;4.2 构件分类命名&lt;/h2&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		在revit建模过程中，对于每个族构件模型都进行了命名。由于revit导出的fbx模型，其构件信息包含一些无用字段，因此需要利用3dsMax软件进行构件再次分类命名，为展示平台的构件信息显示功能做准备，从而提升用户体验。&lt;/p&gt;
&lt;p&gt;​		以门板族构件为例，可以根据其相对于建筑的不同方位与材质进行命名，如前部木制门板；&lt;/p&gt;
&lt;p&gt;​		以屋顶为例，可以根据其结构特点结合当地命名习惯进行命名，如椽子、檩条等。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;5-贴图&#34;&gt;5 贴图&lt;/h1&gt;
&lt;h2 id=&#34;51-整理贴图&#34;&gt;5.1 整理贴图&lt;/h2&gt;
&lt;p&gt;​		根据点云数据及现场调研收集到的图像等信息，搜集整理各构件的纹理贴图，注意贴图的&lt;strong&gt;名称不能出现中文&lt;/strong&gt;，考虑到在网上下载的贴图有乱码的情况，因此建议将全部贴图&lt;strong&gt;重命名为拼音字母&lt;/strong&gt;。贴图的&lt;strong&gt;路径最好也不要出现中文&lt;/strong&gt;。正式贴图之前，建议将贴图素材统一整理到模型根目录下的/tietu文件夹中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107104809527.png&#34; alt=&#34;image-20210107104809527&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-贴图步骤&#34;&gt;5.2 贴图步骤&lt;/h2&gt;
&lt;p&gt;​		在3dmax界面下，按&lt;code&gt;M&lt;/code&gt;调出材质编辑器，将贴图素材用鼠标拖放至材质球上即可，贴图与材质球一一对应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105405290.png&#34; alt=&#34;image-20210107105405290&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		随后将附好材质的材质球直接拖至对应的模型构件上。在模型构件命令面板的修改器列表中，选择&lt;code&gt;UVW贴图&lt;/code&gt;（可以提前将此按钮添加到修改器集中，节约查找UVW贴图命令的操作），调整UVW属性中&lt;code&gt;贴图&lt;/code&gt;、&lt;code&gt;长宽高&lt;/code&gt;和&lt;code&gt;UVW向平铺&lt;/code&gt;等相关参数，使效果尽可能接近真实。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105417385.png&#34; alt=&#34;image-20210107105417385&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		贴图过程中要&lt;strong&gt;及时保存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		下图为贴图完成后的效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105428481.png&#34; alt=&#34;image-20210107105428481&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		模型纹理贴图完成后，还需将模型位置调整至中心坐标位置（视窗网格的中心）。可以按&lt;code&gt;G&lt;/code&gt;显示或者隐藏视窗网格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105443894.png&#34; alt=&#34;image-20210107105443894&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105450400.png&#34; alt=&#34;image-20210107105450400&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;6-模型归档和导出&#34;&gt;6 模型归档和导出&lt;/h1&gt;
&lt;h2 id=&#34;61-模型归档&#34;&gt;6.1 模型归档&lt;/h2&gt;
&lt;p&gt;​		&lt;strong&gt;归档&lt;/strong&gt;，就是将当前场景中的模型文件、材质贴图及贴图路径整理出来，另存成为一个压缩包，方便模型的存储和传输。归档操作很简单，菜单栏中选择&lt;code&gt;文件&lt;/code&gt;→&lt;code&gt;归档&lt;/code&gt;即可；老版本（2017及之前）点击左上角图标→&lt;code&gt;另存为&lt;/code&gt;→&lt;code&gt;归档&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107105534632.png&#34; alt=&#34;image-20210107105534632&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		归档的模型解压缩并打开后，在3dsMax中浏览虽然是没有问题的，但在导出obj模型前，还需&lt;strong&gt;修改模型的路径&lt;/strong&gt;，否则导出的obj模型会出现材质丢失的情况。为避免这种情况产生，建议在完成模型贴图后，直接在本机导出所需的其他格式模型；若要对原模型进行存储或传输，需要归档后在另外的机器导出模型时，就要对模型的贴图路径进行重定向。&lt;/p&gt;
&lt;p&gt;​		在右侧命令面板中，选择&lt;code&gt;实用工具&lt;/code&gt;选项（扳手的图标），点击&lt;code&gt;更多...&lt;/code&gt;选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107200949507.png&#34; alt=&#34;image-20210107200949507&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出来的窗口中选择&lt;code&gt;位图/光度学路径&lt;/code&gt;，点击确定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107201059874.png&#34; alt=&#34;image-20210107201059874&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		随后在右侧命令面板会出现&lt;code&gt;路径编辑器&lt;/code&gt;选项，点击&lt;code&gt;编辑资源&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107201231060.png&#34; alt=&#34;image-20210107201231060&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		此时弹出&lt;code&gt;位图/光度学路径编辑器&lt;/code&gt;窗口，在这里将显示全部的贴图路径信息。点击&lt;code&gt;选择丢失的文件&lt;/code&gt;，我们会看到全部的文件都变为选中状态，说明全部贴图路径均发生了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107201331968.png&#34; alt=&#34;image-20210107201331968&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		点击下方&lt;code&gt;...&lt;/code&gt;按钮，找到解压后模型贴图存放的文件夹，点击&lt;code&gt;使用路径&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		之后点击&lt;code&gt;设置路径&lt;/code&gt;，将原路径修改为正确的路径。可以再次单击&lt;code&gt;选择丢失的文件&lt;/code&gt;，此时已没有文件被选中，说明全部路径已修改完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107202036510.png&#34; alt=&#34;image-20210107202036510&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;62-obj模型导出&#34;&gt;6.2 obj模型导出&lt;/h2&gt;
&lt;p&gt;​		依次点击&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;导出&lt;/code&gt;，配置好导出路径（纯英文）及文件名后，保存类型选择&lt;code&gt;gw::OBJ-Exporter(*.OBJ)&lt;/code&gt;，单击&lt;code&gt;保存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出的窗口中，需要继续配置obj模型导出的参数。面需要改为&lt;code&gt;三角形&lt;/code&gt;，精度改为&lt;code&gt;5&lt;/code&gt;，材质导出选项中，勾选使用材质路径，并修改路径名为&lt;code&gt;./&lt;/code&gt;。配置完成后，点击&lt;code&gt;导出&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107215114429.png&#34; alt=&#34;image-20210107215114429&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		至此，obj模型文件、mtl材质文件以及贴图文件已成功导出。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		由于3dsMax软件中obj模型导出模块的字符集与网页展示平台中的字符集不匹配，导致构件信息显示错误，出现乱码的情况。之前采用的是使用JavaScript数组对象存储模型构件信息，按构件id来匹配显示构件信息，虽然解决了上述问题，但既费时又费力。所以我们选择从根本上解决此问题——修改obj文件的字符集。方法有很多，这里采用&lt;code&gt;notepad++&lt;/code&gt;来处理字符编码的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：https://notepad-plus-plus.org/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​		使用&lt;code&gt;notepad++&lt;/code&gt;打开obj文件，单击&lt;code&gt;编码&lt;/code&gt;，选择&lt;code&gt;转为UTF-8编码&lt;/code&gt;后，保存文件即可。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;63-dae模型导出&#34;&gt;6.3 DAE模型导出&lt;/h2&gt;
&lt;p&gt;​		DAE模型主要用于模型剖切模块，无需导出材质。导出步骤与上文相同，依次点击&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;导出&lt;/code&gt;，配置好导出路径（纯英文）及文件名后，保存类型选择&lt;code&gt;Autodesk Collada(*.DAE)&lt;/code&gt;，单击&lt;code&gt;保存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;​		在弹出的导出选项中，将动画、摄像机和灯光取消勾选。单击&lt;code&gt;确定&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image-20210107221009764.png&#34; alt=&#34;image-20210107221009764&#34;&gt;&lt;/p&gt;
- https://gsemir0418.github.io/posts/3dmax%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ - </description>
        </item>
    
    
    
        <item>
        <title>Revit建模技术文档</title>
        <link>https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
        <pubDate>Sun, 03 Jan 2021 16:41:51 +0800</pubDate>
        
        <guid>https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
        <description>GSemir Blog https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ -&lt;h1 id=&#34;1-revit概述&#34;&gt;1. Revit概述&lt;/h1&gt;
&lt;h1 id=&#34;2安装软件&#34;&gt;2.安装软件&lt;/h1&gt;
&lt;h1 id=&#34;3点云数据导入&#34;&gt;3.点云数据导入&lt;/h1&gt;
&lt;h2 id=&#34;31-直接导入&#34;&gt;3.1 直接导入&lt;/h2&gt;
&lt;h2 id=&#34;32-recap&#34;&gt;3.2 Recap&lt;/h2&gt;
&lt;h1 id=&#34;4构件族与模型搭建&#34;&gt;4.构件族与模型搭建&lt;/h1&gt;
&lt;h2 id=&#34;41-建模流程概述&#34;&gt;4.1 建模流程概述&lt;/h2&gt;
&lt;h2 id=&#34;42-轴网布局&#34;&gt;4.2 轴网布局&lt;/h2&gt;
&lt;h2 id=&#34;43-木框架搭建&#34;&gt;4.3 木框架搭建&lt;/h2&gt;
&lt;h2 id=&#34;44-屋顶&#34;&gt;4.4 屋顶&lt;/h2&gt;
&lt;h3 id=&#34;441-歇山式屋顶&#34;&gt;4.4.1 歇山式屋顶&lt;/h3&gt;
&lt;h3 id=&#34;442-悬山式屋顶&#34;&gt;4.4.2 悬山式屋顶&lt;/h3&gt;
&lt;h2 id=&#34;45-门板&#34;&gt;4.5 门板&lt;/h2&gt;
&lt;h2 id=&#34;46-其他构件&#34;&gt;4.6 其他构件&lt;/h2&gt;
&lt;h2 id=&#34;47-fbx模型导出&#34;&gt;4.7 FBX模型导出&lt;/h2&gt;
&lt;h1 id=&#34;5绘制施工图纸&#34;&gt;5.绘制施工图纸&lt;/h1&gt;
- https://gsemir0418.github.io/posts/revit%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/ - </description>
        </item>
    
    
  </channel>
</rss> 